<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>

	<div class="theme">Основное</div>
	<a href="#obj-main-theory">Теория</a>
	<a href="#obj-main-methods">Методы</a>

	<div class="theme">Объекты ES6</div>
	<a href="#obj-create">Литеральная нотация</a>
	<a href="#obj-for">Перебор объекта</a>
	<a href="#obj-constructor">Конструктор создания объекта</a>
	<a href="#obj-prototype-create">Прототип</a>
	<a href="#descriptor">Дескрипторы свойств</a>
	<a href="#extends-obj">Расширяемость объектов</a>
	<a href="#object-conversion"><bg-menu>toString</bg-menu> <bg-menu>valueOf</bg-menu></a>
	<a href="#class-instanceof"><bg-menu>instanceof</bg-menu></a>
	<a href="#obj-samples">Примеры</a>
	
	<div class="theme">Классы ES6</div>
	<a href="#class-theory">Теория</a>
	<a href="#class-create">Объявление</a>
	<a href="#class-inherit">Наследование</a>
	<a href="#class-expression">Выражения классов</a>

	<div class="theme">ES5 «Функциональный стиль»</div>
	<a href="#class-es5-theory">Теория</a>
	<a href="#class-es5-func">Объявление</a>
	<a href="#class-es5-private">Приватный метод</a>
	<a href="#class-es5-getters">Геттеры и сеттеры</a>
	<a href="#class-es5-inherit">Наследование</a>
	<a href="#class-es5-return">Правила обработки return</a>

	<div class="theme">ES5 «Прототипный стиль»</div>
	<a href="#class-es5-proto-main">Основное</a>
	<a href="#class-es5-proto-prototype">Свойство prototype</a>
	<a href="#class-es5-proto-methods">Добавление методов</a>
	<a href="#class-es5-proto-inherit">Наследование классов</a>
	<a href="#class-mixins">Примеси</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">




<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-main-theory">Теория</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<img src="img/js/proto.png" height="450px" class="center">

<ul class="list-point">
	<b>ХРАНЕНИЕ И КОПИРОВАНИЕ</b>
	<li><u>Примитивные типы данных</u> - хранение и копирование <bg-list>«по значению»</bg-list>. В результате копирования получатся две полностью независимые переменные</li>
	<li><u>Объекты</u> - хранение и копирование <bg-list>«по ссылке»</bg-list>. В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него. При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Получили две переменные, в которых находятся ссылки на один и тот же объект</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-main-methods">Методы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h4>Методы</h4>
<pre><code class="js">
var a = parent <bg-code>instanceof</bg-code> ClassParent; // проверка, какому классу принадлежит объект, с учетом прототипного наследования
var obj = Object.<bg-code>assign</bg-code>({name:'Tony'}, {age:25}, {test:'test'}); // используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект
</code></pre>

<h4>Методы для работы с __proto__</h4>
<pre><code class="js">
Object.<bg-code>create</bg-code>(proto, descriptors); // добавление прототипа при создании объекта (создаёт пустой объект с __proto__, равным первому аргументу, второй содержит дескрипторы свойств)
Object.<bg-code>setPrototypeOf</bg-code>(obj, proto); // добавление прототипа после создания объекта (устанавливает obj.__proto__ = proto)
Object.<bg-code>getPrototypeOf</bg-code>(obj);        // возвращает obj.__proto__
</code></pre>

<pre><code class="js">
ObjChild.<bg-code>isPrototypeOf</bg-code>(ObjParent); // является ли объект ObjParent прототипом для объекта ObjChild
</code></pre>

<h4>Перечисление всех свойств объекта</h4>
<pre><code class="js">
for(let key <bg-code>in</bg-code> obj) { obj[key] }         // перебирает все перечисляемые свойства объекта и его цепочку прототипов
var a = Object.<bg-code>keys</bg-code>(obj);                // возвращает массив со всеми собственными (те, что в цепочке прототипов, не войдут в массив) именами перечисляемых свойств объекта
var a = Object.<bg-code>keys</bg-code>(obj).<bg-code>length</bg-code>;         // количество свойств
var a = Object.<bg-code>getOwnPropertyNames</bg-code>(obj); // возвращает массив содержащий все имена своих свойств (перечисляемых и неперечисляемых) объекта
</code></pre>

<h4>Проверка наличия свойства</h4>
<ul class="list-point">
	<li>Можно обратиться к любому свойству объекта, даже если его нет. Если свойство не существует, вернется undefined</li>
</ul>
<pre><code class="js">
var a = obj.name;                        // проверка наличия свойсва 'name' в объекте (не различает отсутствующие свойства и те что были установлен в undefined)
var a = 'name' <bg-code>in</bg-code> obj;                   // проверка наличия свойсва 'name' в объекте (различает отсутствующие свойства и те что были установлен в undefined)
var a = obj.<bg-code>hasOwnProperty</bg-code>('name');      // проверка наличия свойства 'name' в объекте (не берет наследованные свойства)
</code></pre>

<h4>Прототипное наследование</h4>
<pre><code class="js">
ClassChild.<bg-code>prototype</bg-code>.parentFunc = function() {}         // запись метода в прототип
ClassChild.<bg-code>prototype</bg-code>.parentProp = function() {}         // запись свойства в прототип
ClassChild.<bg-code>prototype</bg-code> = <bg-code>Object.create</bg-code>(ClassParent.prototype); // наследования методов и свойств из ClassParent.prototype
</code></pre>

<h4>Дескрипторы свойств</h4>
<pre><code class="js">
Object.<bg-code>getOwnPropertyDescriptor</bg-code>(obj, 'name');  // получение дескриптора свойств
Object.<bg-code>defineProperty</bg-code>(obj, prop, descriptor);  // переопределение дескриптора свойств
Object.<bg-code>defineProperties</bg-code>(obj, descriptors);     // позволяет объявить сразу несколько свойств
</code></pre>


<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->
<h1>Объекты</h1>
<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-create">Литеральная нотация</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Литеральная нотация</h3>
<!------------------------------------------------------>
<pre><code class="js">
var property = 'lastName';

var person = {
	firstName: 'Brad',
	[property]: 'Stark',
	age: 25,
	children: ['Liza', 'Petro'],
	address: {
		street: '555 Some st',
		city: 'Boston',
		state: 'MA'
	},
	getName() {
		return this.firstName;
	}, 
	<bg-code>get</bg-code> fullName() {
		return this.firstName + ' ' + this.lastName;
	}, 
	<bg-code>set</bg-code> fullName(value) {
		this.firstName = value;
	}
}
</code></pre>

<h4>Обращение к свойствам и методам</h4>
<pre><code class="js">
var a = person.firstName;      // точечная нотация (Dot notation)
var a = person['firstName'];   // скобочная нотация (Bracket notation)
var a = person.children[0];    // обращение к свойству (массив)
var a = person.address.street; // обращение к свойству (объект)
var a = person.getName();      // обращение к методу
</code></pre>

<h4>Обновление и удаление свойства</h4>
<pre><code class="js">
person.firstName = 'Tony';     // обновление свойства
person.height = 190;           // задание нового свойства
delete person.firstName;       // удаление свойства (можно удалить только ненаследованные свойства объекта, наследованные свойства удаляются у прототипа)
</code></pre>

<h4>Добавление метода</h4>
<pre><code class="js">
person.greet = function() {
	console.log('hi');
}
</code></pre>

<h4>Геттеры и сеттеры</h4>
<pre><code class="js">
person.fullName = 'Steve';     // сеттер
var a = person.fullName;       // геттер (result = Steve Stark)
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-for">Перебор объекта</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<bg-list>for..in</bg-list>
<ul class="list-point">
	<li>Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые или числовые строки сортируются</li>
</ul>
<pre><code class="js">
for(let key <bg-code>in</bg-code> obj) {
	console.log(key);      // ключи 
	console.log(obj[key]); // значения
} 
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-constructor">Конструктор создания объекта</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var apple = new Object();
apple.color = 'green';
apple.shape = 'round';
apple.describe = function() {
	return 'An apple is ' + this.color;
}

var a = apple.color;
var a = apple.describe();
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-prototype-create">Создание прототипа</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<b>ПРОТОТИП</b>
	<li>У каждого <u>объекта</u> есть <u>прототип</u>, от которого он наследует <u>свойства</u> и <u>методы</u>. Если объект не включает в себя запрошенное свойство, JavaScript выполнит поиск этого свойства в прототипе объекта. При этом поиск будет выполняться по <u>цепочке прототипов</u> до тех пор, пока не будет найдено то, что нужно. Если же поиск успехом не увенчается, будет возвращена ошибка</li>
	<br>
</ul>

<pre><code class="js">
// объект
var Human = {
	type: "Human",
	head: 1,
	legs: 2
};
// прототип
var Megahuman = <bg-code>Object.create</bg-code>(Human);
</code></pre>

<div class="container-flex"><div class="container-half"><pre><code class="js">
Megahuman.type; // Human
Megahuman.head; // 1
</code></pre></div><div class="container-half"><pre><code class="js">
Megahuman.head = 2; // 2
Human.head;         // 1
</code></pre></div></div>

<div class="container-flex"><div class="container-half"><pre><code class="js">
Megahuman.hands = 10; // 10
Human.hands;          // undefined
</code></pre></div><div class="container-half"><pre><code class="js">
Human.face;     // undefined
Megahuman.face; // undefined
</code></pre></div></div>

<div class="container-flex"><div class="container-half"><pre><code class="js">
Human.face = "okay"; // okay
Megahuman.face;      // okay
</code></pre></div><div class="container-half"><pre><code class="js">
Megahuman.face = "awesome"; // awesome
Human.face;                 // okay
</code></pre></div></div>

<pre><code class="js">
Human.<bg-code>isPrototypeOf</bg-code>(Megahuman); // является ли объект Human прототипом для объекта Megahuman
</code></pre>

<!------------------------------------------------------>
<h3>Удаление свойств</h3>
<!------------------------------------------------------>
<pre><code class="js">
// объект
var Human = {
	type: "Human",
	head: 1,
	legs: 2
};

// прототип
var Megahuman = Object.create(Human);
Megahuman.head = 2; // 2
delete Megahuman.head;
Megahuman.head;     // 1
</code></pre>

<!------------------------------------------------------>
<h3>Конструктор прототипа</h3>
<!------------------------------------------------------>
<pre><code class="js red">
var Person = {
    constructor(name, age) {
        this.name = name;
        this.age = age;
        return this;
    },
    greet() {
        console.log('Hi ' + this.name);
    }
}

var person = Object.create(Person).constructor("Jack", 25);

var a = person.name;
person.greet();
</code></pre>

<h4>Изменение конструктора</h4>
<pre><code class="js red">
var WebDeveloper = Object.create(Person);

WebDeveloper.constructor = function(name, age, skills) {
    Person.constructor.apply(this, arguments);
    this.skills = skills || [];
    return this;
}
WebDeveloper.develop = function() {
    console.log('In Work');
}
var developer = Object.create(WebDeveloper).constructor('Jack', 25, ['html', 'css', 'js']);

console.log(developer.skills);
developer.develop();
console.log(developer.name);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="descriptor">Дескрипторы свойств</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li><bg-list>Свойства объекта</bg-list> имеют: <u>имя</u>, <u>значение</u> (атрибут value), <u>атрибуты</u> (writable, enumerable, configurable)</li>
</ul>

<pre><code class="js">
Object.<bg-code>getOwnPropertyDescriptor</bg-code>(obj, 'name');  // получение дескриптора свойств
Object.<bg-code>defineProperty</bg-code>(obj, prop, descriptor);  // переопределение дескриптора свойств
Object.<bg-code>defineProperties</bg-code>(obj, descriptors);     // позволяет объявить сразу несколько свойств
</code></pre>

<!------------------------------------------------------>
<h3>Получение дескриптора свойств</h3>
<!------------------------------------------------------>
<pre><code class="js">
var person = {
	name: 'Tony',
	age: 20
}
var a = Object.<bg-code>getOwnPropertyDescriptor</bg-code>(person, 'name');
// {value: "Tony", writable: true, enumerable: true, configurable: true } 
</code></pre>

<!------------------------------------------------------>
<h3>Переопределение дескриптора свойств</h3>
<!------------------------------------------------------>
<pre><code class="js">
Object.<bg-code>defineProperty</bg-code>(obj, prop, descriptor)
	obj        // объект, в котором объявляется свойство
	prop       // имя свойства, которое нужно объявить или модифицировать
	descriptor // дескриптор - объект, который описывает поведение свойства
</code></pre>

<pre><code class="js">
// 1-объект, 2-свойство, 3-дескриптор
Object.<bg-code>defineProperty</bg-code>(person, 'name', {
	<bg-light>value</bg-light>: 'Jack',       // значение свойства (по умолчанию undefined)
	<bg-light>writable</bg-light>: false,     // значение свойства можно менять (по умолчанию false)
	<bg-light>configurable</bg-light>: false, // возможность удаление свойства и изменения атрибутов свойства при помощи новых вызовов defineProperty (по умолчанию false)
	<bg-light>enumerable</bg-light>: false,   // свойство просматривается в цикле for..in и методе Object.keys() (по умолчанию false)
	<bg-light>get()</bg-light> {}             // функция, которая возвращает значение свойства (по умолчанию undefined)
	<bg-light>set()</bg-light> {}             // функция, которая записывает значение свойства (по умолчанию undefined)
});
</code></pre>

<h4>Объект с парами свойсво:дескриптор</h4>
<pre><code class="js">
// 1-объект, 2-объект с парами свойсво:дескриптор
Object.<bg-code>defineProperties</bg-code>(person, {
	name: {
		value: 'Jack',
		writable: false
	}, 
	age: {
		value: 25,
		writable: false
	}
});
</code></pre>

<h4>Обычное свойство</h4>
<pre><code class="js">
// оба вызова добавляют в объект user обычное (удаляемое, изменяемое, перечисляемое) свойство
var user = {};
user.name = 'Tony';
Object.defineProperty(user, 'name', { value:'Tony', configurable:true, writable:true, enumerable:true });
</code></pre>

<!------------------------------------------------------>
<h3>Геттеры и сеттеры</h3>
<!------------------------------------------------------>
<pre><code class="js">
var user = {
	firstName: "Вася",
	surname: "Петров"
}

Object.defineProperty(user, "fullName", {
	get() {
		return this.firstName + ' ' + this.surname;
	},
	set(value) {
		var split = value.split(' ');
		this.firstName = split[0];
		this.surname = split[1];
	}
});

user.fullName = "Петя Иванов";
alert(user.fullName);   // Вася Петров
alert(user.firstName ); // Петя
alert(user.surname );   // Иванов
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="extends-obj">Расширяемость объектов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<p>Расширяемость объектов - возможность добавления новых свойств</p>

<pre><code class="js">
var person = {
	name: 'Tony',
	age: 20
}
</code></pre>

<pre><code class="js">
Object.<bg-code>preventExtensions</bg-code>(person);    // запрещает добавление свойств в объект (применяется только к самому объекту)
var a = Object.<bg-code>isExtensible</bg-code>(person); // проверяет применение preventExtensions
</code></pre>

<pre><code class="js">
Object.<bg-code>seal</bg-code>(person);                 // аналогичен preventExtensions, дополнительно задает атрибут configurable:false для всех свойств
var a = Object.<bg-code>isSealed</bg-code>(person);     // проверяет применение seal
</code></pre>

<pre><code class="js">
Object.<bg-code>freeze</bg-code>(person);               // аналогичен seal, дополнительно делает все свойства доступные только для чтения (configurable:false, writable:false)
var a = Object.<bg-code>isFrozen</bg-code>(person);     // проверяет применение freeze
</code></pre>




<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-samples">Примеры</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h4>Задание свойств объекта</h4>
<pre><code class="js">
const text = 'Some text';
function getId() {
	return 7;
}
let obj = {
	text,
	['prop_' + getId()]: 'some prop'
}
console.log(obj); // Object {text: 'Some text', prop_7: 'Some prop'}
</code></pre>

<h4>Метод для разных объектов</h4>
<pre><code class="js">
var speak = function() {
	console.log(this.sound, this.name);
}
</code></pre>
<pre><code class="js">
var animal = {
	sound: 'Mrr',
	name: 'Cat',
	speak: speak
}

animal.speak(); // Mrr, Cat
</code></pre>

<h4>Функция, возвращающая объект</h4>
<pre><code class="js">
function createCar(property, value) {
	return {
		[property]: value,
		['_' + property]: value,
		[property.toUpperCase()]: value,
		['get' + property]() {
			return this[property];
		}
	};
}
var a = createCar('vin', 1);
</code></pre>




<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="object-conversion">Преобразование объектов: toString и valueOf</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>В <bg-list>логическом</bg-list> контексте объект - всегда <u>true</u></li>
	<li>При <bg-list>строковом</bg-list> преобразовании объекта используется его метод <u>toString</u>. Он должен возвращать примитивное значение, причём не обязательно именно строку</li>
	<li>Для <bg-list>численного</bg-list> преобразования используется метод <u>valueOf</u>, который также может возвратить любое примитивное значение. У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется toString</li>
</ul>

<!------------------------------------------------------>
<h3>Логическое преобразование</h3>
<!------------------------------------------------------>
<pre><code class="js">
// любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.
if ({} && []) {
	alert( "Все объекты - true!" ); // alert сработает
}
</code></pre>

<!------------------------------------------------------>
<h3>Строковое преобразование</h3>
<!------------------------------------------------------>
<pre><code class="js">
var user = {
	name: 'Tony'
};

alert( user ); // [object Object]
</code></pre>

<pre><code class="js">
// eсли в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования
var obj = {
	name: 'Tony',
	<bg-code>toString</bg-code>() {
		return this.name;
	}
};

alert( obj ); // Tony
</code></pre>

<!------------------------------------------------------>
<h3>Численное преобразование</h3>
<!------------------------------------------------------>
<pre><code class="js">
// для численного преобразования объекта используется метод valueOf, а если его нет – то toString
var room = {
	number: 777,
	<bg-code>valueOf</bg-code>() { return this.number; },
	<bg-code>toString</bg-code>() { return this.number; }
};

alert( +room );      // 777, вызвался valueOf
delete room.valueOf; // valueOf удалён
alert( +room );      // 777, вызвался toString
</code></pre>



<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->
<h1>Классы</h1>
<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-theory">Теория</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<b>Основное</b>
	<li><bg-list>Класс</bg-list> - функция/шаблон, предназначенный для создания объектов и методов</li>
	<li><bg-list>Объект</bg-list> - это экземпляр, представитель класса, т.е. объект, созданный по шаблону со свойствами и методами, указанными в классе</li>
	<li><bg-list>Конструктор</bg-list> - метод, который вызывается в момент создания объекта т.е. когда используется ключевое слово new он создает свойства и инициализирует, т.е. подготавливает объект к использованию. В классе может быть только 1 конструктор. Если не указать конструктор, то JS создаст пустой конструктор. Свойства указываются только в конструкторе</li>
	<li><bg-list>Принципы</bg-list> - класс должен отвечать за что-то одно (SOLID. Single Responsibility)</li>

	<b class="margin-top">Статические свойства и методы</b>
	<li><bg-list>Статические свойства и методы</bg-list> принадлежат самому классу, а не объектам, созданным на его основе</li>
	<li><bg-list>Статические свойства</bg-list> - используются для хранения вспомогательной информации</li>
	<li><bg-list>Статические методы</bg-list> - используются для создания вспомогательных функций. task.getDefaultColor(); нельзя вызывать напрямую</li>

	<b class="margin-top">Геттеры и Сеттеры</b>
	<li><bg-list>Геттеры и Сеттеры</bg-list> - аксессоры. Внутри класса выглядят и ведут себя как методы, а снаружи выглядят и ведут себя как свойства. Эти свойства-методы позволяют получить доступ и присвоить значения "настоящим" свойствам объекта, т.е. выступают в роли фильтра. Названия свойств get и set не должны совпадать с названиями основных свойств объекта</li>
	
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-create">Создание класса</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="js">
// создание класса
class Task {
	constructor(name = '', color = Task.getDefaultColor()) {
		this.title = 'Выучить JS';
		this.name = name;
		this.color = color;
		this._done = false;
		Task.count += 1;
		console.log('Создание задачи');
	}
	// свойство get связывает свойство объекта с функцией, которая будет вызываться 
	// при обращении к этому свойству
	get done() {
		return this._done === true ? 'Выполнена' : 'Не выполнена';
	}
	set done(value) {
		if(value != undefined && typeof value === 'boolean') {
			this._done = value;
		} else {
			console.error('Ошибка! Укажите значение true или false');
		}
	}
	complete() {
		this.done = true;
		console.log(`Задача ${this.title} выполнена`);
	}
	// статический метод, позволяющий получить значение цвета по умолчанию,
	// если цвет не был передан
	static getDefaultColor() {
		return 'Orange';
	}
}

let task = new Task('Новая задача'); // создание экземпляра класса (объекта)

Task.count = 0;                      // задание статического свойства
console.log(task instanceof Task);   // является ли объект представителем класса
console.log(task.title);             // обращение к свойству title
console.log(task.name);              // обращение к свойству name
console.log(task.color);             // обращение к свойству color, не передавая color
console.log(Task.count);             // обращение к статическому свойству count
task.complete();                     // обращение к методу complete
console.log(task.done, task._done);
</code></pre>

<pre><code class="js">
// переопределение стандартных методов
Task.prototype.toString = function() {
	return this.name;
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-inherit">Наследование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
class Task {
	constructor(title, comment) {
		this._comment = comment; 
		this.title = title;
		this.done = false;
		Task.count += 1;
		console.log('create task');
	}
	get comment() {
		return this._comment;
	}
	set comment(value) {
		this._comment = value;
	}
	static getDefaultComment() {
		return 'Задача';
	}
	complete() {
		this.done = true;
		console.log(`Задача ${this.title} выполнена`);
	}
}
Task.count = 0; // общее кол-во задач

// наследование между двумя классами
// если у подкласса нет конструктора, он будет использовать конструктор родителя
// если подклассу указать конструктор, то он должен вызывать в начале
// конструктор родительского класса super()
// метод super() позволяет наследовать свойства и методы из прототипа
class SubTask extends Task {
	constructor(title, comment, parent) {
		super(title, comment);
		this.parent = parent;
		console.log('create subtask');
	}
	// переопределение родительского метода
	complete() {
		// this.done = true;
		super.complete();
		console.log(`Подзадача ${this.title} выполнена`);	
	}
}

let task = new Task('Изучить JavaScript', 'Comment Task');
let subtask = new SubTask('Изучить ES6', 'Comment SubTask', task);

task.complete();
subtask.complete();

console.log(SubTask.getDefaultComment());
console.log(SubTask.count);
</code></pre>

<blockquote>
В ES6 нельзя указывать класс до его объявления<br>
Классы не засоряют глобальное пространство имен (объект window)
</blockquote>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-expression">Выражения классов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<blockquote>Классы являются функциями, поэтому класс можно объявить двумя способами</blockquote>

<b>1. Class Declaration</b>
<pre><code class="js">
class Task {
	constructor() {
		//
	}
}
</code></pre>

<b>2. Class Expression (выражение класса)</b>
<pre><code class="js">
var Task = class Task {
	constructor() {
		console.log('Create a task');
	}
}

var SubTask = class extends Task {
	constructor() {
		super();
		console.log('Create a subtask');
	}
}

var task = new Task();
var subtask = new SubTask();
</code></pre>


<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->
<h1>ES5 (функциональный стиль)</h1>
<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-theory">Теория</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<b class="margin-top">Функция, запущенная через new, делает следующее:</b>
	<li>1. Создаётся новый пустой объект</li>
	<li>2. Ключевое слово <u>this</u> получает ссылку на этот объект</li>
	<li>3. Функция выполняется. Как правило, она модифицирует <u>this</u> (т.е. этот новый объект), добавляет методы, свойства</li>
	<li>4. Возвращается <u>this</u></li>

	<b class="margin-top">Свойства</b>
	<li><bg-list>Приватные (private)</bg-list> - <u>let prop</u> локальные переменные/методы, включая параметры конструктора. доступн только внутри класса</li>
	<li><bg-list>Публичные (public)</bg-list> - <u>this.prop</u> свойства/методы, записанные в this класса</li>
	<li><bg-list>Защищённые (protected)</bg-list> - <u>this._prop</u> начинаются с подчеркивания. доступны внутри класса и для его потомков</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-func">Функциональный подход</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
function User(name) {
	this.name = name;
	this.avatar = 'Photo';
	<bg-code>this.deleteAvatar</bg-code> = function() {
		this.avatar = null;
	}
}
var user = new User('Jack'); // => User {name: "Jack", avatar: "Photo", deleteAvatar: ƒ}
user.deleteAvatar();
console.log(user);           // => User {name: "Jack", avatar: null, deleteAvatar: ƒ}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-private">Приватный метод</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h4>Простой приватный метод и свойство</h4>
<pre><code class="js">
function User() {
    var privateProperty = 77;
	this.publicMethod = function() {
        <bg-code>privateMethod</bg-code>();
    }
    var <bg-code>privateMethod</bg-code> = function() {
        console.log('private method call' + privateProperty);
    }
}
var user = new User();
user.publicMethod(); // => 'private method call77
</code></pre>

<h4>Сохранение this в замыкании</h4>
<pre><code class="js">
function User() {
    this.name = 'Tony';
    <bg-code>var self = this;</bg-code>
	this.publicMethod = function() {
        privateMethod();
    }
    var privateMethod = function() {
        console.log(<bg-code>self.name</bg-code>);
    }
}
var user = new User();
user.publicMethod(); // => 'Tony'
</code></pre>

<h4>Стрелочная функция</h4>
<pre><code class="js">
function User() {
    this.name = 'Tony';
	this.publicMethod = function() {
        privateMethod();
    }
    var privateMethod = () => {
        console.log(this.name);
    }
}
var user = new User();
user.publicMethod(); 
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-getters">Геттеры и сеттеры</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
function User() {
    var count = 0;
	this.counter = function(i) {
        // вызов без параметра, значит режим геттера, возвращаем свойство
        if (!arguments.length) return count;
        count = i;
    }
}
var user = new User();
user.counter(77); 
user.counter(); // => 77
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-inherit">Наследование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h4>Без аргументов</h4>
<pre><code class="js">
// Admin вызывает функцию User, передавая ей в качестве контекста this текущий объект
// User, в процессе выполнения, записывает в this свойства и методы, в данном случае this.name
function User() {
    this.name = 'Tony';
}
function Admin() {
    <bg-code>User.call(this);</bg-code>
    this.id = 77;
}
var admin = new Admin(); // => Admin {name: "Tony", id: 77}
</code></pre>

<h4>Передача аргументов</h4>
<pre><code class="js">
function User(id, name) {
	this.id = id;
	this.name = name;
}
function Admin() {
	<bg-code>User.apply(this, arguments);</bg-code>
}
var admin = new Admin(77, 'Tony'); // => Admin {id: 77, name: "Tony"}
</code></pre>

<h4>Переопределение наследованных методов</h4>
<pre><code class="js">
function User() {
    this.name = 'Tony';
    this.getName = function() {
        console.log(this.name);
    }
}
function Admin() {
    User.call(this);
    <bg-code>var parentFunc = this.getName;</bg-code>
    this.getName = function() {
        <bg-code>parentFunc.call(this);</bg-code> // то что было в this.getName
        console.log('Jack');   // добавлено в метод getName
    }
}
var admin = new Admin();
admin.getName(); // => 'Tony', 'Jack'
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-return">Правила обработки return</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>При вызове <u>return</u> с объектом, будет возвращён он, а не <u>this</u></li>
	<li>При вызове <u>return</u> с примитивным значением, оно будет отброшено и возвращен <u>this</u></li>
</ul>

<pre><code class="js">
function BigAnimal() {
	this.name = "Мышь";
	return { name: "Годзилла" };  // <-- возвратим объект
}
alert( new BigAnimal().name );  // Годзилла, получили объект вместо this
</code></pre>

<pre><code class="js">
function BigAnimal() {
	this.name = "Мышь";
	return "Годзилла"; // <-- возвратим примитив
}
alert( new BigAnimal().name ); // Мышь, получили this (а Годзилла пропала)
</code></pre>



<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->
<h1>ES5 (прототипный стиль)</h1>
<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-proto-main">Основное</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<b>Основное</b>
	<li><bg-list>Класс</bg-list> - <u>функция-конструктор</u> вместе с её <u>prototype</u>. Такой способ объявления классов называют <u>«прототипным стилем»</u>. При наследовании часть методов переопределяется, например, у массива Array есть свой toString</li>
	<li><u>Функциональный стиль</u> записывает в каждый объект и свойства и методы, а <u>прототипный</u> – только свойства</li>
	<li>При создании методов через прототип, мы теряем возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором</li>

	<b class="margin-top">Прототип __proto__ [[Prototype]]</b>
	<li>Если один объект имеет специальную ссылку <u>__proto__</u> на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте <u>__proto__</u></li>
	<li>Объект, на который указывает ссылка <u>__proto__</u>, называется <u>«прототипом»</u></li>
	<li>__proto__ - наследование на уровне объектов</li>
</ul>

<img src="img/js/proto2.jpg" class="center" height="250px">
<pre><code class="js">
function User() {
    this.name = 'Tony';
}
User.prototype.myFunc = function() {}
Object.prototype.myFuncObject = function() {}
let obj = new User();
</code></pre>


<!------------------------------------------------------>
<h3>Свойство constructor</h3>
<!------------------------------------------------------>
<h4>Свойство constructor по умолчанию</h4>
<pre><code class="js">
// у каждой функции по умолчанию есть свойство prototype, содержащее объект
function MyFunc() {}
MyFunc.prototype = { 
	<bg-code>constructor</bg-code>: MyFunc 
};
var a = new MyFunc(); // => MyFunc {} __proto__: constructor: ƒ MyFunc()
</code></pre>

<h4>Перезапись свойства constructor</h4>
<pre><code class="js">
function MyFunc() {}
MyFunc.prototype = { 
	jumps: true 
};
var a = new MyFunc(); // => MyFunc {} __proto__: jumps: true 
</code></pre>

<h4>Создание объекта с тем же конструктором, что и данный</h4>
<pre><code class="js">
function User(name) {
    this.name = name;
    console.log(name);
}
var user1 = new User('Tony');
var user2 = new user1.<bg-code>constructor</bg-code>('Jack');
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-proto-prototype">Свойство prototype</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<b class="margin-top">Свойство prototype</b>
	<li>При создании объекта через <u>new</u>, в его прототип <u>__proto__</u> записывается ссылка из <u>prototype</u> функции-конструктора</li>
	<li>Имеет смысл только у <u>конструктора</u>, когда есть вызов <u>new</u></li>
	<li>Назначение: указывать <u>__proto__</u> для новых объектов</li>
	<li>Значением prototype может быть только объект</li>
	<li>У каждой функции по умолчанию есть свойство <u>prototype</u></li>
</ul>

<pre><code class="js">
function User() {
    this.name = 'Tony';
}
function Admin() {
    this.id = 77;
}
Admin.<bg-code>prototype</bg-code> = new User();
// Admin.__proto__ = new User();
var admin = new Admin(); // => Admin {id: 77, __proto__: User name: "Tony"}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-proto-methods">Добавление методов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!--__________________________________________________-->
<h4>Добавление метода в прототип класса</h4>
<pre><code class="js">
function User(name) {
	this.name = name;
	this.avatar = 'Photo';
}
<bg-code>User.prototype.deleteAvatar</bg-code> = function() {
	this.avatar = null;
}
var user = new User('Jack'); // => User {name: "Jack", avatar: "Photo", __proto__: deleteAvatar: ƒ () }
user.deleteAvatar();
console.log(user);           // => User {name: "Jack", avatar: null, __proto__: deleteAvatar: ƒ ()}
</code></pre>

<!--__________________________________________________-->
<h4>Изменение встроенных прототипов</h4>
<pre><code class="js">
<bg-code>Object.prototype.myFunc</bg-code> = function() {
    alert('myFunc');
}
let obj = {}
obj.myFunc(); // => 'myFunc'
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-proto-inherit">Наследование классов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Пример наследования</h3>
<!------------------------------------------------------>
<h4>1. Задание классов и прототипов</h4>
<pre><code class="js">
function User() {
	this.userName = 'userName';
}
User.prototype.userFunc = function() {
	alert('userFunc');
}
User.prototype.userProp = 'userProp';
</code></pre>
<pre><code class="js">
function Admin() {
	this.adminName = 'adminName';
}
</code></pre>

<h4>2. Наследование. В прототип Admin добавлили всё из прототипа User</h4>
<pre><code class="js">
<bg-code>Admin.prototype = Object.create(User.prototype);</bg-code>
var admin = new Admin();
</code></pre>

<h4>2. Наследование. Без добавления в прототип Admin (результат аналогичен)</h4>
<pre><code class="js red">
var admin = Object.setPrototypeOf(new Admin(), User.prototype);
</code></pre>

<h4>3. Добавление методов к Admin.prototype (при необходимости)</h4>
<pre><code class="js">
// добавлять после <bg-code>Admin.prototype = Object.create(User.prototype)</bg-code> чтобы не перетерло
Admin.prototype.adminFunc = function() {
	alert('adminFunc');
}
</code></pre>

<h4>4. Переопределение метода родителя (при необходимости)</h4>
<pre><code class="js">
Admin.prototype.userFunc = function() {
	alert('not userFunc');
}
</code></pre>

<h4>5. Вызов метода родителя внутри своего (при необходимости)</h4>
<pre><code class="js">
Admin.prototype.adminUserFunc = function() {
	// вызвать метод родителя передав ему текущие аргументы
	// если вызвать просто Animal.prototype.run(), то в качестве this функция run получит Animal.prototype, а это неверно, нужен текущий объект
	User.prototype.userFunc.apply(this, arguments);
}
</code></pre>

<h4>6. Обращение к методам и свойствам</h4>
<pre><code class="js">
admin.userFunc(); // => alert('userFunc')
admin.userProp;   // => 'userProp'
</code></pre>

<!------------------------------------------------------>
<h3>Вызов конструктора родителя</h3>
<!------------------------------------------------------>
<pre><code class="js">
function Animal(name) {
    this.name = name;
    this.speed = 0;
}
function Rabbit(name) {
    Animal.apply(this, arguments);
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-instanceof">Проверка класса: "instanceof"</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li><bg-list>instanceof</bg-list> позволяет проверить, какому классу принадлежит объект, с учетом прототипного наследования</li>
	<li>Оператор obj instanceof Func проверяет что obj является результатом вызова new Func. Он учитывает цепочку <u>__proto__</u>, поэтому наследование поддерживается</li>
	<li>Оператор <u>instanceof</u> не сможет проверить тип значения, если объект создан в одном окне/фрейме, а проверяется в другом, т.к. в каждом окне своя иерархия объектов. Для точной проверки типов встроенных объектов можно использовать свойство <u>[[Class]]</u></li>
	<li>Оператор <u>instanceof</u> особенно востребован в случаях, когда мы работаем с иерархиями классов. Это наилучший способ проверить принадлежность тому или иному классу с учётом наследования</li>

	<b class="margin-top">Алгоритм проверки obj instanceof Constructor</b>
	<li>1. Получить obj.__proto__</li>
	<li>2. Сравнить obj.__proto__ с Constructor.prototype</li>
	<li>3. Если не совпадает, тогда заменить obj на obj.__proto__ и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат true), либо цепочка прототипов не закончится (результат false)</li>
</ul>

<pre><code class="js">
function ClassParent() {}
var parent = new ClassParent();
var a = parent instanceof ClassParent; // true
// parent.__proto__ == ClassParent.prototype;
</code></pre>

<pre><code class="js">
// массив arr принадлежит классу Array
// но также и является объектом Object
var arr = [];
var a = arr instanceof Array; // true
var a = arr instanceof Object; // true
// arr.__proto__.__proto__ == Object.prototype
</code></pre>

<pre><code class="js">
// сама функция-конструктор не участвует в процессе проверки, важна только цепочка прототипов для проверяемого объекта
// это может приводить к ошибкам в проверке при изменении prototype
function Rabbit() {}
var rabbit = new Rabbit();
Rabbit.prototype = {}; // изменили prototype...
var a = rabbit instanceof Rabbit; // false
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-mixins">Примеси (mixins)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Невозможно унаследовать от двух и более объектов, т.к. ссылка <u>__proto__</u> только одна</li>
	<li><bg-list>Примесь (mixin)</bg-list> – класс или объект, содержащий методы и свойства для реализации конкретного функционала. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования</li>
	<li>Методы примеси активно используют <u>this</u> и предназначены именно для запуска в контексте «объекта-носителя примеси»</li>
	<li>Если какие-то из методов примеси не нужны – их можно перезаписать своими после копирования</li>
	<li>Для добавления примеси в класс – её просто «подмешивают» в прототип. «Подмешать» можно сколько угодно примесей, но если имена методов в разных примесях совпадают, то возможны конфликты.</li>
</ul>

<pre><code class="js">
var mixinGreeting = {
    greet() {
        console.log(this.name);
    }
};
function User(name) {
    this.name = name;
}
for(var key in mixinGreeting) {
    <bg-code>User.prototype[key] = mixinGreeting[key];</bg-code>
}
new User('Tony').greet(); // => Tony
</code></pre>







</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
