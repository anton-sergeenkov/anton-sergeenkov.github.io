<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>

	<div class="theme">Объекты ES6</div>
	<a href="#obj-create">Объявление</a>
	<a href="#obj-methods">Методы</a>
	<a href="#obj-prototype-create">Прототип</a>

	<a href="#descriptor">Дескрипторы свойств</a>
	<a href="#extends-obj">Расширяемость объектов</a>
	<a href="#object-conversion"><bg-menu>toString</bg-menu> <bg-menu>valueOf</bg-menu></a>

	<a href="#obj-samples">Примеры</a>
	<a href="#obj-constructor">Конструктор создания объекта</a>

	<div class="theme">Классы ES6</div>
	<a href="#class-theory">Теория</a>
	<a href="#class-create">Объявление</a>
	<a href="#class-inherit">Наследование</a>
	<a href="#class-expression">Выражения классов</a>

	<div class="theme">ES5 «Функциональный стиль»</div>
	<a href="#class-es5-theory">Теория</a>
	<a href="#class-es5-func">Объявление</a>
	<a href="#class-es5-private">Приватный метод</a>
	<a href="#class-es5-getters">Геттеры и сеттеры</a>
	<a href="#class-es5-inherit">Наследование</a>
	<a href="#class-es5-return">Правила обработки return</a>

	<div class="theme">ES5 «Прототипный стиль»</div>
	<a href="#class-es5-proto-main">Основное</a>
	<a href="#class-es5-proto">Объявление</a>

</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">



<img src="img/js/proto.jpg" height="400px" class="center">

<ul class="list-point">
	<b>ХРАНЕНИЕ И КОПИРОВАНИЕ</b>
	<li><u>Примитивные типы данных</u> - хранение и копирование <bg-list>«по значению»</bg-list>. В результате копирования получатся две полностью независимые переменные</li>
	<li><u>Объекты</u> - хранение и копирование <bg-list>«по ссылке»</bg-list>. В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него. При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Получили две переменные, в которых находятся ссылки на один и тот же объект</li>
</ul>

<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->
<h1>Объекты</h1>
<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-create">Литеральная нотация</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Литеральная нотация</h3>
<!------------------------------------------------------>
<pre><code class="js">
var property = 'lastName';

var person = {
	firstName: 'Brad',
	[property]: 'Stark',
	age: 25,
	children: ['Liza', 'Petro'],
	address: {
		street: '555 Some st',
		city: 'Boston',
		state: 'MA'
	},
	getName() {
		return this.firstName;
	}, 
	<bg-code>get</bg-code> fullName() {
		return this.firstName + ' ' + this.lastName;
	}, 
	<bg-code>set</bg-code> fullName(value) {
		this.firstName = value;
	}
}
</code></pre>

<h4>Обращение к свойствам и методам</h4>
<pre><code class="js">
var a = person.firstName;      // обращение к свойству (строка)
var a = person['firstName'];   // обращение к свойству через []
var a = person.children[0];    // обращение к свойству (массив)
var a = person.address.street; // обращение к свойству (объект)
var a = person.getName();      // обращение к методу
</code></pre>

<h4>Обновление и удаление свойства</h4>
<pre><code class="js">
person.firstName = 'Tony';     // обновление свойства
person.height = 190;           // задание нового свойства
delete person.firstName;       // удаление свойства (можно удалить только ненаследованные свойства объекта, наследованные свойства удаляются у прототипа)
</code></pre>

<h4>Добавление метода</h4>
<pre><code class="js">
person.greet = function() {
	console.log('hi');
}
</code></pre>

<h4>Геттеры и сеттеры</h4>
<pre><code class="js">
person.fullName = 'Steve';     // сеттер
var a = person.fullName;       // геттер (result = Steve Stark)
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-methods">Методы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Свойства</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Можно обратиться к любому свойству объекта, даже если его нет. Если свойство не существует, вернется undefined</li>
</ul>

<bg-list>keys</bg-list> <bg-list>getOwnPropertyNames</bg-list>
<pre><code class="js">
var a = Object.<bg-code>keys</bg-code>(obj);                // возвращает массив из собственных перечисляемых (enumerable) свойств переданного объекта
var a = Object.<bg-code>keys</bg-code>(obj).<bg-code>length</bg-code>;         // количество свойств
var a = Object.<bg-code>getOwnPropertyNames</bg-code>(obj); // возвращает массив со всеми свойствами (независимо от того, перечисляемые они или нет)
</code></pre>

<bg-list>in</bg-list> <bg-list>hasOwnProperty</bg-list>
<pre><code class="js">
var a = obj.name;                        // проверка наличия свойсва 'name' в объекте (не различает отсутствующие свойства и те что были установлен в undefined)
var a = 'name' <bg-code>in</bg-code> obj;                   // проверка наличия свойсва 'name' в объекте (различает отсутствующие свойства и те что были установлен в undefined)
var a = obj.<bg-code>hasOwnProperty</bg-code>('name');      // проверка наличия свойства 'name' в объекте (не берет наследованные свойства)
</code></pre>

<!------------------------------------------------------>
<h3>Перебор объекта</h3>
<!------------------------------------------------------>
<bg-list>for..in</bg-list>
<ul class="list-point">
	<li>Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые или числовые строки сортируются</li>
</ul>
<pre><code class="js">
for(let key <bg-code>in</bg-code> obj) {
	console.log(key);      // ключи 
	console.log(obj[key]); // значения
} 
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-constructor">Конструктор создания объекта</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Конструктор создания объекта</h3>
<!------------------------------------------------------>
<pre><code class="js">
var apple = new Object();
apple.color = 'green';
apple.shape = 'round';
apple.describe = function() {
	return 'An apple is ' + this.color;
}

var a = apple.color;
var a = apple.describe();
</code></pre>

<!------------------------------------------------------>
<h3>Конструктор создания объекта и задание параметров</h3>
<!------------------------------------------------------>
<pre><code class="js">
function fruit(color, shape) {
	this.color = color;
	this.shape = shape;
}

var melon = new fruit('yellow', 'round');
var a = melon.color;
</code></pre>

<!------------------------------------------------------>
<h3>Установление свойств объекту через конструктор</h3>
<!------------------------------------------------------>
<pre><code class="js">
var Car = function(x,y) {
	this.x = x;
	this.y = y;
}

var tesla = new Car(10,20);
tesla; // Object { x: 10, y: 20 }
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-prototype-create">Создание прототипа</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<b>ПРОТОТИП</b>
	<li>У каждого <u>объекта</u> есть <u>прототип</u>, от которого он наследует <u>свойства</u> и <u>методы</u>. Если объект не включает в себя запрошенное свойство, JavaScript выполнит поиск этого свойства в прототипе объекта. При этом поиск будет выполняться по <u>цепочке прототипов</u> до тех пор, пока не будет найдено то, что нужно. Если же поиск успехом не увенчается, будет возвращена ошибка</li>
	<br>
</ul>


<pre><code class="js">
<bg-code>Object.create()</bg-code>         // добавление прототипа при создании объекта
<bg-code>Object.setPrototypeOf()</bg-code> // добавление прототипа после создания объекта
</code></pre>

<pre><code class="js">
// объект
var Human = {
	type: "Human",
	head: 1,
	legs: 2
};
// прототип
var Megahuman = <bg-code>Object.create</bg-code>(Human);
</code></pre>

<div class="container-flex"><div class="container-half"><pre><code class="js">
Megahuman.type; // Human
Megahuman.head; // 1
</code></pre></div><div class="container-half"><pre><code class="js">
Megahuman.head = 2; // 2
Human.head;         // 1
</code></pre></div></div>

<div class="container-flex"><div class="container-half"><pre><code class="js">
Megahuman.hands = 10; // 10
Human.hands;          // undefined
</code></pre></div><div class="container-half"><pre><code class="js">
Human.face;     // undefined
Megahuman.face; // undefined
</code></pre></div></div>

<div class="container-flex"><div class="container-half"><pre><code class="js">
Human.face = "okay"; // okay
Megahuman.face;      // okay
</code></pre></div><div class="container-half"><pre><code class="js">
Megahuman.face = "awesome"; // awesome
Human.face;                 // okay
</code></pre></div></div>

<pre><code class="js">
Human.<bg-code>isPrototypeOf</bg-code>(Megahuman); // является ли объект Human прототипом для объекта Megahuman
</code></pre>

<!------------------------------------------------------>
<h3>Удаление свойств</h3>
<!------------------------------------------------------>
<pre><code class="js">
// объект
var Human = {
	type: "Human",
	head: 1,
	legs: 2
};

// прототип
var Megahuman = Object.create(Human);
Megahuman.head = 2; // 2
delete Megahuman.head;
Megahuman.head;     // 1
</code></pre>

<!------------------------------------------------------>
<h3>Конструктор прототипа</h3>
<!------------------------------------------------------>
<pre><code class="js">
var Person = {
    constructor(name, age) {
        this.name = name;
        this.age = age;
        return this;
    },
    greet() {
        console.log('Hi ' + this.name);
    }
}

var person = Object.create(Person).constructor("Jack", 25);

var a = person.name;
person.greet();
</code></pre>

<h4>Изменение конструктора</h4>
<pre><code class="js">
var WebDeveloper = Object.create(Person);

WebDeveloper.constructor = function(name, age, skills) {
    Person.constructor.apply(this, arguments);
    this.skills = skills || [];
    return this;
}
WebDeveloper.develop = function() {
    console.log('In Work');
}
var developer = Object.create(WebDeveloper).constructor('Jack', 25, ['html', 'css', 'js']);

console.log(developer.skills);
developer.develop();
console.log(developer.name);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="descriptor">Дескрипторы свойств</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li><bg-list>Свойства объекта</bg-list> имеют: <u>имя</u>, <u>значение</u> (атрибут value), <u>атрибуты</u> (writable, enumerable, configurable)</li>
</ul>

<pre><code class="js">
Object.<bg-code>getOwnPropertyDescriptor</bg-code>(obj, 'name');  // получение дескриптора свойств
Object.<bg-code>defineProperty</bg-code>(obj, prop, descriptor);  // переопределение дескриптора свойств
Object.<bg-code>defineProperties</bg-code>(obj, descriptors);     // позволяет объявить сразу несколько свойств
</code></pre>

<!------------------------------------------------------>
<h3>Получение дескриптора свойств</h3>
<!------------------------------------------------------>
<pre><code class="js">
var person = {
	name: 'Tony',
	age: 20
}
var a = Object.<bg-code>getOwnPropertyDescriptor</bg-code>(person, 'name');
// {value: "Tony", writable: true, enumerable: true, configurable: true } 
</code></pre>

<!------------------------------------------------------>
<h3>Переопределение дескриптора свойств</h3>
<!------------------------------------------------------>
<pre><code class="js">
Object.<bg-code>defineProperty</bg-code>(obj, prop, descriptor)
	obj        // объект, в котором объявляется свойство
	prop       // имя свойства, которое нужно объявить или модифицировать
	descriptor // дескриптор - объект, который описывает поведение свойства
</code></pre>

<pre><code class="js">
// 1-объект, 2-свойство, 3-дескриптор
Object.<bg-code>defineProperty</bg-code>(person, 'name', {
	<bg-light>value</bg-light>: 'Jack',       // значение свойства (по умолчанию undefined)
	<bg-light>writable</bg-light>: false,     // значение свойства можно менять (по умолчанию false)
	<bg-light>configurable</bg-light>: false, // возможность удаление свойства и изменения атрибутов свойства при помощи новых вызовов defineProperty (по умолчанию false)
	<bg-light>enumerable</bg-light>: false,   // свойство просматривается в цикле for..in и методе Object.keys() (по умолчанию false)
	<bg-light>get()</bg-light> {}             // функция, которая возвращает значение свойства (по умолчанию undefined)
	<bg-light>set()</bg-light> {}             // функция, которая записывает значение свойства (по умолчанию undefined)
});
</code></pre>

<h4>Объект с парами свойсво:дескриптор</h4>
<pre><code class="js">
// 1-объект, 2-объект с парами свойсво:дескриптор
Object.<bg-code>defineProperties</bg-code>(person, {
	name: {
		value: 'Jack',
		writable: false
	}, 
	age: {
		value: 25,
		writable: false
	}
});
</code></pre>

<h4>Обычное свойство</h4>
<pre><code class="js">
// оба вызова добавляют в объект user обычное (удаляемое, изменяемое, перечисляемое) свойство
var user = {};
user.name = 'Tony';
Object.defineProperty(user, 'name', { value:'Tony', configurable:true, writable:true, enumerable:true });
</code></pre>

<!------------------------------------------------------>
<h3>Геттеры и сеттеры</h3>
<!------------------------------------------------------>
<pre><code class="js">
var user = {
	firstName: "Вася",
	surname: "Петров"
}

Object.defineProperty(user, "fullName", {
	get() {
		return this.firstName + ' ' + this.surname;
	},
	set(value) {
		var split = value.split(' ');
		this.firstName = split[0];
		this.surname = split[1];
	}
});

user.fullName = "Петя Иванов";
alert(user.fullName);   // Вася Петров
alert(user.firstName ); // Петя
alert(user.surname );   // Иванов
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="extends-obj">Расширяемость объектов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<p>Расширяемость объектов - возможность добавления новых свойств</p>

<pre><code class="js">
var person = {
	name: 'Tony',
	age: 20
}

Object.<bg-code>preventExtensions</bg-code>(person);    // запрещает добавление свойств в объект (применяется только к самому объекту)
var a = Object.<bg-code>isExtensible</bg-code>(person); // проверяет применение preventExtensions

Object.<bg-code>seal</bg-code>(person);                 // аналогичен preventExtensions, дополнительно задает атрибут configurable:false для всех свойств
var a = Object.<bg-code>isSealed</bg-code>(person);     // проверяет применение seal

Object.<bg-code>freeze</bg-code>(person);               // аналогичен seal, дополнительно делает все свойства доступные только для чтения (configurable:false, writable:false)
var a = Object.<bg-code>isFrozen</bg-code>(person);     // проверяет применение freeze
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="obj-samples">Примеры</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h4>Задание свойств объекта</h4>
<pre><code class="js">
const text = 'Some text';
function getId() {
	return 7;
}
let obj = {
	text,
	['prop_' + getId()]: 'some prop'
}
console.log(obj); // Object {text: 'Some text', prop_7: 'Some prop'}
</code></pre>

<h4>Метод для разных объектов</h4>
<pre><code class="js">
var speak = function() {
	console.log(this.sound, this.name);
}
</code></pre>
<pre><code class="js">
var animal = {
	sound: 'Mrr',
	name: 'Cat',
	speak: speak
}

animal.speak(); // Mrr, Cat
</code></pre>

<h4>Обращение как к объекту и как к функции</h4>
<pre><code class="js">
let test = function() {
	console.log('hi from object!');
}
test.method = function () {
	console.log('hi from method!');
}
test.method()
test()
</code></pre>

<h4>Функиця, возвращающая объект</h4>
<pre><code class="js">
function createCar(property, value) {
	return {
		[property]: value,
		['_' + property]: value,
		[property.toUpperCase()]: value,
		['get' + property]() {
			return this[property];
		}
	};
}
var a = createCar('vin', 1);
</code></pre>




<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="object-conversion">Преобразование объектов: toString и valueOf</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>В <bg-list>логическом</bg-list> контексте объект - всегда <u>true</u></li>
	<li>При <bg-list>строковом</bg-list> преобразовании объекта используется его метод <u>toString</u>. Он должен возвращать примитивное значение, причём не обязательно именно строку</li>
	<li>Для <bg-list>численного</bg-list> преобразования используется метод <u>valueOf</u>, который также может возвратить любое примитивное значение. У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется toString</li>
</ul>

<!------------------------------------------------------>
<h3>Логическое преобразование</h3>
<!------------------------------------------------------>
<pre><code class="js">
// любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.
if ({} && []) {
	alert( "Все объекты - true!" ); // alert сработает
}
</code></pre>

<!------------------------------------------------------>
<h3>Строковое преобразование</h3>
<!------------------------------------------------------>
<pre><code class="js">
var user = {
	name: 'Tony'
};

alert( user ); // [object Object]
</code></pre>

<pre><code class="js">
// eсли в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования
var obj = {
	name: 'Tony',
	<bg-code>toString</bg-code>() {
		return this.name;
	}
};

alert( obj ); // Tony
</code></pre>

<!------------------------------------------------------>
<h3>Численное преобразование</h3>
<!------------------------------------------------------>
<pre><code class="js">
// для численного преобразования объекта используется метод valueOf, а если его нет – то toString
var room = {
	number: 777,
	<bg-code>valueOf</bg-code>() { return this.number; },
	<bg-code>toString</bg-code>() { return this.number; }
};

alert( +room );      // 777, вызвался valueOf
delete room.valueOf; // valueOf удалён
alert( +room );      // 777, вызвался toString
</code></pre>



<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->
<h1>Классы</h1>
<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-theory">Теория</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<b>Основное</b>
	<li><bg-list>Класс</bg-list> - функция/шаблон, предназначенный для создания объектов и методов</li>
	<li><bg-list>Объект</bg-list> - это экземпляр, представитель класса, т.е. объект, созданный по шаблону со свойствами и методами, указанными в классе</li>
	<li><bg-list>Конструктор</bg-list> - метод, который вызывается в момент создания объекта т.е. когда используется ключевое слово new он создает свойства и инициализирует, т.е. подготавливает объект к использованию. В классе может быть только 1 конструктор. Если не указать конструктор, то JS создаст пустой конструктор. Свойства указываются только в конструкторе</li>
	<li><bg-list>Принципы</bg-list> - класс должен отвечать за что-то одно (SOLID. Single Responsibility)</li>

	<b class="margin-top">Статические свойства и методы</b>
	<li><bg-list>Статические свойства и методы</bg-list> принадлежат самому классу, а не объектам, созданным на его основе</li>
	<li><bg-list>Статические свойства</bg-list> - используются для хранения вспомогательной информации</li>
	<li><bg-list>Статические методы</bg-list> - используются для создания вспомогательных функций. task.getDefaultColor(); нельзя вызывать напрямую</li>

	<b class="margin-top">Геттеры и Сеттеры</b>
	<li><bg-list>Геттеры и Сеттеры</bg-list> - аксессоры. Внутри класса выглядят и ведут себя как методы, а снаружи выглядят и ведут себя как свойства. Эти свойства-методы позволяют получить доступ и присвоить значения "настоящим" свойствам объекта, т.е. выступают в роли фильтра. Названия свойств get и set не должны совпадать с названиями основных свойств объекта</li>
	
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-create">Создание класса</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="js">
// создание класса
class Task {
	constructor(name = '', color = Task.getDefaultColor()) {
		this.title = 'Выучить JS';
		this.name = name;
		this.color = color;
		this._done = false;
		Task.count += 1;
		console.log('Создание задачи');
	}
	// свойство get связывает свойство объекта с функцией, которая будет вызываться 
	// при обращении к этому свойству
	get done() {
		return this._done === true ? 'Выполнена' : 'Не выполнена';
	}
	set done(value) {
		if(value != undefined && typeof value === 'boolean') {
			this._done = value;
		} else {
			console.error('Ошибка! Укажите значение true или false');
		}
	}
	complete() {
		this.done = true;
		console.log(`Задача ${this.title} выполнена`);
	}
	// статический метод, позволяющий получить значение цвета по умолчанию,
	// если цвет не был передан
	static getDefaultColor() {
		return 'Orange';
	}
}

let task = new Task('Новая задача'); // создание экземпляра класса (объекта)

Task.count = 0;                      // задание статического свойства
console.log(task instanceof Task);   // является ли объект представителем класса
console.log(task.title);             // обращение к свойству title
console.log(task.name);              // обращение к свойству name
console.log(task.color);             // обращение к свойству color, не передавая color
console.log(Task.count);             // обращение к статическому свойству count
task.complete();                     // обращение к методу complete
console.log(task.done, task._done);
</code></pre>

<pre><code class="js">
// переопределение стандартных методов
Task.prototype.toString = function() {
	return this.name;
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-inherit">Наследование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
class Task {
	constructor(title, comment) {
		this._comment = comment; 
		this.title = title;
		this.done = false;
		Task.count += 1;
		console.log('create task');
	}
	get comment() {
		return this._comment;
	}
	set comment(value) {
		this._comment = value;
	}
	static getDefaultComment() {
		return 'Задача';
	}
	complete() {
		this.done = true;
		console.log(`Задача ${this.title} выполнена`);
	}
}
Task.count = 0; // общее кол-во задач

// наследование между двумя классами
// если у подкласса нет конструктора, он будет использовать конструктор родителя
// если подклассу указать конструктор, то он должен вызывать в начале
// конструктор родительского класса super()
// метод super() позволяет наследовать свойства и методы из прототипа
class SubTask extends Task {
	constructor(title, comment, parent) {
		super(title, comment);
		this.parent = parent;
		console.log('create subtask');
	}
	// переопределение родительского метода
	complete() {
		// this.done = true;
		super.complete();
		console.log(`Подзадача ${this.title} выполнена`);	
	}
}

let task = new Task('Изучить JavaScript', 'Comment Task');
let subtask = new SubTask('Изучить ES6', 'Comment SubTask', task);

task.complete();
subtask.complete();

console.log(SubTask.getDefaultComment());
console.log(SubTask.count);
</code></pre>

<blockquote>
В ES6 нельзя указывать класс до его объявления<br>
Классы не засоряют глобальное пространство имен (объект window)
</blockquote>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-expression">Выражения классов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<blockquote>Классы являются функциями, поэтому класс можно объявить двумя способами</blockquote>

<b>1. Class Declaration</b>
<pre><code class="js">
class Task {
	constructor() {
		//
	}
}
</code></pre>

<b>2. Class Expression (выражение класса)</b>
<pre><code class="js">
var Task = class Task {
	constructor() {
		console.log('Create a task');
	}
}

var SubTask = class extends Task {
	constructor() {
		super();
		console.log('Create a subtask');
	}
}

var task = new Task();
var subtask = new SubTask();
</code></pre>


<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->
<h1>ES5. Функциональный паттерн наследования</h1>
<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-theory">Теория</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<b class="margin-top">Функция, запущенная через new, делает следующее:</b>
	<li>1. Создаётся новый пустой объект</li>
	<li>2. Ключевое слово <u>this</u> получает ссылку на этот объект</li>
	<li>3. Функция выполняется. Как правило, она модифицирует <u>this</u> (т.е. этот новый объект), добавляет методы, свойства</li>
	<li>4. Возвращается <u>this</u></li>

	<b class="margin-top">Свойства</b>
	<li><bg-list>Приватные (private)</bg-list> - <u>let prop</u> локальные переменные/методы, включая параметры конструктора. доступн только внутри класса</li>
	<li><bg-list>Публичные (public)</bg-list> - <u>this.prop</u> свойства/методы, записанные в this класса</li>
	<li><bg-list>Защищённые (protected)</bg-list> - <u>this._prop</u> начинаются с подчеркивания. доступны внутри класса и для его потомков</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-func">Функциональный подход</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
function User(name) {
	this.name = name;
	this.avatar = 'Photo';
	<bg-code>this.deleteAvatar</bg-code> = function() {
		this.avatar = null;
	}
}
var user = new User('Jack'); // => User {name: "Jack", avatar: "Photo", deleteAvatar: ƒ}
user.deleteAvatar();
console.log(user);           // => User {name: "Jack", avatar: null, deleteAvatar: ƒ}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-private">Приватный метод</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h4>Простой приватный метод и свойство</h4>
<pre><code class="js">
function User() {
    var privateProperty = 77;
	this.publicMethod = function() {
        <bg-code>privateMethod</bg-code>();
    }
    var <bg-code>privateMethod</bg-code> = function() {
        console.log('private method call' + privateProperty);
    }
}
var user = new User();
user.publicMethod(); // => 'private method call77
</code></pre>

<h4>Сохранение this в замыкании</h4>
<pre><code class="js">
function User() {
    this.name = 'Tony';
    <bg-code>var self = this;</bg-code>
	this.publicMethod = function() {
        privateMethod();
    }
    var privateMethod = function() {
        console.log(<bg-code>self.name</bg-code>);
    }
}
var user = new User();
user.publicMethod(); // => 'Tony'
</code></pre>

<h4>Стрелочная функция</h4>
<pre><code class="js">
function User() {
    this.name = 'Tony';
	this.publicMethod = function() {
        privateMethod();
    }
    var privateMethod = () => {
        console.log(this.name);
    }
}
var user = new User();
user.publicMethod(); 
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-getters">Геттеры и сеттеры</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
function User() {
    var count = 0;
	this.counter = function(i) {
        // вызов без параметра, значит режим геттера, возвращаем свойство
        if (!arguments.length) return count;
        count = i;
    }
}
var user = new User();
user.counter(77); 
user.counter(); // => 77
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-inherit">Наследование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h4>Без аргументов</h4>
<pre><code class="js">
// Admin вызывает функцию User, передавая ей в качестве контекста this текущий объект
// User, в процессе выполнения, записывает в this свойства и методы, в данном случае this.name
function User() {
    this.name = 'Tony';
}
function Admin() {
    <bg-code>User.call(this);</bg-code>
    this.id = 77;
}
var admin = new Admin(); // => Admin {name: "Tony", id: 77}
</code></pre>

<h4>Передача аргументов</h4>
<pre><code class="js">
function User(id, name) {
	this.id = id;
	this.name = name;
}
function Admin() {
	<bg-code>User.apply(this, arguments);</bg-code>
}
var admin = new Admin(77, 'Tony'); // => Admin {id: 77, name: "Tony"}
</code></pre>

<h4>Переопределение наследованных методов</h4>
<pre><code class="js">
function User() {
    this.name = 'Tony';
    this.getName = function() {
        console.log(this.name);
    }
}
function Admin() {
    User.call(this);
    <bg-code>var parentFunc = this.getName;</bg-code>
    this.getName = function() {
        <bg-code>parentFunc.call(this);</bg-code> // то что было в this.getName
        console.log('Jack');   // добавлено в метод getName
    }
}
var admin = new Admin();
admin.getName(); // => 'Tony', 'Jack'
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-return">Правила обработки return</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>При вызове <u>return</u> с объектом, будет возвращён он, а не <u>this</u></li>
	<li>При вызове <u>return</u> с примитивным значением, оно будет отброшено и возвращен <u>this</u></li>
</ul>

<pre><code class="js">
function BigAnimal() {
	this.name = "Мышь";
	return { name: "Годзилла" };  // <-- возвратим объект
}
alert( new BigAnimal().name );  // Годзилла, получили объект вместо this
</code></pre>

<pre><code class="js">
function BigAnimal() {
	this.name = "Мышь";
	return "Годзилла"; // <-- возвратим примитив
}
alert( new BigAnimal().name ); // Мышь, получили this (а Годзилла пропала)
</code></pre>



<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->
<h1>ES5 (прототипный стиль)</h1>
<!-------------------------------------------------------------------------------->
<!-------------------------------------------------------------------------------->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-proto-main">Основное</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<b>Прототип __proto__ [[Prototype]]</b>
	<li>Если один объект имеет специальную ссылку <u>__proto__</u> на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте <u>__proto__</u></li>
	<li>Объект, на который указывает ссылка <u>__proto__</u>, называется <u>«прототипом»</u></li>
</ul>

<!------------------------------------------------------>
<h3>Методы для работы с __proto__</h3>
<!------------------------------------------------------>
<pre><code class="js">
Object.<bg-code>getPrototypeOf</bg-code>(obj);        // возвращает obj.__proto__
Object.<bg-code>setPrototypeOf</bg-code>(obj, proto); // устанавливает obj.__proto__ = proto
Object.<bg-code>create</bg-code>(proto, descriptors); // создаёт пустой объект с __proto__, равным первому аргументу, второй содержит дескрипторы свойств
</code></pre>

<!------------------------------------------------------>
<h3>Свойство prototype</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<b class="margin-top">Свойство prototype</b>
	<li>При создании объекта через <u>new</u>, в его прототип <u>__proto__</u> записывается ссылка из <u>prototype</u> функции-конструктора</li>
	<li>Имеет смысл только у <u>конструктора</u>, когда есть вызов <u>new</u></li>
	<li>Назначение: указывать <u>__proto__</u> для новых объектов</li>
	<li>Значением prototype может быть только объект</li>
	<li>У каждой функции по умолчанию есть свойство <u>prototype</u></li>
</ul>

<pre><code class="js">
function User() {
    this.name = 'Tony';
}
function Admin() {
    this.id = 77;
}
Admin.<bg-code>prototype</bg-code> = new User();
// Admin.__proto__ = new User();
var admin = new Admin(); // => Admin {id: 77, __proto__: User name: "Tony"}
</code></pre>

<!------------------------------------------------------>
<h3>Свойство constructor</h3>
<!------------------------------------------------------>
<h4>Свойство constructor по умолчанию</h4>
<pre><code class="js">
// у каждой функции по умолчанию есть свойство prototype, содержащее объект
function MyFunc() {}
MyFunc.prototype = { 
	<bg-code>constructor</bg-code>: MyFunc 
};
var a = new MyFunc(); // => MyFunc {} __proto__: constructor: ƒ MyFunc()
</code></pre>

<h4>Перезапись свойства constructor</h4>
<pre><code class="js">
function MyFunc() {}
MyFunc.prototype = { 
	jumps: true 
};
var a = new MyFunc(); // => MyFunc {} __proto__: jumps: true 
</code></pre>

<h4>Создание объекта с тем же конструктором, что и данный</h4>
<pre><code class="js">
function User(name) {
    this.name = name;
    console.log(name);
}
var user1 = new User('Tony');
var user2 = new user1.<bg-code>constructor</bg-code>('Jack');
</code></pre>

<!------------------------------------------------------>
<h3>Полифил Object.create</h3>
<!------------------------------------------------------>
<h4>Исходный Object.create()</h4>
<pre><code class="js">
var objFirst = {
    name: 'Tony'
};
var objSecond = Object.create(objFirst); // => {} __proto__: name: "Tony"
</code></pre>

<h4>Полифил</h4>
<pre><code class="js">
var objFirst = {
    name: 'Tony'
};

//if (!Object.create) Object.create = inherit; // проверка поддержки Object.create
var objSecond = inherit(objFirst); // => {} __proto__: name: "Tony"

function inherit(proto) {
    function F() {}       // Создана новая функция F. Она ничего не делает с this, так что если вызвать new F, то получим пустой объект
    F.prototype = proto;  // Свойство F.prototype устанавливается в будущий прототип proto
    var object = new F(); // Результатом вызова new F будет пустой объект с __proto__ равным значению F.prototype
    return object;        // Получили пустой объект с заданным прототипом. Возвратим его
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="class-es5-proto">Объявление</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
function User(name) {
	this.name = name;
	this.avatar = 'Photo';
}
<bg-code>User.prototype.deleteAvatar</bg-code> = function() {
	this.avatar = null;
}
var user = new User('Jack'); // => User {name: "Jack", avatar: "Photo", __proto__: deleteAvatar: ƒ () }
user.deleteAvatar();
console.log(user);           // => User {name: "Jack", avatar: null, __proto__: deleteAvatar: ƒ ()}
</code></pre>


<h4>Наследование</h4>
<pre><code class="js red">
function Admin(name, id) {
	this.name = name;
	this.id = id;
	this.avatar = 'Photo';
}

Admin.prototype = Object.create(User.prototype);

Admin.prototype.changeMyId = function() {
	this.id = 1;
}

var admin = new Admin('Admin', 2);
</code></pre>









</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
