<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>

	<a href="#special">Особенности</a>
	<a href="#announcement">Объявление</a>
	<a href="#arguments">Псевдомассив аргументов "arguments"</a>
	<a href="#parameters">Параметры функции (ES6)</a>
	<a href="#arrow">Стрелочные функции (ES6)</a>
	<a href="#closures-theory">Замыкания (теория)</a>
	<a href="#closures">Замыкания</a>
	<a href="#recursion">Рекурсия</a>
	<a href="#named">Named Function Expression</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">



<h1>JavaScript Functions</h1>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="special">Особенности</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><span class="hl">Аргумент функции</span> - передаваемое значение</li>
	<li><span class="hl">Параметр функции</span> - принимаемое значение</li>
	<li>Директива <span class="hl">return</span> может использоваться без значения, чтобы прекратить выполнение и выйти из функции</li>
	<li>Если в функции не указан <span class="hl">return</span>, она вернет <span class="hl">undefined</span></li>
	<li>Функции (Function Declaration) совершают поднятие <span class="hl">hoisting</span> к началу контекста в котором объявлены, поэтому можно использовать функции до их объявления</li>
	<li>Функция - это особый тип объекта со специальными свойствами, например, constructor и call</li>
	<li>Функция <u>объект первого класса</u>, так как их можно передать в качестве аргумента в другие функции, как и любой другой объект</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="announcement">Объявление</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><span class="hl">Function Declaration</span> - функция, объявленная в основном потоке кода, создаются интерпретатором до выполнения кода</li>
	<li><span class="hl">Function Expression</span> - объявление функции в контексте какого-либо выражения, например присваивания. Создаются в процессе выполнения выражения, в котором созданы, в данном случае при операции присваивания</li>
</ul>

<!------------------------------------------------------>
<h3>1. Function Declaration</h3>
<!------------------------------------------------------>
<pre><code class="js">
function func(num) {
	console.log(num);
}
func(1);
</code></pre>

<pre><code class="js">
// присвоили ссылку на функцию
var a = func;
function func(){
	//
}
</code></pre>

<!------------------------------------------------------>
<h3>2. Function Expression (выражения функции)</h3>
<!------------------------------------------------------>
<pre><code class="js">
var func = function(num) {
	console.log(num);
}
func(2);
</code></pre>

<pre><code class="js">
var Task = function Task() {
	//
}
// создание нового объекта использую функцию Task
var task = new Task();
</code></pre>

<h4>Функцию можно скопировать в другую переменную</h4>
<pre><code class="js">
function sayHi() {   // создать функцию и поместить её в переменную sayHi
	alert( "Привет" );
}

var func = sayHi;    // копирование функции в новую переменную
func(); // Привет    // функцию можно вызывать и как sayHi() и как func()

sayHi = null;
sayHi();             // ошибка
</code></pre>

<!------------------------------------------------------>
<h3>3. Анонинимное с немедленным вызовом IIFE (самовызывающаяся)</h3>
<!------------------------------------------------------>
<ul class="list">
	<li><span class="hl">Immediately-Invoked Functional Expression (IIFE)</span> немедленно вызываемое функциональное выражение</li>
</ul>

<ul class="list-point">
	<li>Если браузер видит <u>function</u> в основном потоке кода – он считает, что это <u>Function Declaration</u></li>
	<li>Если же <u>function</u> идёт в составе более сложного выражения, то он считает, что это <u>Function Expression</u></li>
	<li>Скобки в анонимной функции нужны чтобы показать, что это <u>Function Expression</u>, который по правилам JavaScript можно вызвать «на месте»</li>
</ul>

<pre><code class="js">
(function(num) {
	console.log(num);
})(3);
</code></pre>

<pre><code class="js">
var count = (function(num) {
	console.log(num);
})(3);
</code></pre>

<h4>Анонимная функция</h4>
<pre><code class="js">
function ask(question, yes, no) {
	if (confirm(question)) yes()
	else no();
}

ask(
	"Вы согласны?",
	function() { alert("Вы согласились."); },
	function() { alert("Вы отменили выполнение."); }
);
</code></pre>

<h4>Возвращение функции</h4>
<pre><code class="js">
var func = function() {
	return function() {
		console.log('Hi');
	}
}
func()();
</code></pre>

<!------------------------------------------------------>
<h3>4. new Function</h3>
<!------------------------------------------------------>
<ul class="list">
	<b>new Function(params, code)</b>
	<li><span class="hl">params</span> - параметры функции через запятую в виде строки</li>
	<li><span class="hl">code</span> - код функции в виде строки</li>
</ul>

<pre><code class="js">
// создание функции из строки
var sum = new Function('a,b', 'return a+b;');
var result = sum(1, 2);
alert(result); // 3
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="named">Named Function Expression</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h3>Named Function Expression (NFE) - именованные функциональные выражения</h3>

<ul class="list-point">
	<li>Имя NFE используется для единственной цели – позволить изнутри функции вызвать саму себя</li>
	<li>Если функция задана как Function Expression, ей можно дать имя</li>
	<li>Оно будет доступно только внутри функции</li>
	<li>Это имя предназначено для надёжного рекурсивного вызова функции, даже если она записана в другую переменную</li>
	<li>С Function Declaration так поступить нельзя</li>
	<li>NFE нельзя перезаписать</li>
</ul>

<pre><code class="js">
var f = function sayHi(name) {
  alert( sayHi ); // изнутри функции - видно (выведет код функции)
};

alert( sayHi ); // снаружи - не видно (ошибка: undefined variable 'sayHi')
</code></pre>

<div class="container-flex"><div class="container-half"><pre><code class="js">
function f(n) {
  return n ? n * f(n - 1) : 1;
};

var g = f;
f = null;

alert( g(5) ); // запуск функции с новым именем - ошибка при выполнении!
// функция из своего кода обращается к своему старому имени f
// этой функции уже нет, f = null
</code></pre></div><div class="container-half"><pre><code class="js">
var f = function factorial(n) {
  return n ? n*factorial(n-1) : 1;
};

var g = f;  // скопировали ссылку на функцию-факториал в g
f = null;

alert( g(5) ); // 120, работает!
<br>
</code></pre></div></div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="arguments">Псевдомассив аргументов "arguments"</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Любая функция может быть вызвана с произвольным количеством аргументов</li>
	<li>Нет «перегрузки» функций, «полиморфизма функций»: объявление нескольких одинаковых функции с разными аргументами</li>
	<li>arguments - «псевдомассив» или «коллекция», т.е. объект, который похож на массив, в нём есть нумерованные свойства и length, но методов массива у него нет</li>
</ul>

<pre><code class="js">
<bg-code>arguments</bg-code>        // список аргументов по номерам (arguments[0], arguments[1])
<bg-code>arguments.length</bg-code> // количество аргументов
</code></pre>

<pre><code class="js">
function greet() {
	for (var i = 0; i < <bg-code>arguments.length</bg-code>; i++) {
		console.log(<bg-code>arguments[i]</bg-code>);
	}
}
greet('Tony', 'Jack', 'Anne');
</code></pre>

<!------------------------------------------------------>
<h3>Аргументы по умолчанию через ||</h3>
<!------------------------------------------------------>
<pre><code class="js">
function showWarning(width, title) {
	width = width || 200; // если не указана width, то width = 200
	title = title || "Предупреждение";
}
</code></pre>
<pre><code class="js">
// при передаче width = 0 или width = null, оператор ИЛИ заменит его на значение по умолчанию
// оператор ИЛИ если нужно использовать значение по умолчанию только если width === undefined
</code></pre>

<!------------------------------------------------------>
<h3>«Именованные аргументы» - объект в виде аргумента</h3>
<!------------------------------------------------------>
<pre><code class="js">
function showMessage(options) {
	var width = options.width || 200;
	var height = options.height || 100;
	var contents = options.contents || "Предупреждение";
}
</code></pre>
<pre><code class="js">
showMessage({
	contents: "Вы вызвали функцию"
});
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="parameters">Параметры функции (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Параметры по умолчанию (default parameters)</h3>
<!------------------------------------------------------>
<pre><code class="js">
function greet(greeting='Hello', name='Friend') {
	console.log(greeting + ' ' + name);
}
greet();
</code></pre>

<!------------------------------------------------------>
<h3>Оставшиеся параметры (rest parameters)</h3>
<!------------------------------------------------------>
<pre><code class="js">
// arguments - объект, содержащий переданные агрументы
[object Arguments] {
	0: arg1,
	1: arg2, 
	2: arg3,
	3: arg4
}
</code></pre>

<h4>ES5</h4>
<pre><code class="js">
function sum() {
	var sum = 0;
	Array.prototype.forEach.call(arguments, function(value) {
		sum += value;
	});
	console.log(sum);
}
sum(1, 2, 3, 4);
</code></pre>

<pre><code class="js">
function sum() {
	var sum = 0;
	for (let value in arguments) {
		sum += arguments[value];
	}
	console.log(sum);
}
sum(1, 2, 3, 4);
</code></pre>

<h4>ES6</h4>
<pre><code class="js">
// Синтаксис отдельных параметров превращает отдельные элементы в масссив
function sum(...values) {
	var sum = 0;
	values.forEach(function(value) {
		sum += value;
	});
	console.log(sum);
}
sum(1, 2, 3, 4);
</code></pre>
<pre><code class="js">
function sum(...values) {
	console.log(values.reduce(function(prevValue, currentValue){
		return prevValue + currentValue;
	}));
}
sum(1, 2, 3, 4);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="arrow">Стрелочные функции (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions
" target="_blank">MDN</a></li>
	<li>Стрелка должна стразу идти после параметров (на этой же строке)</li>
	<li>Стрелочные функции лексически привязаны к значению this. Стрелочные функции не содержат собственный контекст this, а используют значение this окружающего контекста</li>
	<li>Так как значение this определяется лексикой, вызов стрелочных функций с помощью методов call() или apply(), даже если передать аргументы в эти методы, не влияет на значение this</li>
	<li>Стрелочные функции не имеют собственного объекта arguments, поэтому в теле стрелочных функций arguments будет ссылаться на переменную в окружающей области</li>
	<li>Стрелочные функции не могут быть использованы как конструктор и вызовут ошибку при использовании с new</li>
	<li>Ключевое слово yield не может быть использовано в теле стрелочной функции. Как следствие стрелочные функции не могут быть использованы как генераторы</li>
</ul>

<!------------------------------------------------------>
<h3>2 агрумента</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var add = (x, y) => x + y;
<br>
</code></pre></div><div class="container-half"><pre><code class="js">
function add(x, y) {
	return x + y;
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>1 агрумент</h3>
<!------------------------------------------------------>
<blockquote>Если функция принимает 1 параметр, не нужно заключать его в скобки</blockquote>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var square = x => x*x;
<br>
</code></pre></div><div class="container-half"><pre><code class="js">
var square = function(x) {
	return x*x;
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Нет аргументов</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var giveMeAnswer = () => 42;
<br>
</code></pre></div><div class="container-half"><pre><code class="js">
var giveMeAnswer = function() {
	return 42;
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Не возвращает значение</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var log = () => console.log('hi');
<br>
</code></pre></div><div class="container-half"><pre><code class="js">
var log = function() {
	console.log('hi');
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Состоит из двух строк</h3>
<!------------------------------------------------------>
<blockquote>Если в стрелочной функции несколько строк, то используются фигурные скобки и return</blockquote>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var multiply = (x, y) => {
	var result = x*y;
	return result;
}
</code></pre></div><div class="container-half"><pre><code class="js">
var multiply = function(x, y) {
	var result = x*y;
	return result;
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Возвращает объект</h3>
<!------------------------------------------------------>
<blockquote>Возвращаемый объект оборачивается в круглые скобки</blockquote>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var getPerson = () => ({ name:'Jack' });
<br>
</code></pre></div><div class="container-half"><pre><code class="js">
var getPerson = function() {
	return { name:'Jack' }
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Самовызывающаяся функция (IIFE)</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half"><pre><code class="js">
(() => console.log('IIFE'))();
<br>
</code></pre></div><div class="container-half"><pre><code class="js">
(function(){
	console.log('IIFE');
})();
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>
<h4>Пример #1. Перебор массива (forEach) и сумма элементов</h4>
<pre><code class="js">
var numbers = [1, 2, 3, 4, 5];
var sum = 0;
// numbers.forEach(function(num){
// 	 sum += num;
// });
numbers.forEach(num => sum += num);
</code></pre>

<h4>Пример #2. Перебор каждого элемента массива (map) возведение в квадрат</h4>
<pre><code class="js">
var numbers = [1, 2, 3, 4, 5];
var squared = numbers.map(n => n * n);
</code></pre>

<h4>Пример #3. Объекты</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var person1 = {
	name: 'Tony',
	greet: function() {
		console.log('Hello' + this.name);
		console.log(this); // выведет объект person
	}
}
person1.greet();
</code></pre></div><div class="container-half"><pre><code class="js">
var person2 = {
	name: 'Tony',
	greet: () => {
		console.log('Hello' + this.name);
		console.log(this); // выведет объект из контекста (window)
	}
}
person2.greet();
</code></pre></div></div>

<ul class="list-point">
	<b>Особенности</b>
	<li>this берется из контекста (окружения) в котором функция объявлена в независимости от того где эта функция будет выполнена</li>
	<li>нельзя использовать как конструкторы объектов</li>
	<li>нельзя использовать .bind(), .call(), .apply(), т.к. нельзя изменить this, оно берется из контекста</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="closures-theory">Замыкания (теория)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list">

	<li><bg-list>1. Создание LexicalEnvironment</bg-list> Создается специальный внутренний объект (словарь / лексическое окружение / объект переменных) LexicalEnvironment, привязанный к этому вызову</li>
	<ul class="list-point">
		<li>LexicalEnvironment - это хранилище для данных в памяти и механизм для извлечения этих данных при обращении</li>
		<li>LexicalEnvironment существует когда есть хотя бы одна функция у которой свойство <u>[[Scope]]</u> ссылается на него</li>
		<li>LexicalEnvironment является внутренним, он скрыт от прямого доступ</li>
		<li>На верхнем уровне им является <u>«глобальный объект»</u>, в браузере – <u>window</u></li>
	</ul>

	<li><bg-list>2. Свойства LexicalEnvironment</bg-list> Все аргументы, функции переменные и константы внутри функции автоматически записываются в LexicalEnvironment и становятся <u>свойствами</u> LexicalEnvironment: имена становятся <u>ключами</u>, а значения <u>значениями</u> в LexicalEnvironment</li>

	<li><bg-list>3. Ссылка на [[Scope]]</bg-list> <u>LexicalEnvironment</u> получает ссылку на скрытое свойство <u>[[Scope]]</u>, которое ссылается на <u>LexicalEnvironment</u> в котором функция была создана, а также на все его <u>свойства</u>. Н-р если функция создана в глобальном объекте <u>window</u>, то <u>[[Scope]]</u> будет ссылаться на <u>window</u></li>

	<ul class="list-point">
		<li>Благодаря [[Scope]], функция имеет доступ к <u>внешним переменным</u></li>
		<li>[[Scope]] появляется и исчезает вместе с функцией</li>
		<li>К [[Scope]] нет прямого доступа</li>
		<li>При создании функции с использованием <u>new Function</u>, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window. Следствие - такие функции не могут использовать замыкание</li>
	</ul>
	
	<li><bg-list>4. Доступ к переменным</bg-list> Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем <u>LexicalEnvironment</u>, а затем, если её нет – ищет во внешнем объекте переменных, н-р <u>window</u></li>

	<li><bg-list>5. Доступ к внешним переменным</bg-list> Для доступа к внешней переменной функция по ссылке <u>[[Scope]]</u> обращается во <u>внешний объект переменных</u> и берёт то значение, которое там есть на момент обращения</li>
</ul>

<ul class="list-point">
	<b>Замыкание</b>
	<li><bg-header>Замыкание</bg-header> - функция и ее лексическая область видимости в которой она была создана. При этом функция замыкает в себе некоторую информацию из области видимости</li>

	<li>лексическое окружение - переменные внешней области видимости, к которым функция имеет доступ</li>
	<li>функция вместе со всеми внешними переменными, которые ей доступны</li>
	<li>сама функция и вся цепока видимости LexicalEnvironment, образованная при создании функции</li>
	<li>сочетании функции и окружения (глобальные переменные), где она была задана</li>
</ul>

<ul class="list-point">
	<b>Свойства замыкания</b>
	<li>Сохранение промежуточных данных (переменных)</li>
	<li>Инкапсуляция</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="closures">Замыкания</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Пример 1</h3>
<!------------------------------------------------------>
<pre><code class="js">
function sum(a) {
	return function(b) {
		return a + b;
	}
}
var s = sum(10);
console.log(s(15));
</code></pre>

<!------------------------------------------------------>
<h3>Пример 2</h3>
<!------------------------------------------------------>
<pre><code class="js">
var func = function() {
	var i = 10;
	return function() {
		return i;
	}
}
var anotherFunc = function() {
	var i = 20;
	console.log(func()());
}
anotherFunc();
</code></pre>

<!------------------------------------------------------>
<h3>Пример 3</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half"><pre><code class="js">
function counter() {
	var count = 0;
	return function() {
		count++;
		console.log(count);
	}
}
var plus = counter();
plus(); // 1
plus(); // 2
plus(); // 3
</code></pre></div><div class="container-half"><pre><code class="js code-select">
function counter() {
	var count = 0;
	return function() {
		return count++;
	}
}
var plus = counter();
console.log(plus()); // 0
console.log(plus()); // 1
console.log(plus()); // 2 <br>
</code></pre></div></div>

<pre><code class="js">
var counter = (function() {
	var count = 0;
	return function() {
		return count++;
	}
})();
console.log(counter()); // 0
console.log(counter()); // 1 
console.log(counter()); // 2 
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="recursion">Рекурсия</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h4>Степень pow(x, n) через рекурсию</h4>
<pre><code class="js">
function pow(x, n) {
	if (n != 1) { // пока n != 1, сводить вычисление pow(x,n) к pow(x,n-1)
		return x * pow(x, n - 1);
	} else {
		return x;
	}
}
alert( pow(2, 3) ); // 8
</code></pre>




</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
