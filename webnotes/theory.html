<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>

	<div class="theme">Парадигмы программирования</div>
    <a href="#paradigms">Парадигмы</a>
    <a href="#paradigms-imper">1. Императивное</a>
    <a href="#paradigms-decl">2. Декларативное</a>
    <a href="#paradigms-func">3. Функциональное</a>
    <a href="#paradigms-oop">4. Объектно-ориентированное</a>
    <a href="#composition">Композиция</a>
    <a href="#currying">Каррирование</a>

    <div class="theme">Паттерны проектирования</div>
    <a href="#patterns">Паттерны проектирования</a>

    <div class="part">Порождающие</div>
    <a href="#pattern-singleton">«Синглтон»</a>
    <a href="#pattern-builder">«Строитель»</a>
    <a href="#pattern-simple-factory">«Простая фабрика»</a>

    <div class="part">Структурные</div>
    <a href="#pattern-decorator">«Декоратор»</a>
    <a href="#pattern-facade">«Фасад»</a>

    <div class="part">Поведенческие</div>
    <a href="#pattern-observer">«Наблюдатель»</a>

    <div class="part">Неизвестно</div>
    <a href="#pattern-module">«Модуль»</a>
    <a href="#pattern-revealing-module">«Открытый модуль»</a>

    <div class="theme">Алгоритмы и структуры данных</div>
    <a href="#big-o-notation">Big-O Notation (сложность алгоритмов)</a>
    <a href="#structure-data">Структуры данных</a>
    <a href="#basic-algoritms">Базовые алгоритмы</a>

    <div class="theme">Принципы программирования</div>
    <a href="#solid">SOLID</a>
    <a href="#dry">DRY</a>
    <a href="#kiss">KISS</a>
    <a href="#yagni">YAGNI</a>
    <a href="#code-smell">Запахи кода</a>
    <a href="#refactoring">Рефакторинг</a>
    
    <div class="theme">Методологии разработки</div>
    <a href="#method-dev">Методологии разработки</a>
    <a href="#method-waterfall">Waterfall</a>
    <a href="#method-agile">Agile / Scrum / Kanban</a>
    <a href="#estimation">Эстимация</a>

    <div class="theme">Прочее</div>
    <a href="#web-applications">Виды веб приложений</a>
    <a href="#design">Эволюция веб-дизайна</a>
    <a href="#framework">Фреймворки</a>
    <a href="#mvc">MVC MVP MVVM</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms">Парадигмы программирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms">
<ol class="list-num">
    <li>Императивное (C, C++, Java)</li>
    <li>Декларативное (HTML, SQL)</li>
    <li>Структурное (Pascal, C)</li>
    <li>Функциональное (F#, Lisp, Erlang, Scala)</li>
    <li>Логическое</li>
    <li>Объектно-ориентированное (С#, Java)</li>
    <li>Аспектно-ориентированное</li>
</ol>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-imper">Императивное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-imper">

<ul class="list-point">
    <li><bg-define>Императивное программирование</bg-define> В исходном коде программы записываются инструкции (команды), которые выполняются последовательно</li>
</ul>

<b class="margin-top">Используется</b>
<ol class="list-num">
    <li>Именованные переменные</li>
    <li>Операторы присваивания</li>
    <li>Составные выражения</li>
    <li>Подпрограммы</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает как решить задачу (явное указание всех шагов)</li>
    <li>Изменение состояния (переменных)</li>
    <li>При вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию состояния переменных</li>
</ol>

<pre><code class="js">
function double (arr) {
    let results = []
    for (let i = 0; i < arr.length; i++){
        results.push(arr[i] * 2)
    }
    return results
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-decl">Декларативное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-decl">

<ul class="list-point">
    <li><bg-define>Декларативное программирование</bg-define></li>
</ul>

<b class="margin-top">Не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает что должно быть сделано</li>
    <li>Неизменяемость</li>
    <li>Многие декларативные подходы имеют определённый слой императивных абстракций</li>
    <li>Код является контекстно-независимым - его можно использовать в любой программе без изменений</li>
</ol>

<pre><code class="js">
function double (arr) {
    return arr.map((item) => item * 2)
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-func">Функциональное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-func">

<ul class="list-point">
    <li><bg-define>Функциональное программирование</bg-define> - последовательный вызов набора функций</li>
    <li>Процесс вычисления трактуется как вычисление значений функций в математическом понимании</li>
    <li>Специфические возможности по работе с функциями: передача функций другим функциям в качестве аргументов и возврат функций из других функций</li>
    <li>Предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций</li>
    <li>Описывает математические отношения между данными и целью</li>
    <li>Один из видов декларативного программрования</li>
    <li>Нужно что-то посчитать, но функция которая это считает возвращает не результат, а рецепт для вычисления результата, т.е. возвращает функцию, которая посчитает результат</li>
    <li>Методы для функционального программирования в JavaScript: arr.map, arr.forEach, arr.filter, arr.sort, arr.concat, arr.join, arr.reduce, arr.reduceRight, Object.assign, Object.keys()</li>
</ul>

<b class="margin-top">Что не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>При вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных</li>
    <li>То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций</li>
    <li>Не нужно описывать шаги, нужно определить функцию, выполнить функции последовательно и в результате выполнения набор функций будет получен результат</li>
    <li>Разделение функций и данных</li>
</ol>

<b class="margin-top">Концепции</b>
<ol class="list-num">
    <li><bg-define>Чистые функции</bg-define> (pure functions) - функция, которая при одинаковых аргументах всегда возвращает одни и те же значения и не имеет видимых побочных эффектов (side effects) ввода-вывода и памяти. Зависят только от своих параметров и возвращают только свой результат. Не влияют на состояние программы</li>
    <ul class="list-point">
        <b>Условия</b>
        <li><u>Детерменированная</u> - для одного и того же набора входных значений возвращает одинаковый результат</li>
        <li><u>Без побочных эффектов</u> В императивных языках некоторые функции в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывая их обработчики. Они называются функциями с побочными эффектами</li>
        <li>Для замены циклов в JS можно использовать map и reduce</li>
    </ul>

    <li><bg-define>Функции высшего порядка</bg-define> - функция принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата</li>

    <li><bg-define>Функции первого класса</bg-define> - функция трактуются как объект, то есть может быть передана другим функциям и ее можно вернуть из функций. Так же ее можно присваивать переменным let func = function(){}</li>







    <li><bg-define>Каррирование функций</bg-define> - все функции могут быть от одного аргумента. Преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному</li>

    <li><bg-define>Рекурсия</bg-define> В функциональных языках цикл обычно реализуется в виде рекурсии. Рекурсивные функции вызывают сами себя, позволяя операции выполняться снова и снова</li>

    <li><bg-define>Лямбда-исчисление</bg-define> - механизм «анонимных функций» - callback-функций, которые можно определить прямо в том месте, где они используются, и которые имеют доступ к локальным переменным текущей функции</li>

    <li><bg-define>Иммутабельность</bg-define> - свойство объектов не изменяться (н-р строка. строку нельзя поменять на месте, для изменения нужно создать новую строку). Принцип иммутабельности в ФП должен применяется для другими страктурами данных (списки, словари). Иммутабельный список - список в который нельзя добавить / удалить элемент, можно только итерироваться по ним. Можно создать новый список который содежит все элементы +1, при этом старый остается валадным</li>

    <li><bg-define>Замыкания</bg-define></li>
</ol>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-oop">Объектно-ориентированное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-oop">

<ul class="list-point">
    <li><bg-define>Объектно-ориентированное программирование</bg-define> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования</li>
</ul>

<b class="margin-top">Механизмы</b>
<ol class="list-point">
    <li><bg-define>Инкапсуляция</bg-define> - механизм языка, позволяющий ограничить доступ одних компонентов программы к другим. Группировка свойств и методов в один класс</li>
    <li>Инкапсуляция – отделение и защита внутреннего интерфейса от внешнего</li>
    <li><u>Внутренний интерфейс</u> – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными»</li>
    <li><u>Внешний интерфейс</u> – это свойства и методы, доступные снаружи объекта, их называют «публичными»</li>
    <li>Мы обращаемся с объектами как с единой сущностью, а не как с набором отдельных полей и методов, тем самым скрываем и защищаем реализацию класса. Если клиентский код не знает ничего, кроме публичного интерфейса, он не может зависеть от деталей реализации</li>

    <li><bg-define>Наследование</bg-define> - описание нового класса на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом</li>
    <li>Наследование транзитивно: класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса (Object). Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию</li>
    
    <li><bg-define>Полиморфизм</bg-define> - возможность объектов с одинаковой спецификацией иметь различную реализацию. «Один интерфейс, множество реализаций». Переопеределение методов у дочерних классов. Возможность единообразно обрабатывать объекты с различной реализацией при условии наличия общего интерфейса</li>
    
    <li><bg-define>Абстракция</bg-define> позволяет работать с объектами не вдаваясь в особенности их реализации</li>
    <li>Инкапсуляция помогает реализовать абстракцию</li>
    <li>Абстракция это способ представления объекта в программе</li>
    <li>Абстракция - объекты из окружающиего мира которые мы хотим описать</li>
</ol>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="composition">Композиция</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-composition">

<ul class="list-point margin-top">
    <li><bg-define>Композиция и Агрегация</bg-define> - расширение функционала класса за счет "внедрения" других классов</li>
    <li>Об агрегировании также часто говорят как об «отношении принадлежности» по принципу «у машины есть корпус, колёса и двигатель»</li>

    <li><bg-define>Агрегация (агрегирование по ссылке)</bg-define> - отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое - нет</li>

    <li><bg-define>Композиция (агрегирование по значению)</bg-define> - более строгий вариант агрегирования, когда включаемый объект может существовать только как часть класса. Если класс будет уничтожен, то и включённый объект тоже будет уничтожен. Объект не может выйти за рамки своего класса. Объект будет создаваться внутри класса при создании класса и будет уничтожаться перед уничтожением родительского класса</li>

    <li><bg-define>Функциональная композиция</bg-define> - передача результа вызова одной функции в качестве аргумента другой функции</li>
</ul>

<pre><code class="light">
<img src="img/js/composition.png"></code></pre>

<ul class="list-point">
    <li><em>Агрегация</em>: <bg-code>профессора - факультеты</bg-code>, профессора остаются жить после разрушения факультета</li>
    <li><em>Композиция</em>: <bg-code>университет - факультеты</bg-code>, факультеты без университета уничтожаются</li>
</ul>

<h4>Наследование и композиция</h4>
<div class="container-flex"><div class="container-half">
<ul class="list-point">
    <li><b>Наследование</b> - когда класс-наследник имеет все поля и методы родительского класса, и, как правило, добавляет какой-то новый функционал или/и поля</li>
    <li><b>Наследование предполагает</b> принадлежность к какой-то общности (похожесть). Наследуются атрибуты, т.е. возможности, другого класса, при этом объектов непосредственно родительского класса не создается</li>
    <li><b>Минус наследования</b> влияние родительского класса на дочерние</li>
</ul>
</div><div class="container-half">
<ul class="list-point">
    <li><b>Ассоциация (частные случаи: Композиция и Агрегация)</b> – когда один класс включает в себя другой класс в качестве одного из полей</li>
    <li><b>Композиция предполагает</b> формирование целого из частей. При композиции класс-агрегатор создает объекты других классов</li>
</ul>
</div></div>

<h4>Dependency Injection</h4>
<pre><code class="js">
function makeCoffee(coffee) {}
function produceCoffee() {
    return { iCoffee:true }
}
function barista(makeCoffee, produceCoffee) {
    let coffee = makeCoffee(produceCoffee());
}
barista(makeCoffee, produceCoffee);
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="currying">Каррирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-currying">

<ul class="list-point">
    <li><bg-define>Каррирование / Карринг (Currying)</bg-define> - в функциональном программирование - это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму <u>замыканий</u>, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат.
    <li>При каррировании число вложенных функций равно числу аргументов исходной функции. Каждая из этих функций ожидает собственный аргумент. Если функция аргументов не принимает, или принимает лишь один аргумент, то каррировать её нельзя</li>

    <li><bg-define>Частичное применение функций (Partial Function Application)</bg-define> - функцию преобразуют в другую функцию, обладающую меньшим числом аргументов. Некоторые аргументы такой функции оказываются зафиксированными (для них задаются значения по умолчанию</li>

    <li>Каррирование и преобразования функций реализуются в JavaScript благодаря замыканиям и тому, что функции в JS являются объектами первого класса (их можно передавать в качестве аргументов другим функциям, возвращать из них, присваивать переменным)</li>
</ul>

<!------------------------------------------------------>
<h3>Каррирование</h3>
<!------------------------------------------------------>
<h4>Пример 1</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
// исходная функция
function multiply(a, b, c) {
    return a * b * c;
}
multiply(1,2,3); // 6
<br><br><br><br><br><br><br><br>
</code></pre></div><div class="container-half"><pre><code class="js">
// каррирование
function multiply(a) {
    return (b) => {
        return (c) => {
            return a * b * c
        }
    }
}
log(multiply(1)(2)(3)) // 6

//const mul1 = multiply(1);
//const mul2 = mul1(2);
//const result = mul2(3);
//log(result); // 6
</code></pre></div></div>

<h4>Пример 2</h4>
<pre><code class="js">
function add(x){
    return function() {
        return x + y;
    }
}
inc = add(1);
console.log(inc(15));   // 16
console.log(add(8)(7)); // 15
</code></pre>

<!------------------------------------------------------>
<h3>Частичное применение функций</h3>
<!------------------------------------------------------>
<pre><code class="js">
function volume(l) {
    return (w, h) => {
        return l * w * h
    }
}
</code></pre>

<div class="container-flex"><div class="container-half"><pre><code class="js">
// вариант использования 1
const hV = volume(70);
hV(203,142);
hV(220,122);
hV(120,123);
</code></pre></div><div class="container-half"><pre><code class="js">
// вариант использования 2
volume(70)(90,30);
volume(70)(390,320);
volume(70)(940,340);
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Частичная функция через bind</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Вызов <u>bind</u> позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз</li>
    <li>Если в bind указаны аргументы - они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове</li>
</ul>

<pre><code class="html">
<a href="js.html#methods-this-bind" target="_blank">[Local] bind()</a>
</code></pre>

<pre><code class="js">
function mul(a, b) {
    return a * b;
};

// double умножает только на два
var double = mul.bind(null, 2); // контекст фиксируем null, он не используется

console.log( double(3) ); // = mul(2, 3) = 6
console.log( double(4) ); // = mul(2, 4) = 8
console.log( double(5) ); // = mul(2, 5) = 10
</code></pre>

<ul class="list-point">
    <li>При вызове double будет передавать свои аргументы исходной функции mul после тех, которые указаны в bind, то есть в данном случае после зафиксированного первого аргумента 2</li>
    <li>"double" является «частичной функцией» (partial function) от mul</li>
    <li>При помощи bind мы можем получить из функции её «частный вариант» как самостоятельную функцию</li>
</ul>

</div>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Методологии разработки</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-dev">Методологии разработки</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-dev">

<ul class="list-point">
    <li><bg-define>Методология разработки</bg-define> - организация труда, включающая идеологические принципы, план, контроль над процессами, подход к сотрудникам</li>
</ul>

<ol class="list-num">
    <li><u>Waterfall</u> - традиционный подход</li>
    <li><u>RUP (Rational Unified Process)</u> - рациональный (итеративный подход). ПО выходит с уменьшенной функциональностью, чтобы занять нишу на рынке и противостоять конкурентам, после чего дорабатывается</li>
    <li><u>Agile</u> - общая методология гибкой разработки</li>
    <li><u>Crystal Clear</u> - подход с уравниванием разработчиков в коллективе. Каждая команда является набором людей с разным уровнем знаний, разными умениями и опытом</li>
    <li><u>Spiral</u> - спиральный метод. Раннее выявление и уменьшение проектных рисков</li>
    <li><u>DSDM (Dynamic Systems Development Model)</u> - динамическая модель. При планировании в самом начале невозможно понимать всех тонкостей разработки, поэтому весь процесс — исследовательская работа</li>
    <li><u>FDD (Feature Driven Development)</u> - методология, рассматривающая будущие изменения. Процесс для обеспечения масштабируемости и повторяемости, при этом поощряющий творчество и инновации</li>
    <li><u>JAD (Joint Application Development)</u> - ориентированный на пользователя подход. Максимальная занятость в разработке конечного пользователя</li>
    <li><u>RAD (Rapid Application Development)</u> - модель быстрой разработки</li>
    <li><u>Scrum</u> - концепция работы в условиях сорванных сроков и идеологического кризиса</li>
    <li><u>XP (Extreme Programming)</u> - экстремальная разработка в динамической среде</li>
    <li><u>LD (Lean Development)</u> - метод, предполагающий бережное отношение ко всем участникам процесса</li>
</ol>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-waterfall">Waterfall</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-waterfall">

<ul class="list-point">
    <li><bg-define>Waterfall Model (каскадная модель)</bg-define> - модель процесса разработки программного обеспечения, в которой процесс разработки выглядит как поток, последовательно проходящий фазы.</li>
    <li>Весь процесс является жестким и линейным, имеет четкие цели для каждого этапа, новая фаза начинается по завершению предыдущей, нет возврата назад</li>
</ul>

<h4>Шаги</h4>
<ol class="list-num">
    <li><u>Требования</u> - список требований к ПО. В первую очередь, анализируются требования и пожелания заказчика, затем это проецируется на возможности компании и состояние рынка. В результате получается некий документ, где описывается, что должно делать ПО, но не как и с помощью каких инструментов</li>
    <li><u>Проектирование</u> -  согласовывается логика работы ПО. Здесь всё ещё не принимаются конкретные решения по реализации, но уже описывается функционирование всех разделов приложения. На выходе разработчики уже представляют, сколько по времени и кадровому составу может занять проект. Создаются документы, подробно описывающие для программистов способ и план реализации указанных требований</li>
    <li><u>Конструирование</u> (также «реализация» либо «кодирование») - речь идёт о конкретных инструментах для реализации идей: согласовываются требования к дизайну, языки программирования, уровни данных, сервисы и т. д. Формируется внешний облик готового продукта</li>
    <li><u>Воплощение</u> - исполнительский этап, на который, как правило, приходится большая часть разработки. Если классическая модель допускает свободное взаимодействие с предыдущими этапами, то на практике допускается лишь внесение незначительных правок в «Конструирование»</li>
    <li><u>Тестирование и отладка</u> (также «верификация»)</li>
    <li><u>Инсталляция</u></li>
    <li><u>Поддержка</u></li>
</ol>

<h4>Преимущества</h4>
<ul class="list-point">
    <li><u>Устойчива к изменению кадрового состава</u> Благодаря подробному документированию смена работников практически не влияет на сроки исполнения проекта</li>
    <li><u>Дисциплина</u> Модель заставляет разработчиков, вовлечённых в проект быть дисциплинированными, оставаться в рамках намеченного плана. При необходимости в общей модели добавляется орган управления, ответственный за принятие решений, исполнители же обязаны работать в рамках системы</li>
    <li><u>Гибкость на ранних этапах</u> Изменения в первых трёх фазах могут быть сделаны немедленно и с минимальными усилиями, поскольку они не подкреплены кодом</li>
    <li><u>Ориентация на сроки и финансы</u> Благодаря тому, что каждый этап полностью очерчивает контур будущего ПО, все разработчики понимают свою роль, границы работы и сроки исполнения. Это позволяет оперировать реальными цифрами перед заказчиком</li>
</ul>

<h4>Недостатки</h4>
<ul class="list-point">
    <li><u>Неадаптивная структура ПО</u> На первых этапах модель водопада может быть гибкой, но если на фазе тестирования выявляются проблемы в общей структуре – это влечёт за собой последствия в виде сорванных сроков и даже отказов заказчика. Таким образом, возрастает роль руководителей и ответственных разработчиков, с уровнем компетентности которых в любой компании часто бывают проблемы</li>
    <li><u>Игнорирует конечного пользователя</u> Чем ниже продвигается процесс в водопаде, тем меньше в нём роль заказчика. Внесение каких-либо изменений в функциональность ПО запускает всю цепочку этапов заново, поэтому продукты полученные по каскадной модели далеки от ориентации на массового пользователя</li>
    <li><u>Позднее тестирование</u> Более гибкие методологии используют тестирование в качестве фундаментальной операции, происходящей непрерывно. Waterfall же допускает низкую квалификацию сотрудников на каждом этапе и плохое качество исполнения, ведь при запоздалом тестировании проблемы невозможно решить фундаментально</li>
</ul>

<h4>Итого</h4>
<ol class="list-num">
    <span>Каскадная методология – хорошее решение точки зрения сроков и отчётности, но очень слабое в плане качества. Поэтому сегодня её рекомендуется использовать только в трёх случаях:</span>
    <li>При ориентации ПО на заказчика, требующего прозрачность работ и исполнение в назначенные сроки</li>
    <li>При наличии в штате руководителей соответствующей квалификации</li>
    <li>При исполнении проекта, не имеющего конкуренции на рынке</li>
</ol>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-agile">Agile / Scrum / Kanban</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-agile">

<!------------------------------------------------------>
<h3>Agile</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Agile (agile software development)</bg-define> методология - семейство «гибких» подходов к разработке ПО, основынная на итеративном проходе по scope задач в условиях работы разных специалистов с целью выпуска работоспособного продукта</li>

    <li>Agile предполагает, что при реализации проекта не нужно опираться только на заранее созданные подробные планы. Важно ориентироваться на постоянно меняющиеся условия внешней и внутренней среды и учитывать обратную связь от заказчиков и пользователей. Это поощряет разработчиков и инженеров экспериментировать и искать новые решения, не ограничивая себя жесткими рамками и стандартами</li>

    <li>К отдельным agile-подходам относятся <u>scrum</u> и <u>kanban</u></li>

    <li><bg-define>Product Owner (PO)</bg-define> - Product Manager в терминологии Scrum</li>
    <li><bg-define>Product Manager</bg-define> - отвечает за продукт. Несет ответственность за рождение новых продуктов, их подготовленность к выходу на рынок, ценовые характеристики, его целевую аудиторию и прочие характеристики</li>
    <li><bg-define>Project Manager (PM)</bg-define> - отвечает за процесс. Координатор. Отвечает за соблюдение сроков и мониторинг всех зависимостей между командами</li>

    <li><bg-define>Program Manager</bg-define></li>
    <li><bg-define>Product Lead / Product Director / Group Product Manager</bg-define> - начальник над несколькими PM. Отвечает за несколько продуктов одной ветки и определяет цели на более высоком уровне</li>
</ul>

<h4>Agile-манифест</h4>
<ul class="list-point">
    <li>Люди и взаимодействие важнее процессов и инструментов</li>
    <li>Работающий продукт важнее исчерпывающей документации</li>
    <li>Сотрудничество с заказчиком важнее согласования условий контракта. Устные договоренности между сотрудниками, между заказчиком и исполнителем важнее всего, что отражено в планах, договорах и техническом задании</li>
    <li>Готовность к изменениям важнее следования первоначальному плану </li>
</ul>


<pre><code class="html">
<a href="http://agilemanifesto.org/iso/ru/principles.html" target="_blank">[agilemanifesto] Принципы</a>
</code></pre>

<!------------------------------------------------------>
<h3>Scrum</h3>
<!------------------------------------------------------>
<pre><code class="html">
<a href="https://www.youtube.com/watch?v=cDvZaXzQezs" target="_blank">[YouTube] Agile и Scrum на пальцах</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Scrum</bg-define> «подход структуры». Гибкая методология по разработке ПО. Команда из 5-9 разработчиков</li>
    <li>Scrum-подход делит рабочий процесс на равные <u>спринты</u> – обычно это периоды от недели до месяца, в зависимости от проекта и команды. Перед спринтом формулируются задачи на данный спринт, в конце – обсуждаются  результаты, а команда начинает новый спринт. Спринты очень удобно сравнивать между собой, что позволяет управлять эффективностью работы</li>
    <li><b>Принципы:</b><br> 
        - не стремитесь сразу получить сложный продукт<br>
        - минимально жизнеспособный продукт можно показать пользователям и определить какие доработки нужны а какие нет</li>
    <li><b>Плюсы:</b><br> 
    - детальное задание необязательно<br>
    - разработка под контролем<br> 
    - цена оказывается ниже ввиду рисков закладываемых подрядчиком в фиксированную стоимость</li>
</ul>

<h4>Команда</h4>
<ol class="list-num">
    <li>Универсальная команда специалистов</li>
    <li><bg-define>Product Owner</bg-define> - Product Manager в терминологии Scrum. Соединяет команду с заказчиком. Человек, который управляет созданием продукта и отвечает за то, что получится в результате</li>
    <li><bg-define>Scrum Master (бизнес-аналитик)</bg-define> - помогает Product Owner организовать бизнес-процесс: проводит общие собрания, решает бытовые проблемы, мотивирует команду и следит за соблюдением Scrum-подхода. Переводит задачи написанные обычным язвком в задачи понятные разработчикам по средствам <u>Backlog</u></li>
</ol>

<h4>Backlog</h4>
<ol class="list-num">
    <li><bg-define>Backlog</bg-define> - приоритезированный список задач, куда записываются пожелания заказчика. Создают Scrum Master и Product Owner</li>
    <ol class="list-num">
        <li><u>Эпик</u> - большая часть функционала которая может быть завершена в рамках разработки (н-р: разработка личного кабинета пользователя). Эпики делятся на Сторисы</li>
        <li><u>Стори/Сторисы</u> - более мелкая часть функционала которая еще не может случить для задач разработки (н-р: кабинет пользователя может состоять из функционала по авторизации, по рассылке уведомлений и т.д.). Сторис отвечает на вопрос "Я как пользователь хочу ... (н-р: иметь возможность делать посты)"</li>
        <li><u>Таски/Задачи</u> - идут к разработчикам</li>
    </ol>
</ol>

<h4>Собрания</h4>
<ol class="list-num">
    <li><bg-define>Planning Poker / Scrum Poker</bg-define> - разбиение Сторис на задачи и оценка сложности задач в Story Points</li>
    <ul class="list-point">
        <li><bg-define>Story Points</bg-define> - оценивание с точки зрения сложности. Определяются эталонные задачи (кто за сколько врмени выполнял задачу). Отталкиваясь от эталонный оцениваются все остальные Сторис</li>
        <li>У всех на собрании есть карты на которых выставолены числа, соответствующие кол-ву Story Points. Для более честной оценки все взакрытую при объявлении задачи выбирают свое количество Story Points и после показывают что поставили</li>
    </ul>

    <li>Сессия временной оценки задач. Назначаются ответственные за задачи. По итогу есть список задач который помещается в <u>список TODO</u> - задач на разработку. Задачи оцененные, приориетизированные, есть назначенные разработчики. После этого спринт считается запущенным</li>

    <li><bg-define>Daily Scrum Meeting/Stand-Up</bg-define> - 15 минут ежедневно проводятся встречи проектной команды, где контролируется ход работ. Каждый участник команды рассказывает про свой текущий статус: - Что делал вчера? - Что буду делать сегодня? - Какие проблемы есть?</li>
</ol>

<h4>Cпринт</h4>
<ul class="list-point">
    <li><u>Спринт</u> - участок времени за который разработчики выполняют фиксированый набор задач, оцененных на <u>Planning Poker</u> и на оценочной сессии. В конце спринта всегда должен быть работоспособный кусок продукта либо сам продукт, который можно показать заказчику</li>
    <li>Начало: после Planning Poker и Сессии оценки</li>
    <li>Длина спринтов одинаковая и обычно выбираются кратными неделям: 1,2,4 недели</li>
    <li>В рамках спринта задача меняется свои статусы. Изначально после оценки задчи попадают в статус TODO</li>
    <li>По итогу спринта - продукт который можно показать клиенту. Каждый разработчки презентует те задачи, которые он сделал. Заказчик видим конкретный результат, вносит коррективы</li>
</ul>

<h4>Доска</h4>
<ol class="list-num">
    <li><bg-code>STORY / BACKLOG</bg-code> </li>
    <li><bg-code>TODO</bg-code> # после оценки</li>
    <li><bg-code>REJECTED</bg-code> # от тестировщика в случае нахождения багов</li>
    <li><bg-code>IN PROGRESS</bg-code> разработчик берет в разработку</li>
    <li><bg-code>REVIEW / TESTING / TO VERIFY</bg-code> # разработчик закончил</li>
    <li><bg-code>DONE</bg-code> переводит тестировщик</li>
</ol>

<ul class="list-point">
    <li>Разработчик берет задачу из REJECTED, переносит в IN PROGRESS и старается в приоритетном прядке ее закрыть</li>
    <Когда все задачи, относящиеся к Сторис завершены, считается что Стирис закрыта></li>
</ul>

<h4>Ретроспектива</h4>
<ul class="list-point">
    <li>После review ретроспектива - собрание на которым команда отвечает на вопросы <br>
    - "Что было сделано хорошо в Спринте"<br>
    - "Что мы делали плохо в спринте"<br>
    - "Что нужно сделать чтобы в следующем спринте работать лучше"</li>
    <li>Каждый в команде по очереди высказывается и предлагает варианты улучения процесса</li>
    <li>К концу ретроспективы список элементов на улучшение, который к концу следующего спринта смотрится и проверяется что улучшили, а что нет</li>
    <li>Оценивается эффуктивность команды. Берутся стори которые были закрыты и суммируются их Story Points. Если команда закрыра 30 Story Points, значит в следующем спринте можно запланировать 30 Story Points</li>
</ul>

<!------------------------------------------------------>
<h3>Kanban</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Kanban</bg-define> - «подход баланса». Гибкий метод управления проектами, целью которого является повышение производительности труда в командах</li>
    <li>Главная идея Kanban - визуализация рабочего процесса. Она заключается в создании физической панели, на которой можно наглядно отмечать прогресс</li>

    <li>Задача – сбалансировать разных специалистов внутри команды и избежать ситуации, когда дизайнеры работают сутками, а разработчики жалуются на отсутствие новых задач</li>
    <li>Вся команда едина – в kanban нет ролей владельца продукта и scrum-мастера. Бизнес-процесс делится не на универсальные спринты, а на стадии выполнения конкретных задач: «Планируется», «Разрабатывается», «Тестируется», «Завершено» и др.</li>
    <li>Главный показатель эффективности в kanban – это среднее время прохождения задачи по доске. Задача прошла быстро – команда работала продуктивно и слаженно. Задача затянулась – надо думать, на каком этапе и почему возникли задержки и чью работу надо оптимизировать</li>
    <li>Для визуализации agile-подходов используют доски: физические и электронные. Они позволяют сделать рабочий процесс открытым и понятным для всех специалистов, что важно, когда у команды нет одного формального руководителя</li>

    <li>В основе концепции лежат «спринты»</li>

    <li><bg-define>Спринт</bg-define> - короткая итерация, строго ограниченная по времени (обычно 2−4 недели). В это время минимизируется длительность совещаний, но увеличивается их частота (они называются «схватками»). Благодаря этому контроль за выполнением становится более гибким, а разработчики быстрее реагируют на возникающие проблемы. Традиционное планирование отходит на второй план, его место занимает журнал спринтов</li>
</ul>
</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="estimation">Эстимация</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-estimation">

<ul class="list-point">
    <li>Эстимация - оценки сроков и стоимости проекта</li>
</ul>

<h4>1. Экспертная оценка (Expert Judgement)</h4>
<ul class="list-point">
    <li>Формирование оценки с привлечением экспертов в данной требуемой области</li>
    <li>Эксперты выдвигают свои предположения по поводу оценки (сроков или стоимости). После этого можно усреднить все предложения, а можно постараться прийти к единому решению в ходе дискуссии</li>
</ul>

<h4>2. Метод оценки по 3 точкам (Three Point Estimation)</h4>
<ul class="list-point">
    <li>Сначала определяются <u>оптимистичная (O = Optimistic)</u>, <u>пессимистичная (P = Pessimistic)</u> и <u>реалистичная\средняя (M = Middle)</u> оценки</li>
    <li>Значения <u>P, M и O</u> определяются экспертно (в часах, днях, $). Для этого задаются вопросы типа: <br> «сколько времени займет проект, если все пойдет хорошо?», <br> «каким может быть самый негативный сценарий и сколько на него потребуется времени\усилий?» и т.д.</li>
    <li>Далее полученные значения P, M и O подставляются в формулу: <u>(O + 4 M + P) / 6</u></li>
    <li>Результат расчета дает усредненную оценку. Такая формула позволяет с одной стороны учесть возможные позитивные и негативные сценарии, а с другой – «сгладить» их влияние и получить более реальное значение оценки</li>
</ul>

<h4>3. Стоимость качества (Cost of Quality)</h4>
<ul class="list-point">
    <li>Сначала оценивается время / бюджет только на разработку функционала, без учета ошибок и проблем, как если бы у нас сразу получалось идеальное ПО без дефектов. А далее оценивается сколько дополнительного времени и бюджета потребуется на работу с ошибками и проблемами в реальности, чтобы приблизить ПО к тому самому «идеальному» состоянию</li>
    <li>При оценке затрат на обеспечение качества ПО можно проанализировать и учесть такие области:
    <ul class="list-point">
        <li>расходы на активности по предотвращению дефектов</li>
        <li>стоимость тестирования</li>
        <li>исправление внутренних ошибок</li>
        <li>исправление внешних проблем по интеграции</li>
        <li>затраты на установку и настройку ПО с учетом реальной среды и данных</li>
    </ul>
    </li>
</ul>

<h4>4. Оценка по аналогиям (Analogous Estimation)</h4>
<ul class="list-point">
    <li>Можно опираться на прошлый опыт решения подобных задач или проектов</li>
    <li>Чтобы найти знакомые или похожие на предыдущий опыт задачи можно сделать декомпозицию</li>
</ul>

<h4>5. Оценка по параметрам и моделирование (Parametric Model)</h4>
<ul class="list-point">
    <li>Один из самых точных и гибких методов оценки. Его суть в том, чтобы построить некую параметризированную модель-прогноз взяв за основу прошлый опыт, имеющиеся данные и метрики, статистику</li>
    <li>Фактически строится специальная математическая модель, которая позволяет отслеживать как меняется итоговая оценка в зависимости от исходных параметров</li>
</ul>

<h4>6. Оценка от частного к общему (Bottom-up Estimation)</h4>
<ul class="list-point">
    <li>Метод похож на экспертную оценку, только в данном случае прогноз делается не для всего проекта в целом, а отдельно для составляющих его задач. Как это выглядит: мы собираем экспертное мнение, например, у специалистов по анализу, разработке, тестированию, поддержке ПО. Суммируем их оценки вместе, добавляем к ним затраты времени на взаимодействие и формируем общий прогноз</li>
    <li>Другими словами, мы собираем оценку по частям, узнавая сколько необходимо времени каждому из участников процесса разработки ПО и сводим все воедино с учетом дополнительных рисков</li>
</ul>
</div>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Принципы программирования</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="solid">SOLID</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-solid">
<ul class="list-point">
    <li><bg-define>SOLID</bg-define> (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency inversion) - пять основных принципов ООП</li>
    <li>При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени</li>
    <li><b>Цель принципов</b>: способствуют изменениям; легко понимаемы; повторно используемы</li>
</ul>

<h4>Принципы</h4>
<ul class="list-point">
    <li><bg-define>[S] SRP</bg-define> (The Single Responsibility Principle. Принцип единственной ответственности)</li>
    <li>Каждый класс выполняет лишь одну задачу/ответственность</li>

    <li class="margin-top"><bg-define>[O] OCP</bg-define> (The Open Closed Principle. Принцип открытости/закрытости)</li>
    <li>Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации</li>
    <li>От класса можно наследоваться и расширить его функциональность, но нет прямой возможности менять функциональность базового класса</li>

    <li class="margin-top"><bg-define>[L] LSP</bg-define> (The Liskov Substitution Principle. Принцип подстановки Барбары Лисков)</li>
    <li>Если гарантируется функциональность для базового класса, то гарантируется функциональность для всех его потомков (поведение программы не изменится)</li>
    <li>Поведение в методах-наследниках менять нельзя</li>
    <li>Наследующий класс должен дополнять, а не изменять базовый и не должен противоречить поведению, заданному базовым классом</li>

    <li class="margin-top"><bg-define>[I] ISP</bg-define> (The Interface Segregation Principle. Принцип разделения интерфейса)</li>
    <li>Абстракция (API или класс) должна быть сгруппирована в мелкие единицы и содержать только необходимые методы, давая возможность использовать только то, что необходимо. При необходимости разделить функциональность на несколько классов. При изменении методов интерфейса не должны меняться программные сущности, которые этот метод не используют</li>
    <li>Программные сущности не должны зависеть от методов, которые они не используют</li>

    <li class="margin-top"><bg-define>[D] DIP</bg-define> (The Dependency Inversion Principle. Принцип инверсии зависимостей)</li>
    <li>Зависимость кода должна строиться от абстракции, а не от класса</li>
    <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций</li>
    <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций</li>
    <li>Зависимость на Абстракциях. Нет зависимости на что-то конкретное</li>
</ul>

<h4>Когда следует применять</h4>
<ul class="list-point">
    <li>Жесткость - трудно вносить изменнея в код. Одно изменение вносит изменение в другие модули</li>
    <li>Хрупкость - свойство программы повреждаться во многих местах при внесении одного изменения</li>
    <li>Ненужная сложность - содержание элементов не используемых в данный момент</li>
    <li>Ненужные повторения - проблема дублирования кода</li>
    <li>Непрозрачность - трудность кода для понимания</li>
</ul>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="dry">DRY</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-dry">
<ul class="list-point">
    <li><bg-define>DRY</bg-define> (Don’t Repeat Yourself. Не повторяйся) - нацелен на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования</li>
    <li>Формулируется как: «Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы»</li>
    <li>Когда принцип DRY применяется успешно, изменение единственного элемента системы не требует внесения изменений в другие, логически не связанные элементы. Те элементы, которые логически связаны, изменяются предсказуемо и единообразно</li>
    <li>Нарушения принципа <u>DRY</u> называют <u>WET - «Write Everything Twice»</u> (Пиши всё по два раза) или <u>«We enjoy typing»</u> (Нам нравится печатать)</li>
</ul>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="kiss">KISS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-kiss">
<ul class="list-point">
    <li><bg-define>KISS</bg-define> («Keep it simple, stupid») - принцип утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются</li>
    <li>Принцип, запрещающий использование более сложных средств, чем необходимо</li>
</ul>

<h4>Принципы</h4>
<ul class="list-point">
    <li>Разбивайте задачу на множество более маленьких задач, каждая задача должна решаться одним или парой классов</li>
    <li>Сохраняйте ваши классы/методы маленькими. Каждый метод должен состоять не более чем из 30-40 строк. Каждый метод должен решать одну маленькую задачу, а не множество случаев</li>
</ul>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="yagni">YAGNI</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-yagni">
<ul class="list-point">
    <li><bg-define>YAGNI</bg-define> («You aren't gonna need it». «Вам это не понадобится») - процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, то есть отказ добавления функциональности, в которой нет непосредственной надобности</li>
</ul>

<h4>Последствия написание кода, который не нужно прямо сейчас</h4>
<ul class="list-point">
    <li>Тратится время на добавление, тестирование и улучшение необходимой функциональности</li>
    <li>Новые функции должны быть отлажены, документированы и сопровождаться</li>
    <li>Новая функциональность ограничивает то, что может быть сделано в будущем, - ненужные новые функции могут впоследствии помешать добавить новые нужные</li>
    <li>Пока новые функции действительно не нужны, трудно полностью предугадать, что они должны делать, и протестировать их. Если новые функции тщательно не протестированы, они могут неправильно работать, когда впоследствии понадобятся</li>
    <li>Это приводит к тому, что программное обеспечение становится более сложным</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="code-smell">Запахи кода (Code Smell)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-code-smell">
<ul class="list-point">
    <li><bg-define>Code Smell (Запахи кода)</bg-define> - код с признаками (запахами) проблем в системе</li>
    <li>Запахи кода - ключевые признаки необходимости рефакторинга</li>
    <li>Запахи кода - это не набор чётких правил, а описание мест, на которые нужно обращать внимание при рефакторинге</li>
</ul>

<h4>Общие запахи объектно-ориентированного кода</h4>
<ol class="list-num">
    <li><bg-code>Дублирование кода</bg-code> - использование одинаковых структур кода в нескольких местах</li>
    <li><bg-code>Длинный метод</bg-code></li>
    <li><bg-code>Большой класс</bg-code></li>
    <li><bg-code>Длинный список параметров</bg-code> - использование объектов позволяет, в случае изменения передаваемых данных, модифицировать только сам объект</li>
    <li><bg-code>Расходящиеся модификации</bg-code> - проблема возникает, когда при модификации в системе невозможно выделить определённое место, которое нужно изменить</li>
    <li><bg-code>Стрельба дробью</bg-code> - при выполнении любых модификаций приходится вносить множество мелких изменений в большое число классов</li>
    <li><bg-code>Завистливые функции</bg-code> - метод обращается к данным другого объекта чаще, чем к собственным данным</li>
    <li><bg-code>Группы данных</bg-code> - группы данных, встречающихся совместно, нужно превращать в самостоятельный класс</li>
    <li><bg-code>Одержимость элементарными типами</bg-code> - Проблема связана с использованием элементарных типов вместо маленьких объектов для небольших задач, таких как валюта, диапазоны, специальные строки для телефонных номеров и т.д.</li>
    <li><bg-code>Операторы типа switch</bg-code> - часто один и тот же блок switch оказывается разбросанным по разным местам программы. При добавлении в переключатель нового варианта приходится искать все эти блоки switch и модифицировать их</li>
    <li><bg-code>Параллельные иерархии наследования</bg-code> - всякий раз при порождении подкласса одного из классов приходится создавать подкласс другого класса</li>
    <li><bg-code>Ленивый класс</bg-code> - класс, затраты на существование которого не окупаются выполняемыми им функциями, должен быть ликвидирован</li>
    <li><bg-code>Теоретическая общность</bg-code> - на определённом этапе существования программы обеспечивается набор механизмов, который, возможно, потребуется для некоторой будущей функциональности. Программу становится труднее понимать и сопровождать</li>
    <li><bg-code>Временное поле</bg-code> поле, которое нужно объекту только при определённых обстоятельствах. Такое положение вещей трудно для понимания, так как ожидается, что объекту нужны все его поля</li>
    <li><bg-code>Цепочка вызовов</bg-code> появляется тогда, когда клиент запрашивает у одного объекта другой объект, другой объект запрашивает ещё один объект и т. д. Такие последовательности вызовов означают, что клиент связан с навигацией по структуре классов. Любые изменения промежуточных связей означают необходимость модификации клиента</li>
    <li><bg-code>Посредник</bg-code> - чрезмерное использование делегирования может привести к появлению классов, у которых большинство методов состоит только из вызова метода другого класса</li>
    <li><bg-code>Неуместная близость</bg-code> возникает тогда, когда классы чаще, чем следовало бы, погружены в закрытые части друг друга</li>
    <li><bg-code>Альтернативные классы с разными интерфейсами</bg-code> - два класса, в которых часть функциональности общая, но методы, реализующие её, имеют разные параметры</li>
    <li><bg-code>Неполнота библиотечного класса</bg-code> Библиотеки через некоторое время перестают удовлетворять требованиям пользователей. Естественное решение — поменять кое-что в библиотеках, но библиотечные классы не изменять</li>
    <li><bg-code>Классы данных</bg-code> - это классы, которые содержат только поля и методы для доступа к ним, это просто контейнеры для данных, используемые другими классами</li>
    <li><bg-code>Отказ от наследства</bg-code> Если наследник использует лишь малую часть унаследованных методов и свойств родителя, это является признаком неправильной иерархии</li>
    <li><bg-code>Комментарии</bg-code> Почувствовав потребность написать комментарий, попробуйте изменить структуру кода так, чтобы любые комментарии стали излишними</li>
</ol>
</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="refactoring">Рефакторинг</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-refactoring">
<ul class="list-point">
    <li><bg-define>Рефакторинг (refactoring)</bg-define> - процесс изменения внутренней структуры программы, не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В основе рефакторинга лежит последовательность небольших эквивалентных (то есть сохраняющих поведение) преобразований. Поскольку каждое преобразование маленькое, программисту легче проследить за его правильностью, и в то же время вся последовательность может привести к существенной перестройке программы и улучшению её согласованности и чёткости</li>
    <li>Цель рефакторинга — сделать код программы более легким для понимания; без этого рефакторинг нельзя считать успешным</li>
    <li>Рефакторинг следует отличать от <u>оптимизации производительности</u>. Как и рефакторинг, оптимизация обычно не изменяет поведение программы, а только ускоряет её работу. Но оптимизация часто затрудняет понимание кода, что противоположно рефакторингу</li>
    <li>С другой стороны, нужно отличать рефакторинг от <u>реинжиниринга</u>, который осуществляется для расширения функциональности программного обеспечения. Как правило, крупные рефакторинги предваряют реинжиниринг</li>
</ul>

<h4>Причины применения рефакторинга</h4>
<ol class="list-num">
    <li>Необходимо добавить новую функцию, которая недостаточно укладывается в принятое архитектурное решение</li>
    <li>Необходимо исправить ошибку, причины возникновения которой сразу не ясны</li>
    <li>Преодоление трудностей в командной разработке, которые обусловлены сложной логикой программы</li>
</ol>

<h4>Признаки плохого кода</h4>
<ol class="list-num">
    <li>Дублирование кода</li>
    <li>Длинный метод</li>
    <li>Большой класс</li>
    <li>Длинный список параметров</li>
    <li>"Жадные" функции — это метод, который чрезмерно обращается к данным другого объекта</li>
    <li>Избыточные временные переменные</li>
    <li>Классы данных</li>
    <li>Несгруппированные данные</li>
</ol>

<h4>Методы рефакторинга</h4>
<ul class="list-point">
    <li><bg-code>Изменение сигнатуры метода (change method signature)</bg-code> - добавление, изменение или удаление параметра метода. Изменив сигнатуру метода, необходимо скорректировать обращения к нему в коде всех клиентов. Это изменение может затронуть внешний интерфейс программы, кроме того, не всегда разработчику, изменяющему интерфейс, доступны все клиенты этого интерфейса, поэтому может потребоваться та или иная форма регистрации изменений интерфейса для последующей передачи их вместе с новой версией программы
    </li>

    <li><bg-code>Инкапсуляция поля (encapsulate field)</bg-code> В случае, если у класса имеется открытое поле, необходимо сделать его закрытым и обеспечить методы доступа. После «Инкапсуляции поля» часто применяется «Перемещение метода»</li>
    
    <li><bg-code>Выделение класса (extract class)</bg-code></li>
    <li><bg-code>Выделение интерфейса (extract interface)</bg-code></li>
    <li><bg-code>Выделение локальной переменной (extract local variable)</bg-code></li>
    <li><bg-code>Выделение метода (extract method)</bg-code> - выделение из длинного и/или требующего комментариев кода отдельных фрагментов и преобразовании их в отдельные методы, с подстановкой подходящих вызовов в местах использования. В этом случае действует правило: если фрагмент кода требует комментария о том, что он делает, то он должен быть выделен в отдельный метод. Также правило: один метод не должен занимать более чем один экран (25-50 строк, в зависимости от условий редактирования), в противном случае некоторые его фрагменты имеют самостоятельную ценность и подлежат выделению. Из анализа связей выделяемого фрагмента с окружающим контекстом делается вывод о перечне параметров нового метода и его локальных переменных</li>
    
    <li><bg-code>Генерализация типа (generalize type)</bg-code></li>
    <li><bg-code>Встраивание (inline)</bg-code></li>
    <li><bg-code>Введение фабрики (introduce factory)</bg-code></li>
    <li><bg-code>Введение параметра (introduce parameter)</bg-code></li>
    <li><bg-code>Подъём метода (pull up method)</bg-code></li>
    <li><bg-code>Спуск метода (push down method)</bg-code></li>
    <li><bg-code>Переименование метода (rename method)</bg-code></li>
    <li><bg-code>Перемещение метода (move method)</bg-code> применяется по отношению к методу, который чаще обращается к другому классу, чем к тому, в котором сам располагается</li>

    <li><bg-code>Замена условного оператора полиморфизмом (replace conditional with polymorphism)</bg-code> Условный оператор с несколькими ветвями заменяется вызовом полиморфного метода некоторого базового класса, имеющего подклассы для каждой ветви исходного оператора. Выбор ветви осуществляется неявно, в зависимости от того, экземпляру какого из подклассов оказался адресован вызов</li>
    
    <li><bg-code>Замена наследования делегированием (replace inheritance with delegation)</bg-code></li>
    <li><bg-code>Замена кода типа подклассами (replace type code with subclasses)</bg-code></li>
</ul>

<h4>Проблемы, возникающие при проведении рефакторинга</h4>
<ul class="list-point">
    <li>Проблемы, связанные с базами данных</li>
    <li>Проблемы изменения интерфейсов</li>
    <li>Трудности при изменении дизайна</li>
</ul>

<h4>Средства автоматизации рефакторинга</h4>
<ul class="list-point">
    Технические критерии для инструментов рефакторинга:
    <li>Базы данных программы</li>
    <li>Деревья синтаксического разбора</li>
    <li>Точность</li>
    Практические критерии для инструментов рефакторинга:
    <li>Скорость</li>
    <li>Отмена модификаций</li>
    <li>Интеграция с другими инструментами</li>
</ul>
</div>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Прочее</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-applications">Виды веб приложений</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><bg-define>SSR</bg-define> - Server-Side Rendering (рендеринг на стороне сервера)</li>
    <li><bg-define>SPA</bg-define> - Single-Page Application (одностраничное приложение)</li>
    <li><bg-define>PWA</bg-define> - Progressive Web App (прогрессивное веб-приложение)</li>
    <li>Стандартные HTML страницы</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="design">Эволюция веб-дизайна</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre>
<code class="js">
1990-2000  Нет дизайна
2000-2010  Скевоморфизм
2010-2013  Flat Design  
2014-2017  Material Design
2018-....  Fluent Design
</code>
</pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="framework">Фреймворки (особенности)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- структура приложения 
- паттерны проектирования
- строгая структура (модульность) приложения
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="mvc">MVC MVP MVVM</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- MVC (модель вид контроллер)
- MVP (модель вид представитель)
- MVVM (модель вид модель представления)
</code></pre>

<pre><code class="plaintext">
<em>MVC</em>
<em>model</em>      - бизнес-логика (просчитывание данных, операций)
<em>view</em>       - видимая часть
<em>controller</em> - берет данные из view и передает в model (запускает model)
</code></pre>



<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Паттерны проектирования</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="patterns">Паттерны проектирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-patterns">
<pre><code class="html">
<a href="https://refactoring.guru/ru/design-patterns/catalog" target="_blank">Каталог паттернов проектирования</a>
<a href="https://habr.com/ru/company/ruvds/blog/427293/" target="_blank">Паттерны проектирования в JavaScript</a>
<a href="https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9" target="_blank">Шаблоны проектирования в JavaScript</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Паттерн проектирования (design pattern)</bg-define> - это часто встречающееся решение определённой проблемы при проектировании архитектуры программ</li>
    <li>В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды программы</li>
    <li>Паттерны часто путают с <u>алгоритмами</u>, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах</li>
</ul>

<!------------------------------------------------------>
<h3>Классификация</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Порождающие</bg-define> отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей</li>
    <ul class="list-point">
        <li><bg-code>Фабричный метод (Factory Method)</bg-code> Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов</li>
        <li><bg-code>Абстрактная фабрика (Abstract Factory)</bg-code> Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов. Интерфейс, который группирует другие фабрики, логически связанные друг с другом</li>
        <li><bg-code-accent>Строитель (Builder)</bg-code-accent> Позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов</li>
        <li><bg-code>Прототип (Prototype)</bg-code> Позволяет копировать объекты, не вдаваясь в подробности их реализации</li>
        <li><bg-code-accent>Одиночка (Singleton)</bg-code-accent> Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа</li>
    </ul>

    <li><bg-define>Структурные</bg-define> отвечают за построение удобных в поддержке иерархий классов. Показывают различные способы построения связей между объектами</li>
    <ul class="list-point">
        <li><bg-code>Адаптер (Adapter)</bg-code> Позволяет объектам с несовместимыми интерфейсами работать вместе</li>
        <li><bg-code>Мост (Bridge)</bg-code> Разделяет один или несколько классов на две отдельные иерархии - абстракцию и реализацию, позволяя изменять их независимо друг от друга</li>
        <li><bg-code>Компоновщик (Composite)</bg-code> Позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, как будто это единичный объект</li>
        <li><bg-code-accent>Декоратор (Decorator)</bg-code-accent> Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»</li>
        <li><bg-code-accent>Фасад (Facade)</bg-code-accent> Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку</li>
        <li><bg-code>Легковес (Flyweight)</bg-code> Позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте</li>
        <li><bg-code>Заместитель (Proxy)</bg-code> Позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу</li>
    </ul>

    <li><bg-define>Поведенческие</bg-define> решают задачи эффективного и безопасного взаимодействия между объектами программы</li>
    <ul class="list-point">
        <li><bg-code>Цепочка обязанностей (Chain of Responsibility)</bg-code> Позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи</li>
        <li><bg-code>Команда (Command)</bg-code> Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций</li>
        <li><bg-code>Итератор (Iterator)</bg-code> Даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления</li>
        <li><bg-code>Посредник (Mediator)</bg-code> Позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник</li>
        <li><bg-code>Снимок (Memento)</bg-code> Позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов</li>
        <li><bg-code-accent>Наблюдатель (Observer)</bg-code-accent> Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах</li>
        <li><bg-code>Состояние (State)</bg-code> Позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта</li>
        <li><bg-code>Стратегия (Strategy)</bg-code> Определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы</li>
        <li><bg-code>Шаблонный метод (Template method)</bg-code> Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры</li>
        <li><bg-code>Посетитель (Visitor)</bg-code> Позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться</li>
    </ul>

</ul>

<!------------------------------------------------------>
<h3>Зачем?</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-code>Проверенные решения</bg-code> Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда</li>
    <li><bg-code>Стандартизация кода</bg-code> Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так как все скрытые проблемы в них уже давно найдены</li>
    <li><bg-code>Общий программистский словарь</bg-code> Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, какой крутой дизайн вы придумали и какие классы для этого нужны</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-simple-factory">Паттерн «Простая фабрика»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-simple-factory">
<ul class="list-point">
    <li><bg-define>«Простая фабрика»</bg-define> - производит нужный экземпляр, не утруждая клиента тонкостями этого процесса</li>
    <li>Ненужно каждый раз создавать экземпляр класса</li>
</ul>
<pre><code class="js">
class WoodenDoor {
    constructor(width, height){
        this.width = width
        this.height = height
    }
    getWidth(){
        return this.width
    }
    getHeight(){
        return this.height
    }
}
const DoorFactory = {
    makeDoor(width, height) {
        return new WoodenDoor(width, height); 
    }
}
const door = DoorFactory.makeDoor(100, 200)
console.log('Width:', door.getWidth())
console.log('Height:', door.getHeight())
</code></pre>
</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-singleton">Паттерн «Синглтон»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-singleton">
<ul class="list-point">
    <li><bg-define>«Синглтон» (Singleton)</bg-define> порождающий паттерн проектирования, гарантирующий что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа в однопоточном приложении</li>
    <li>В рамках применения этого паттерна новый экземпляр некоего класса создаётся в том случае, если он пока не создан. Если же экземпляр класса уже существует, то, при попытке обращения к конструктору, возвращается ссылка на соответствующий объект. Последующие вызовы конструктора всегда будут возвращать тот же самый объект</li>

    <li><b>Зачем:</b> Использование конструктора плохая практика, особенно если у класса есть зависимости var user = new User()</li>
</ul>

<h4>Какие проблемы решает</h4>
<ol class="list-num">
    <li><bg-code>Гарантирует наличие единственного экземпляра класса</bg-code> Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных. Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект</li>
    <li><bg-code>Предоставляет глобальную точку доступа</bg-code> Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома</li>
</ol>

<!------------------------------------------------------>
<h3>Представление класса в виде синглтона</h3>
<!------------------------------------------------------>
<h4>Обычный класс a !== b</h4>
<pre><code class="js">
class usualClass {
    constructor() {
        // this.name = null;
    }
    testMethod() {
        return 'Hello'
    }
}

var a = new usualClass();
var b = new usualClass();
<bg-code>console.log(a === b); // false</bg-code>
console.log(a.testMethod());
</code></pre>


<div class="container-flex"><div class="container-half"><h4>Singleton ES5</h4><pre><code class="js">
const Universe = (function(){
    let instance = null;
    function func() {
        if (!instance) {
            instance = this;
            this.size = 100;
        }
        return instance;
    }
    func.prototype.getSize = function() {
       return this.size;
    }
    func.prototype.setSize = function(size) {
       this.size = size;
    }
    return func;
})();

var a = new Universe();
var b = new Universe();

<bg-code>console.log(a === b); // true</bg-code>
console.log(a.getSize(), b.getSize()); // 100, 100
a.setSize(200);
console.log(a.getSize(), b.getSize()); // 200, 200
</code></pre></div><div class="container-half"><h4>Singleton ES6</h4><pre><code class="js">
var instance = null;

class Singleton {
    constructor() {
        if(!instance){
            instance = this;
        }
        return instance;
    }
}
var a = new Singleton();
var b = new Singleton();
<bg-code>console.log(a === b); // true</bg-code>
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Представление класса в виде объектного литерала</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Всякий раз, когда мы обращаемся к переменной user, мы получаем ссылку на один и тот же объект</li>
</ul>
<pre><code class="js">
const user = {
    name: 'Tony',
    greet: function() {
        console.log('Hello!');
    }
};
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-decorator">Паттерн «Декоратор»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-decorator">

<ul class="list-point">
    <li><bg-define>«Декоратор»</bg-define> - структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»</li>
    <li>Расширения функционала объектов без модификации существующих классов или функций-конструкторов. Паттерн можно использовать для добавления к объектам неких возможностей без модификации кода, который ответственен за их создание</li>
    <li>Применяя «Декоратор», вы не меняете первоначальный класс и не создаёте дочерних классов</li>
</ul>

<pre><code class="js">
function Car(name) {
    this.name = name;
    this.color = 'White';
}

// создание нового объекта, который планируется декорировать
const tesla = new Car('Tesla Model 3');

// декорирование объекта - добавление нового функционала
tesla.setColor = function(color) {
    this.color = color;
}
tesla.setPrice = function(price) {
    this.price = price;
}

tesla.setColor('black');
tesla.setPrice(49000);
console.log(tesla.color); // выводит black
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-builder">Паттерн «Строитель»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-builder">
<ul class="list-point">
    <li><bg-define>«Строитель»</bg-define> - порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов</li>
    <li>Паттерн Строитель нужен, если объект может существовать в разных вариациях или процесс инстанцирования состоит из нескольких шагов</li>
</ul>

<h4>Пример гамбургера с разными компонентами</h4>
<pre><code class="js">
class BurgerBuilder {
    constructor(size) {
        this.size = size
    }
    addPepperoni() {
        this.pepperoni = true
        return this
    }
    addCheeze() {
        this.cheeze = true
        return this
    }
    build() {
        return new Burger(this)
    }
}
const burger = (new BurgerBuilder(14))
    .addPepperoni()
    .addCheeze()
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-observer">Паттерн «Наблюдатель»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-observer">
<ul class="list-point">
    <li><bg-define>«Наблюдатель»</bg-define> - поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах</li>
    <li>Основан на зависимости один ко многим: при изменении состояния одного объекта (Observer), все зависимые объекты (Observable) оповещаются об этом. Самое главное в общении этих двух объектов, что не нужна прямая связь между объектом и субъектом. Это позволяет добиться модульности клиентской части кода</li>
    <li><u>Observable</u> (Издатели) - наблюдаемый объект. Содержит список [Observer] и если у него что-то происходит, всех оповещает в цикле. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков</li>
    <li><u>[Observer]</u> (Подписчики) - наблюдатели (кучка объектов) за Observable</li>
</ul>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-module">Паттерн «Модуль»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-module">
<ul class="list-point">
    <li><bg-define>Модуль</bg-define> - прием, с помощью которого мы можем скрывать какие-то реализации. Самостоятельный фрагмент кода, который можно изменять, не затрагивая другой код проекта. Модули, кроме того, позволяют избегать такого явления, как загрязнение областей видимости, благодаря тому, что они создают отдельные области видимости для объявляемых в них переменных.</li>
    <li>Модуль использует <u>IIFE</u>, <u>замыкания</u> и <u>области видимости функций</u> для имитации концепции <u>инкапсуляции</u></li>
    <li><bg-code>Модуль при помощи замыканий</bg-code> – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется</li>
    <li>Все функции модуля будут иметь доступ к другим переменным и внутренним функциям этого же модуля через замыкание. Но снаружи программист, использующий модуль, может обращаться напрямую только к тем переменным и функциям, которые экспортированы. Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля</li>
    <li><b>Недостаток</b> приходится создавать публичные функции только для того, чтобы обращаться к приватным функциям и переменным</li>
</ul>

<pre><code class="js">
const myModule = (function() {
    const privateVariable = 'Hello World';
    function privateMethod() {
        console.log(privateVariable);
    }
    return {
        publicMethod: function() {
            privateMethod();
        }
    }
})();
</code></pre>

<pre><code class="js">
myModule.publicMethod(); // Выводит 'Hello World'
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-facade">Паттерн «Фасад»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-facade">
<ul class="list-point">
    <li><bg-define>«Фасад»</bg-define> - структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку</li>
</ul>

<pre><code class="js">
var $ = function(target) {
    return new MemeQuery(target);
}
function MemeQuery(target) {
    this.target = document.querySelector(target);
}
MemeQuery.prototype.html = function(html) {
    this.target.innerHTML = html;
    return this;
}

$('#myParagraph').html('Meeemee').html('Some JS design patterns');
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-revealing-module">Паттерн «Открытый модуль»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-revealing-module">

<ul class="list-point">
    <li><bg-define>Открытый модуль</bg-define> - в паттерне назначаем свойствам возвращаемого объекта приватные функции, которые хотим сделать общедоступными</li>
</ul>

<ul class="list-point">
    <b>Преимущества паттерна «Открытый модуль» перед паттерном «Модуль»</b>
    <li>«Открытый модуль» позволяет делать общедоступными скрытые сущности модуля (и снова скрывать их, если нужно), модифицируя, для каждой из них, лишь одну строку в объекте, возвращаемом после выполнения IIFE</li>
    <li>Возвращаемый объект не содержит определения функций. Всё, что находится справа от имён его свойств, определено в IIFE. Это способствует чистоте кода и упрощает его чтение</li>
</ul>

<pre><code class="js">
const myRevealingModule = (function() {
    let privateVar = 'Peter';
    const publicVar  = 'Hello World';
    function privateFunction() {
        console.log('Name: '+ privateVar);
    }
    function publicSetName(name) {
        privateVar = name;
    }
    function publicGetName() {
        privateFunction();
    }
    return {
        setName: publicSetName,
        greeting: publicVar,
        getName: publicGetName
    };
})();
</code></pre>

<pre><code class="js">
myRevealingModule.setName('Mark');
myRevealingModule.getName(); // Выводит Name: Mark
</code></pre>

</div>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Алгоритмы и структуры данных</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="big-o-notation">Big-O Notation (сложность алгоритмов)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-big-o-notation">

<pre><code class="html">
<a href="https://www.youtube.com/watch?v=ZRdOb4yR0kk" target="_blank">[YouTube] Оценка сложности алгоритма</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Big-O Notation</bg-define> показывает <b>верхнюю границу сложности алгоритма</b> зависимости между <b>входными параметрами</b> функции и <b>количеством операций</b>, которые выполнит процессор</li>

    <li>Нельзя оценивать работу алгоритм с точки зрения времени. Один и тот же алгоритм на разных машинах будет выполняться разное время. Алгоритм включает в себя число шагов. Идея Big-O - сколько шагов нужно сделать чтобы алгоритм завершил свое выполнение</li>

    <li><bg-define>Сложность алгоритма (вычислительная сложность)</bg-define> - функция зависимости объёма работы, которая выполняется некоторым алгоритмом, от размера входных данных</li>

    <li>Объём работы обычно измеряется временем и вычислительными ресурсами. Время определяется количеством элементарных шагов, необходимых для решения задачи. Ресурсы определяются объёмом памяти или места на носителе данных</li>
</ul>

<!------------------------------------------------------>
<h3>Верхняя граница (отбрасывание констант)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Мы говорим как будет вести себя алгоритм на бесконечности</li>
    <li>Если алгоритм для n-элементов выполняет n-тактов плюс один такт для вывода информацим на экран, то сложность такого алгоритма всё равно O(N), т.к. бесконечность гораздо больше единицы. Тоже самое касается алгоритмов, которые выполняются за O(2N) или более</li>
    <li>Big-O описывает только скорость роста. Поэтому мы отбрасываем константы при оценке сложности</li>
    <li>Алгоритм, описываемый как O(2N) должен описываться как O(N)</li>
</ul>

<!------------------------------------------------------>
<h3>O(формула_поведения_алгоритма)</h3>
<!------------------------------------------------------>
<pre><code class="bash">
<em>O(0)</em> # ничего не происходит
<em>O(1)</em> # постоянная величина (н-р: размер файлов не зависит на скорость передачи данных если они доставляются на самолете)
<em>O(N)</em> # зависимость прямо пропорциональна (линейная) и зависит от количества передаваемых бит (н-р: чем больше файлов, тем дольше их передавать по сети)
<em>O(N + N) = O(N)</em> # последователность действий - сложение
<em>O(N * N) = O(N<sup>2</sup>)</em> # вложенные действия - умножение
</code></pre>

<!------------------------------------------------------>
<h3>Быстродействие</h3>
<!------------------------------------------------------>
<h4>Рекурсия => Быстродействие: O(N)</h4>
<pre><code class="js">
function pow(x, n) {
    if (n != 1) {
        return x * pow(x, n - 1);
    } else {
        return x;
    }
}
</code></pre>

<h4>Сложение чисел => Быстродействие: O(1)</h4>
<pre><code class="js">
function sum(a, b) {
    return a + b;
}
</code></pre>

<h4>Быстродействие: O(N)</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
let min = 1;
let max = 10;
for(let i=0; i<=100; i++) {
    if (i < min) min = i;
    if (i > max) max = i;
}
</code></pre></div><div class="container-half"><pre><code class="js">
let min = 1;
let max = 10;
for(let i=0; i<=100; i++) {
    if (i < min) min = i;
}
for(let i=0; i<=100; i++) {
    if (i > max) max = i;
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Сложение и умножение</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half">
<b>Быстродействие: O(A + B)</b>
<pre><code class="js">
let arrA = [1,2,3];
let arrB = [1,2,3];
for(let i=0; i<=arrA; i++) {
    console.log(i);
}
for(let i=0; i<=arrB; i++) {
    console.log(i);
}
// Проход по массивам выполняется последовательно
// Выполнение первого цикла не зависит от выполнения второго
// A - длина массива arrA
// B - длина массива arrB
</code></pre></div><div class="container-half">
<b>Быстродействие: O(A * B)</b>
<pre><code class="js">
let arrA = [1,2,3];
let arrB = [1,2,3];
for(let a=0; a<=arrA; a++) {
    for(let b=0; b<=arrB; b++) {
        console.log(a, b);
    }
}
// Выполнить что-то N раз, пока делаешь что-то свое
// Цикл по "B" зависим от цикла по "A"
</code></pre></div></div>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="structure-data">Структуры данных</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-structure-data">

    <ul class="list-point">
        <li><bg-define>Структуры данных</bg-define></li>

        <li><bg-define>Очередь</bg-define></li>
        <li><bg-define>Стек</bg-define></li>
        <li><bg-define>Листья</bg-define></li>
        <li><bg-define>Деревья</bg-define></li>
    </ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="basic-algoritms">Базовые алгоритмы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-basic-algoritms">
    
    <ul class="list-point">
        <li><bg-define></bg-define></li>
    </ul>

</div>




</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
