<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>

	<div class="theme">Парадигмы программирования</div>
    <a href="#paradigms">Парадигмы</a>
    <a href="#paradigms-imper">1. Императивное</a>
    <a href="#paradigms-decl">2. Декларативное</a>
    <a href="#paradigms-func">3. Функциональное</a>
    <a href="#paradigms-oop">4. Объектно-ориентированное</a>
    <a href="#composition">Композиция</a>
    <a href="#currying">Каррирование</a>
    <a href="#ddd">DDD</a>
    <a href="#cqrs">CQRS</a>
    <a href="#event-sourcing">Event Sourcing</a>

    <div class="theme">Паттерны проектирования</div>
    <a href="#patterns">Паттерны проектирования</a>
    <a href="#pattern-singleton"><bg-menu>[1]</bg-menu> «Синглтон»</a>
    <a href="#pattern-builder"><bg-menu>[1]</bg-menu> «Строитель»</a>
    <a href="#pattern-simple-factory"><bg-menu>[1]</bg-menu> «Простая фабрика»</a>
    <a href="#pattern-decorator"><bg-menu>[2]</bg-menu> «Декоратор»</a>
    <a href="#pattern-facade"><bg-menu>[2]</bg-menu> «Фасад»</a>
    <a href="#pattern-observer"><bg-menu>[3]</bg-menu> «Наблюдатель»</a>
    <a href="#pattern-module"><bg-menu>[?]</bg-menu> «Модуль»</a>
    <a href="#pattern-revealing-module"><bg-menu>[?]</bg-menu> «Открытый модуль»</a>

    <div class="theme">Принципы программирования</div>
    <a href="#solid">SOLID</a>
    <a href="#dry">DRY</a>
    <a href="#kiss">KISS</a>
    <a href="#yagni">YAGNI</a>
    <a href="#code-smell">Запахи кода</a>
    <a href="#refactoring">Рефакторинг</a>
    <a href="#code-standart">Стандарты кода</a>

    <div class="theme">Алгоритмы и структуры данных</div>
    <a href="#big-o-notation">Big-O Notation (сложность алгоритмов)</a>
    <a href="#structure-data">Структуры данных</a>
    <a href="#basic-algoritms-sort">Алгоритмы сотрировки</a>

    <div class="theme">Deployment</div>
    <a href="#deployment-ci"><bg-menu>1</bg-menu> Continuous Integration</a>
    <a href="#deployment-cd"><bg-menu>2</bg-menu> Continuous Delivery</a>
    <a href="#deployment-continuous"><bg-menu>3</bg-menu> Continuous Deployment</a>
    <a href="#deployment-software">Software Deployment</a>

    <div class="theme">Тестирование</div>
    <a href="#testing-test">Тестирование</a>
    <a href="#testing-pyramid">Пирамида тестирования</a>
    <a href="#testing-unit"><bg-menu>1</bg-menu> Юнит-тесты</a>
    <a href="#testing-integration"><bg-menu>2</bg-menu> Интеграционные тесты</a>
    <a href="#testing-e2e"><bg-menu>3</bg-menu> E2E-тесты</a>
    <a href="#testing-tdd">TDD</a>
    <a href="#testing-bdd">BDD</a>

    <div class="theme">Методологии разработки</div>
    <a href="#method-dev">Методологии разработки</a>
    <a href="#method-waterfall">Waterfall</a>
    <a href="#method-agile">Agile / Scrum / Kanban</a>
    <a href="#estimation">Эстимация</a>

    <div class="theme">Прочее</div>
    <a href="#web-applications">Виды веб приложений</a>
    <a href="#design">Эволюция веб-дизайна</a>
    <a href="#framework">Фреймворки</a>
    <a href="#mvc">MVC MVP MVVM</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms">Парадигмы программирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms">
<ol class="list-num">
    <li>Императивное (C, C++, Java)</li>
    <li>Декларативное (HTML, SQL)</li>
    <li>Структурное (Pascal, C)</li>
    <li>Функциональное (F#, Lisp, Erlang, Scala)</li>
    <li>Логическое</li>
    <li>Объектно-ориентированное (С#, Java)</li>
    <li>Аспектно-ориентированное</li>
</ol>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-imper">Императивное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-imper">

<ul class="list-point">
    <li><bg-define>Императивное программирование</bg-define> В исходном коде программы записываются инструкции (команды), которые выполняются последовательно</li>
</ul>

<b class="margin-top">Используется</b>
<ol class="list-num">
    <li>Именованные переменные</li>
    <li>Операторы присваивания</li>
    <li>Составные выражения</li>
    <li>Подпрограммы</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает как решить задачу (явное указание всех шагов)</li>
    <li>Изменение состояния (переменных)</li>
    <li>При вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию состояния переменных</li>
</ol>

<pre><code class="js">
function double (arr) {
    let results = []
    for (let i = 0; i < arr.length; i++){
        results.push(arr[i] * 2)
    }
    return results
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-decl">Декларативное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-decl">

<ul class="list-point">
    <li><bg-define>Декларативное программирование</bg-define></li>
</ul>

<b class="margin-top">Не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает что должно быть сделано</li>
    <li>Неизменяемость</li>
    <li>Многие декларативные подходы имеют определённый слой императивных абстракций</li>
    <li>Код является контекстно-независимым - его можно использовать в любой программе без изменений</li>
</ol>

<pre><code class="js">
function double (arr) {
    return arr.map((item) => item * 2)
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-func">Функциональное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-func">

<ul class="list-point">
    <li><bg-define>Функциональное программирование</bg-define> - последовательный вызов набора функций</li>
    <li>Процесс вычисления трактуется как вычисление значений функций в математическом понимании</li>
    <li>Специфические возможности по работе с функциями: передача функций другим функциям в качестве аргументов и возврат функций из других функций</li>
    <li>Предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций</li>
    <li>Описывает математические отношения между данными и целью</li>
    <li>Один из видов декларативного программрования</li>
    <li>Нужно что-то посчитать, но функция которая это считает возвращает не результат, а рецепт для вычисления результата, т.е. возвращает функцию, которая посчитает результат</li>
    <li>Методы для функционального программирования в JavaScript: arr.map, arr.forEach, arr.filter, arr.sort, arr.concat, arr.join, arr.reduce, arr.reduceRight, Object.assign, Object.keys()</li>
</ul>

<b class="margin-top">Что не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>При вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных</li>
    <li>То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций</li>
    <li>Не нужно описывать шаги, нужно определить функцию, выполнить функции последовательно и в результате выполнения набор функций будет получен результат</li>
    <li>Разделение функций и данных</li>
</ol>

<b class="margin-top">Концепции</b>
<ol class="list-num">
    <li><bg-define>Чистые функции</bg-define> (pure functions) - функция, которая при одинаковых аргументах всегда возвращает одни и те же значения и не имеет видимых побочных эффектов (side effects) ввода-вывода и памяти. Зависят только от своих параметров и возвращают только свой результат. Не влияют на состояние программы</li>
    <ul class="list-point">
        <b>Условия</b>
        <li><u>Детерменированная</u> - для одного и того же набора входных значений возвращает одинаковый результат</li>
        <li><u>Без побочных эффектов</u> В императивных языках некоторые функции в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывая их обработчики. Они называются функциями с побочными эффектами</li>
        <li>Для замены циклов в JS можно использовать map и reduce</li>
    </ul>

    <li><bg-define>Функции высшего порядка</bg-define> - функция принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата</li>

    <li><bg-define>Функции первого класса</bg-define> - функция трактуются как объект, то есть может быть передана другим функциям и ее можно вернуть из функций. Так же ее можно присваивать переменным let func = function(){}</li>

    <li><bg-define>Каррирование функций</bg-define> - все функции могут быть от одного аргумента. Преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному</li>

    <li><bg-define>Рекурсия</bg-define> В функциональных языках цикл обычно реализуется в виде рекурсии. Рекурсивные функции вызывают сами себя, позволяя операции выполняться снова и снова</li>

    <li><bg-define>Лямбда-исчисление</bg-define> - механизм «анонимных функций» - callback-функций, которые можно определить прямо в том месте, где они используются, и которые имеют доступ к локальным переменным текущей функции</li>

    <li><bg-define>Иммутабельность</bg-define> - свойство объектов не изменяться (н-р строка. строку нельзя поменять на месте, для изменения нужно создать новую строку). Принцип иммутабельности в ФП должен применяется для другими страктурами данных (списки, словари). Иммутабельный список - список в который нельзя добавить / удалить элемент, можно только итерироваться по ним. Можно создать новый список который содежит все элементы +1, при этом старый остается валадным</li>

    <li><bg-define>Замыкания</bg-define></li>
</ol>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-oop">Объектно-ориентированное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-oop">

<ul class="list-point">
    <li><bg-define>Объектно-ориентированное программирование</bg-define> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования</li>
</ul>

<b class="margin-top">Механизмы</b>
<ol class="list-point">
    <li><bg-define>Инкапсуляция</bg-define> - механизм языка, позволяющий ограничить доступ одних компонентов программы к другим. Группировка свойств и методов в один класс</li>
    <li>Инкапсуляция – отделение и защита внутреннего интерфейса от внешнего</li>
    <li><u>Внутренний интерфейс</u> – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными»</li>
    <li><u>Внешний интерфейс</u> – это свойства и методы, доступные снаружи объекта, их называют «публичными»</li>
    <li>Мы обращаемся с объектами как с единой сущностью, а не как с набором отдельных полей и методов, тем самым скрываем и защищаем реализацию класса. Если клиентский код не знает ничего, кроме публичного интерфейса, он не может зависеть от деталей реализации</li>

    <li><bg-define>Наследование</bg-define> - описание нового класса на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом</li>
    <li>Наследование транзитивно: класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса (Object). Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию</li>
    
    <li><bg-define>Полиморфизм</bg-define> - возможность объектов с одинаковой спецификацией иметь различную реализацию. «Один интерфейс, множество реализаций». Переопеределение методов у дочерних классов. Возможность единообразно обрабатывать объекты с различной реализацией при условии наличия общего интерфейса</li>
    
    <li><bg-define>Абстракция</bg-define> позволяет работать с объектами не вдаваясь в особенности их реализации</li>
    <li>Инкапсуляция помогает реализовать абстракцию</li>
    <li>Абстракция это способ представления объекта в программе</li>
    <li>Абстракция - объекты из окружающиего мира которые мы хотим описать</li>
</ol>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="composition">Композиция</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-composition">

<ul class="list-point margin-top">
    <li><bg-define>Композиция и Агрегация</bg-define> - расширение функционала класса за счет "внедрения" других классов</li>
    <li>Об агрегировании также часто говорят как об «отношении принадлежности» по принципу «у машины есть корпус, колёса и двигатель»</li>

    <li><bg-define>Агрегация (агрегирование по ссылке)</bg-define> - отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое - нет</li>

    <li><bg-define>Композиция (агрегирование по значению)</bg-define> - более строгий вариант агрегирования, когда включаемый объект может существовать только как часть класса. Если класс будет уничтожен, то и включённый объект тоже будет уничтожен. Объект не может выйти за рамки своего класса. Объект будет создаваться внутри класса при создании класса и будет уничтожаться перед уничтожением родительского класса</li>

    <li><bg-define>Функциональная композиция</bg-define> - передача результа вызова одной функции в качестве аргумента другой функции</li>
</ul>

<pre><code class="light">
<img src="img/js/composition.png"></code></pre>

<ul class="list-point">
    <li><em>Агрегация</em>: <bg-code>профессора - факультеты</bg-code>, профессора остаются жить после разрушения факультета</li>
    <li><em>Композиция</em>: <bg-code>университет - факультеты</bg-code>, факультеты без университета уничтожаются</li>
</ul>

<h4>Наследование и композиция</h4>
<div class="container-flex"><div class="container-half">
<ul class="list-point">
    <li><b>Наследование</b> - когда класс-наследник имеет все поля и методы родительского класса, и, как правило, добавляет какой-то новый функционал или/и поля</li>
    <li><b>Наследование предполагает</b> принадлежность к какой-то общности (похожесть). Наследуются атрибуты, т.е. возможности, другого класса, при этом объектов непосредственно родительского класса не создается</li>
    <li><b>Минус наследования</b> влияние родительского класса на дочерние</li>
</ul>
</div><div class="container-half">
<ul class="list-point">
    <li><b>Ассоциация (частные случаи: Композиция и Агрегация)</b> – когда один класс включает в себя другой класс в качестве одного из полей</li>
    <li><b>Композиция предполагает</b> формирование целого из частей. При композиции класс-агрегатор создает объекты других классов</li>
</ul>
</div></div>

<h4>Dependency Injection</h4>
<pre><code class="js">
function makeCoffee(coffee) {}
function produceCoffee() {
    return { iCoffee:true }
}
function barista(makeCoffee, produceCoffee) {
    let coffee = makeCoffee(produceCoffee());
}
barista(makeCoffee, produceCoffee);
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="currying">Каррирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-currying">

<ul class="list-point">
    <li><bg-define>Каррирование / Карринг (Currying)</bg-define> - в функциональном программирование - это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму <u>замыканий</u>, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат.
    <li>При каррировании число вложенных функций равно числу аргументов исходной функции. Каждая из этих функций ожидает собственный аргумент. Если функция аргументов не принимает, или принимает лишь один аргумент, то каррировать её нельзя</li>

    <li><bg-define>Частичное применение функций (Partial Function Application)</bg-define> - функцию преобразуют в другую функцию, обладающую меньшим числом аргументов. Некоторые аргументы такой функции оказываются зафиксированными (для них задаются значения по умолчанию</li>

    <li>Каррирование и преобразования функций реализуются в JavaScript благодаря замыканиям и тому, что функции в JS являются объектами первого класса (их можно передавать в качестве аргументов другим функциям, возвращать из них, присваивать переменным)</li>
</ul>

<!------------------------------------------------------>
<h3>Каррирование</h3>
<!------------------------------------------------------>
<h4>Пример 1</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
// исходная функция
function multiply(a, b, c) {
    return a * b * c;
}
multiply(1,2,3); // 6
<br><br><br><br><br><br><br><br>
</code></pre></div><div class="container-half"><pre><code class="js">
// каррирование
function multiply(a) {
    return (b) => {
        return (c) => {
            return a * b * c
        }
    }
}
log(multiply(1)(2)(3)) // 6

//const mul1 = multiply(1);
//const mul2 = mul1(2);
//const result = mul2(3);
//log(result); // 6
</code></pre></div></div>

<h4>Пример 2</h4>
<pre><code class="js">
function add(x){
    return function() {
        return x + y;
    }
}
inc = add(1);
console.log(inc(15));   // 16
console.log(add(8)(7)); // 15
</code></pre>

<!------------------------------------------------------>
<h3>Частичное применение функций</h3>
<!------------------------------------------------------>
<pre><code class="js">
function volume(l) {
    return (w, h) => {
        return l * w * h
    }
}
</code></pre>

<div class="container-flex"><div class="container-half"><pre><code class="js">
// вариант использования 1
const hV = volume(70);
hV(203,142);
hV(220,122);
hV(120,123);
</code></pre></div><div class="container-half"><pre><code class="js">
// вариант использования 2
volume(70)(90,30);
volume(70)(390,320);
volume(70)(940,340);
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Частичная функция через bind</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Вызов <u>bind</u> позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз</li>
    <li>Если в bind указаны аргументы - они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове</li>
</ul>

<pre><code class="html">
<a href="js.html#methods-this-bind" target="_blank">[Local] bind()</a>
</code></pre>

<pre><code class="js">
function mul(a, b) {
    return a * b;
};

// double умножает только на два
var double = mul.bind(null, 2); // контекст фиксируем null, он не используется

console.log( double(3) ); // = mul(2, 3) = 6
console.log( double(4) ); // = mul(2, 4) = 8
console.log( double(5) ); // = mul(2, 5) = 10
</code></pre>

<ul class="list-point">
    <li>При вызове double будет передавать свои аргументы исходной функции mul после тех, которые указаны в bind, то есть в данном случае после зафиксированного первого аргумента 2</li>
    <li>"double" является «частичной функцией» (partial function) от mul</li>
    <li>При помощи bind мы можем получить из функции её «частный вариант» как самостоятельную функцию</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ddd">DDD</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-ddd">

<ul class="list-point">
    <li><bg-define>Domain-Driven Design, DDD (Предметно-ориентированное проектирование)</bg-define> - набор принципов и схем, направленных на создание оптимальных систем объектов. Сводится к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом</li>
    <li>DDD - набор правил, которые позволяют принимать правильные проектные решения. Данный подход позволяет значительно ускорить процесс проектирования программного обеспечения в незнакомой предметной области</li>
    <li>Подход DDD особо полезен в ситуациях, когда разработчик не является специалистом в области разрабатываемого продукта. К примеру: программист не может знать все области, в которых требуется создать ПО, но с помощью правильного представления структуры, посредством проблемно-ориентированного подхода, может без труда спроектировать приложение, основываясь на ключевых моментах и знаниях рабочей области</li>
    <li>Приложение должно максимально рассказыать какую предметную область решаем</li>
</ul>

<h4>Определения</h4>
<ul class="list-point">
    <li><u>Область (domain)</u> - предметная область, к которой применяется разрабатываемое ПО</li>
    <li><u>Модель (model)</u> - описывает отдельные аспекты области и может быть использована для решения проблемы</li>
    <li><u>Язык описания</u> - используется для единого стиля описания домена и модели</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="cqrs">CQRS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-cqrs">

<ul class="list-point">
    <li><bg-define>Command-Query Separation (CQS) или Command-Query Responsibility Segregation (CQRS)</bg-define> - принцип императивного программирования, который гласит, что метод должен быть либо командой, выполняющей какое-то действие, либо запросом, возвращающим данные, но не одновременно. Другими словами, задавание вопроса не должно менять ответ. Более формально, возвращать значение можно только чистым, не имеющим побочных эффектов методам. Следует отметить, что строгое соблюдение этого принципа делает невозможным отслеживание количества вызовов запросов</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="event-sourcing">Event Sourcing</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-event-sourcing">

<ul class="list-point">
    <li><bg-define>Event Sourcing</bg-define> - подход хранения данных, при котором вместо конечного результата (финальное состояние) храниться череда записей о событиях происшедших с некоторой сущностью</li>
    <li><bg-define>Event Store</bg-define> - хранилище в котром запоминаем все действия пользователей в той очередности в которой они пришли</li>
    <li><bg-define>Snapshot</bg-define> - объединяет всю информацию до snapshot</li>
</ul>

<img src="img/js/event-sourcing1.png">
<img src="img/js/event-sourcing2.png" class="margin-top">

<h4>Механизмы</h4>
<ul class="list-point">
    <li>Каждому событию дается имя, которое определяет его значение, т.е. присутствует семантика. Есть огромная разница между «Событие 1» и «Корабль Отплыл»</li>
    <li>Нет ограничений на кол-во событий для сущности. Соответственно новые события могут отражать, как и новые виды совершенных действий, так и расширять уже существующие, скажем, добавили новое свойство в его 2-ой версии</li>
    <li>Произошедшие события неизменны («immutable»)</li>
</ul>

</div>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Методологии разработки</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-dev">Методологии разработки</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-dev">

<ul class="list-point">
    <li><bg-define>Методология разработки</bg-define> - организация труда, включающая идеологические принципы, план, контроль над процессами, подход к сотрудникам</li>
</ul>

<ol class="list-num">
    <li><u>Waterfall</u> - традиционный подход</li>
    <li><u>RUP (Rational Unified Process)</u> - рациональный (итеративный подход). ПО выходит с уменьшенной функциональностью, чтобы занять нишу на рынке и противостоять конкурентам, после чего дорабатывается</li>
    <li><u>Agile</u> - общая методология гибкой разработки</li>
    <li><u>Crystal Clear</u> - подход с уравниванием разработчиков в коллективе. Каждая команда является набором людей с разным уровнем знаний, разными умениями и опытом</li>
    <li><u>Spiral</u> - спиральный метод. Раннее выявление и уменьшение проектных рисков</li>
    <li><u>DSDM (Dynamic Systems Development Model)</u> - динамическая модель. При планировании в самом начале невозможно понимать всех тонкостей разработки, поэтому весь процесс — исследовательская работа</li>
    <li><u>FDD (Feature Driven Development)</u> - методология, рассматривающая будущие изменения. Процесс для обеспечения масштабируемости и повторяемости, при этом поощряющий творчество и инновации</li>
    <li><u>JAD (Joint Application Development)</u> - ориентированный на пользователя подход. Максимальная занятость в разработке конечного пользователя</li>
    <li><u>RAD (Rapid Application Development)</u> - модель быстрой разработки</li>
    <li><u>Scrum</u> - концепция работы в условиях сорванных сроков и идеологического кризиса</li>
    <li><u>XP (Extreme Programming)</u> - экстремальная разработка в динамической среде</li>
    <li><u>LD (Lean Development)</u> - метод, предполагающий бережное отношение ко всем участникам процесса</li>
</ol>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-waterfall">Waterfall</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-waterfall">

<ul class="list-point">
    <li><bg-define>Waterfall Model (каскадная модель)</bg-define> - модель процесса разработки программного обеспечения, в которой процесс разработки выглядит как поток, последовательно проходящий фазы.</li>
    <li>Весь процесс является жестким и линейным, имеет четкие цели для каждого этапа, новая фаза начинается по завершению предыдущей, нет возврата назад</li>
</ul>

<h4>Шаги</h4>
<ol class="list-num">
    <li><u>Требования</u> - список требований к ПО. В первую очередь, анализируются требования и пожелания заказчика, затем это проецируется на возможности компании и состояние рынка. В результате получается некий документ, где описывается, что должно делать ПО, но не как и с помощью каких инструментов</li>
    <li><u>Проектирование</u> -  согласовывается логика работы ПО. Здесь всё ещё не принимаются конкретные решения по реализации, но уже описывается функционирование всех разделов приложения. На выходе разработчики уже представляют, сколько по времени и кадровому составу может занять проект. Создаются документы, подробно описывающие для программистов способ и план реализации указанных требований</li>
    <li><u>Конструирование</u> (также «реализация» либо «кодирование») - речь идёт о конкретных инструментах для реализации идей: согласовываются требования к дизайну, языки программирования, уровни данных, сервисы и т. д. Формируется внешний облик готового продукта</li>
    <li><u>Воплощение</u> - исполнительский этап, на который, как правило, приходится большая часть разработки. Если классическая модель допускает свободное взаимодействие с предыдущими этапами, то на практике допускается лишь внесение незначительных правок в «Конструирование»</li>
    <li><u>Тестирование и отладка</u> (также «верификация»)</li>
    <li><u>Инсталляция</u></li>
    <li><u>Поддержка</u></li>
</ol>

<h4>Преимущества</h4>
<ul class="list-point">
    <li><u>Устойчива к изменению кадрового состава</u> Благодаря подробному документированию смена работников практически не влияет на сроки исполнения проекта</li>
    <li><u>Дисциплина</u> Модель заставляет разработчиков, вовлечённых в проект быть дисциплинированными, оставаться в рамках намеченного плана. При необходимости в общей модели добавляется орган управления, ответственный за принятие решений, исполнители же обязаны работать в рамках системы</li>
    <li><u>Гибкость на ранних этапах</u> Изменения в первых трёх фазах могут быть сделаны немедленно и с минимальными усилиями, поскольку они не подкреплены кодом</li>
    <li><u>Ориентация на сроки и финансы</u> Благодаря тому, что каждый этап полностью очерчивает контур будущего ПО, все разработчики понимают свою роль, границы работы и сроки исполнения. Это позволяет оперировать реальными цифрами перед заказчиком</li>
</ul>

<h4>Недостатки</h4>
<ul class="list-point">
    <li><u>Неадаптивная структура ПО</u> На первых этапах модель водопада может быть гибкой, но если на фазе тестирования выявляются проблемы в общей структуре – это влечёт за собой последствия в виде сорванных сроков и даже отказов заказчика. Таким образом, возрастает роль руководителей и ответственных разработчиков, с уровнем компетентности которых в любой компании часто бывают проблемы</li>
    <li><u>Игнорирует конечного пользователя</u> Чем ниже продвигается процесс в водопаде, тем меньше в нём роль заказчика. Внесение каких-либо изменений в функциональность ПО запускает всю цепочку этапов заново, поэтому продукты полученные по каскадной модели далеки от ориентации на массового пользователя</li>
    <li><u>Позднее тестирование</u> Более гибкие методологии используют тестирование в качестве фундаментальной операции, происходящей непрерывно. Waterfall же допускает низкую квалификацию сотрудников на каждом этапе и плохое качество исполнения, ведь при запоздалом тестировании проблемы невозможно решить фундаментально</li>
</ul>

<h4>Итого</h4>
<ol class="list-num">
    <span>Каскадная методология – хорошее решение точки зрения сроков и отчётности, но очень слабое в плане качества. Поэтому сегодня её рекомендуется использовать только в трёх случаях:</span>
    <li>При ориентации ПО на заказчика, требующего прозрачность работ и исполнение в назначенные сроки</li>
    <li>При наличии в штате руководителей соответствующей квалификации</li>
    <li>При исполнении проекта, не имеющего конкуренции на рынке</li>
</ol>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-agile">Agile / Scrum / Kanban</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-agile">

<!------------------------------------------------------>
<h3>Agile</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Agile (agile software development)</bg-define> методология - семейство «гибких» подходов к разработке ПО, основынная на итеративном проходе по scope задач в условиях работы разных специалистов с целью выпуска работоспособного продукта</li>

    <li>Agile предполагает, что при реализации проекта не нужно опираться только на заранее созданные подробные планы. Важно ориентироваться на постоянно меняющиеся условия внешней и внутренней среды и учитывать обратную связь от заказчиков и пользователей. Это поощряет разработчиков и инженеров экспериментировать и искать новые решения, не ограничивая себя жесткими рамками и стандартами</li>

    <li>К отдельным agile-подходам относятся <u>scrum</u> и <u>kanban</u></li>

    <li><bg-define>Product Owner (PO)</bg-define> - Product Manager в терминологии Scrum</li>
    <li><bg-define>Product Manager</bg-define> - отвечает за продукт. Несет ответственность за рождение новых продуктов, их подготовленность к выходу на рынок, ценовые характеристики, его целевую аудиторию и прочие характеристики</li>
    <li><bg-define>Project Manager (PM)</bg-define> - отвечает за процесс. Координатор. Отвечает за соблюдение сроков и мониторинг всех зависимостей между командами</li>

    <li><bg-define>Program Manager</bg-define></li>
    <li><bg-define>Product Lead / Product Director / Group Product Manager</bg-define> - начальник над несколькими PM. Отвечает за несколько продуктов одной ветки и определяет цели на более высоком уровне</li>
</ul>

<h4>Agile-манифест</h4>
<ul class="list-point">
    <li>Люди и взаимодействие важнее процессов и инструментов</li>
    <li>Работающий продукт важнее исчерпывающей документации</li>
    <li>Сотрудничество с заказчиком важнее согласования условий контракта. Устные договоренности между сотрудниками, между заказчиком и исполнителем важнее всего, что отражено в планах, договорах и техническом задании</li>
    <li>Готовность к изменениям важнее следования первоначальному плану </li>
</ul>


<pre><code class="html">
<a href="http://agilemanifesto.org/iso/ru/principles.html" target="_blank">[agilemanifesto] Принципы</a>
</code></pre>

<!------------------------------------------------------>
<h3>Scrum</h3>
<!------------------------------------------------------>
<pre><code class="html">
<a href="https://www.youtube.com/watch?v=cDvZaXzQezs" target="_blank">[YouTube] Agile и Scrum на пальцах</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Scrum</bg-define> «подход структуры». Гибкая методология по разработке ПО. Команда из 5-9 разработчиков</li>
    <li>Scrum-подход делит рабочий процесс на равные <u>спринты</u> – обычно это периоды от недели до месяца, в зависимости от проекта и команды. Перед спринтом формулируются задачи на данный спринт, в конце – обсуждаются  результаты, а команда начинает новый спринт. Спринты очень удобно сравнивать между собой, что позволяет управлять эффективностью работы</li>
    <li><b>Принципы:</b><br> 
        - не стремитесь сразу получить сложный продукт<br>
        - минимально жизнеспособный продукт можно показать пользователям и определить какие доработки нужны а какие нет</li>
    <li><b>Плюсы:</b><br> 
    - детальное задание необязательно<br>
    - разработка под контролем<br> 
    - цена оказывается ниже ввиду рисков закладываемых подрядчиком в фиксированную стоимость</li>
</ul>

<h4>Команда</h4>
<ol class="list-num">
    <li>Универсальная команда специалистов</li>
    <li><bg-define>Product Owner</bg-define> - Product Manager в терминологии Scrum. Соединяет команду с заказчиком. Человек, который управляет созданием продукта и отвечает за то, что получится в результате</li>
    <li><bg-define>Scrum Master (бизнес-аналитик)</bg-define> - помогает Product Owner организовать бизнес-процесс: проводит общие собрания, решает бытовые проблемы, мотивирует команду и следит за соблюдением Scrum-подхода. Переводит задачи написанные обычным язвком в задачи понятные разработчикам по средствам <u>Backlog</u></li>
</ol>

<h4>Backlog</h4>
<ol class="list-num">
    <li><bg-define>Backlog</bg-define> - приоритезированный список задач, куда записываются пожелания заказчика. Создают Scrum Master и Product Owner</li>
    <ol class="list-num">
        <li><u>Эпик</u> - большая часть функционала которая может быть завершена в рамках разработки (н-р: разработка личного кабинета пользователя). Эпики делятся на Сторисы</li>
        <li><u>Стори/Сторисы</u> - более мелкая часть функционала которая еще не может случить для задач разработки (н-р: кабинет пользователя может состоять из функционала по авторизации, по рассылке уведомлений и т.д.). Сторис отвечает на вопрос "Я как пользователь хочу ... (н-р: иметь возможность делать посты)"</li>
        <li><u>Таски/Задачи</u> - идут к разработчикам</li>
    </ol>
</ol>

<h4>Собрания</h4>
<ol class="list-num">
    <li><bg-define>Planning Poker / Scrum Poker</bg-define> - разбиение Сторис на задачи и оценка сложности задач в Story Points</li>
    <ul class="list-point">
        <li><bg-define>Story Points</bg-define> - оценивание с точки зрения сложности. Определяются эталонные задачи (кто за сколько врмени выполнял задачу). Отталкиваясь от эталонный оцениваются все остальные Сторис</li>
        <li>У всех на собрании есть карты на которых выставолены числа, соответствующие кол-ву Story Points. Для более честной оценки все взакрытую при объявлении задачи выбирают свое количество Story Points и после показывают что поставили</li>
    </ul>

    <li>Сессия временной оценки задач. Назначаются ответственные за задачи. По итогу есть список задач который помещается в <u>список TODO</u> - задач на разработку. Задачи оцененные, приориетизированные, есть назначенные разработчики. После этого спринт считается запущенным</li>

    <li><bg-define>Daily Scrum Meeting/Stand-Up</bg-define> - 15 минут ежедневно проводятся встречи проектной команды, где контролируется ход работ. Каждый участник команды рассказывает про свой текущий статус: - Что делал вчера? - Что буду делать сегодня? - Какие проблемы есть?</li>
</ol>

<h4>Cпринт</h4>
<ul class="list-point">
    <li><u>Спринт</u> - участок времени за который разработчики выполняют фиксированый набор задач, оцененных на <u>Planning Poker</u> и на оценочной сессии. В конце спринта всегда должен быть работоспособный кусок продукта либо сам продукт, который можно показать заказчику</li>
    <li>Начало: после Planning Poker и Сессии оценки</li>
    <li>Длина спринтов одинаковая и обычно выбираются кратными неделям: 1,2,4 недели</li>
    <li>В рамках спринта задача меняется свои статусы. Изначально после оценки задчи попадают в статус TODO</li>
    <li>По итогу спринта - продукт который можно показать клиенту. Каждый разработчки презентует те задачи, которые он сделал. Заказчик видим конкретный результат, вносит коррективы</li>
</ul>

<h4>Доска</h4>
<ol class="list-num">
    <li><bg-code>STORY / BACKLOG</bg-code> </li>
    <li><bg-code>TODO</bg-code> # после оценки</li>
    <li><bg-code>REJECTED</bg-code> # от тестировщика в случае нахождения багов</li>
    <li><bg-code>IN PROGRESS</bg-code> разработчик берет в разработку</li>
    <li><bg-code>REVIEW / TESTING / TO VERIFY</bg-code> # разработчик закончил</li>
    <li><bg-code>DONE</bg-code> переводит тестировщик</li>
</ol>

<ul class="list-point">
    <li>Разработчик берет задачу из REJECTED, переносит в IN PROGRESS и старается в приоритетном прядке ее закрыть</li>
    <Когда все задачи, относящиеся к Сторис завершены, считается что Стирис закрыта></li>
</ul>

<h4>Ретроспектива</h4>
<ul class="list-point">
    <li>После review ретроспектива - собрание на которым команда отвечает на вопросы <br>
    - "Что было сделано хорошо в Спринте"<br>
    - "Что мы делали плохо в спринте"<br>
    - "Что нужно сделать чтобы в следующем спринте работать лучше"</li>
    <li>Каждый в команде по очереди высказывается и предлагает варианты улучения процесса</li>
    <li>К концу ретроспективы список элементов на улучшение, который к концу следующего спринта смотрится и проверяется что улучшили, а что нет</li>
    <li>Оценивается эффуктивность команды. Берутся стори которые были закрыты и суммируются их Story Points. Если команда закрыра 30 Story Points, значит в следующем спринте можно запланировать 30 Story Points</li>
</ul>

<!------------------------------------------------------>
<h3>Kanban</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Kanban</bg-define> - «подход баланса». Гибкий метод управления проектами, целью которого является повышение производительности труда в командах</li>
    <li>Главная идея Kanban - визуализация рабочего процесса. Она заключается в создании физической панели, на которой можно наглядно отмечать прогресс</li>

    <li>Задача – сбалансировать разных специалистов внутри команды и избежать ситуации, когда дизайнеры работают сутками, а разработчики жалуются на отсутствие новых задач</li>
    <li>Вся команда едина – в kanban нет ролей владельца продукта и scrum-мастера. Бизнес-процесс делится не на универсальные спринты, а на стадии выполнения конкретных задач: «Планируется», «Разрабатывается», «Тестируется», «Завершено» и др.</li>
    <li>Главный показатель эффективности в kanban – это среднее время прохождения задачи по доске. Задача прошла быстро – команда работала продуктивно и слаженно. Задача затянулась – надо думать, на каком этапе и почему возникли задержки и чью работу надо оптимизировать</li>
    <li>Для визуализации agile-подходов используют доски: физические и электронные. Они позволяют сделать рабочий процесс открытым и понятным для всех специалистов, что важно, когда у команды нет одного формального руководителя</li>

    <li>В основе концепции лежат «спринты»</li>

    <li><bg-define>Спринт</bg-define> - короткая итерация, строго ограниченная по времени (обычно 2−4 недели). В это время минимизируется длительность совещаний, но увеличивается их частота (они называются «схватками»). Благодаря этому контроль за выполнением становится более гибким, а разработчики быстрее реагируют на возникающие проблемы. Традиционное планирование отходит на второй план, его место занимает журнал спринтов</li>
</ul>
</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="estimation">Эстимация</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-estimation">

<ul class="list-point">
    <li>Эстимация - оценки сроков и стоимости проекта</li>
</ul>

<h4>1. Экспертная оценка (Expert Judgement)</h4>
<ul class="list-point">
    <li>Формирование оценки с привлечением экспертов в данной требуемой области</li>
    <li>Эксперты выдвигают свои предположения по поводу оценки (сроков или стоимости). После этого можно усреднить все предложения, а можно постараться прийти к единому решению в ходе дискуссии</li>
</ul>

<h4>2. Метод оценки по 3 точкам (Three Point Estimation)</h4>
<ul class="list-point">
    <li>Сначала определяются <u>оптимистичная (O = Optimistic)</u>, <u>пессимистичная (P = Pessimistic)</u> и <u>реалистичная\средняя (M = Middle)</u> оценки</li>
    <li>Значения <u>P, M и O</u> определяются экспертно (в часах, днях, $). Для этого задаются вопросы типа: <br> «сколько времени займет проект, если все пойдет хорошо?», <br> «каким может быть самый негативный сценарий и сколько на него потребуется времени\усилий?» и т.д.</li>
    <li>Далее полученные значения P, M и O подставляются в формулу: <u>(O + 4 M + P) / 6</u></li>
    <li>Результат расчета дает усредненную оценку. Такая формула позволяет с одной стороны учесть возможные позитивные и негативные сценарии, а с другой – «сгладить» их влияние и получить более реальное значение оценки</li>
</ul>

<h4>3. Стоимость качества (Cost of Quality)</h4>
<ul class="list-point">
    <li>Сначала оценивается время / бюджет только на разработку функционала, без учета ошибок и проблем, как если бы у нас сразу получалось идеальное ПО без дефектов. А далее оценивается сколько дополнительного времени и бюджета потребуется на работу с ошибками и проблемами в реальности, чтобы приблизить ПО к тому самому «идеальному» состоянию</li>
    <li>При оценке затрат на обеспечение качества ПО можно проанализировать и учесть такие области:
    <ul class="list-point">
        <li>расходы на активности по предотвращению дефектов</li>
        <li>стоимость тестирования</li>
        <li>исправление внутренних ошибок</li>
        <li>исправление внешних проблем по интеграции</li>
        <li>затраты на установку и настройку ПО с учетом реальной среды и данных</li>
    </ul>
    </li>
</ul>

<h4>4. Оценка по аналогиям (Analogous Estimation)</h4>
<ul class="list-point">
    <li>Можно опираться на прошлый опыт решения подобных задач или проектов</li>
    <li>Чтобы найти знакомые или похожие на предыдущий опыт задачи можно сделать декомпозицию</li>
</ul>

<h4>5. Оценка по параметрам и моделирование (Parametric Model)</h4>
<ul class="list-point">
    <li>Один из самых точных и гибких методов оценки. Его суть в том, чтобы построить некую параметризированную модель-прогноз взяв за основу прошлый опыт, имеющиеся данные и метрики, статистику</li>
    <li>Фактически строится специальная математическая модель, которая позволяет отслеживать как меняется итоговая оценка в зависимости от исходных параметров</li>
</ul>

<h4>6. Оценка от частного к общему (Bottom-up Estimation)</h4>
<ul class="list-point">
    <li>Метод похож на экспертную оценку, только в данном случае прогноз делается не для всего проекта в целом, а отдельно для составляющих его задач. Как это выглядит: мы собираем экспертное мнение, например, у специалистов по анализу, разработке, тестированию, поддержке ПО. Суммируем их оценки вместе, добавляем к ним затраты времени на взаимодействие и формируем общий прогноз</li>
    <li>Другими словами, мы собираем оценку по частям, узнавая сколько необходимо времени каждому из участников процесса разработки ПО и сводим все воедино с учетом дополнительных рисков</li>
</ul>
</div>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Принципы программирования</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="solid">SOLID</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-solid">
<ul class="list-point">
    <li><bg-define>SOLID</bg-define> (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency inversion) - пять основных принципов ООП</li>
    <li>При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени</li>
    <li><b>Цель принципов</b>: способствуют изменениям; легко понимаемы; повторно используемы</li>
</ul>

<h4>Принципы</h4>
<ul class="list-point">
    <li><bg-define>[S] SRP</bg-define> (The Single Responsibility Principle. Принцип единственной ответственности)</li>
    <li>Каждый класс выполняет лишь одну задачу/ответственность</li>

    <li class="margin-top"><bg-define>[O] OCP</bg-define> (The Open Closed Principle. Принцип открытости/закрытости)</li>
    <li>Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации</li>
    <li>От класса можно наследоваться и расширить его функциональность, но нет прямой возможности менять функциональность базового класса</li>

    <li class="margin-top"><bg-define>[L] LSP</bg-define> (The Liskov Substitution Principle. Принцип подстановки Барбары Лисков)</li>
    <li>Если гарантируется функциональность для базового класса, то гарантируется функциональность для всех его потомков (поведение программы не изменится)</li>
    <li>Поведение в методах-наследниках менять нельзя</li>
    <li>Наследующий класс должен дополнять, а не изменять базовый и не должен противоречить поведению, заданному базовым классом</li>

    <li class="margin-top"><bg-define>[I] ISP</bg-define> (The Interface Segregation Principle. Принцип разделения интерфейса)</li>
    <li>Абстракция (API или класс) должна быть сгруппирована в мелкие единицы и содержать только необходимые методы, давая возможность использовать только то, что необходимо. При необходимости разделить функциональность на несколько классов. При изменении методов интерфейса не должны меняться программные сущности, которые этот метод не используют</li>
    <li>Программные сущности не должны зависеть от методов, которые они не используют</li>

    <li class="margin-top"><bg-define>[D] DIP</bg-define> (The Dependency Inversion Principle. Принцип инверсии зависимостей)</li>
    <li>Зависимость кода должна строиться от абстракции, а не от класса</li>
    <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций</li>
    <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций</li>
    <li>Зависимость на Абстракциях. Нет зависимости на что-то конкретное</li>
</ul>

<h4>Когда следует применять</h4>
<ul class="list-point">
    <li>Жесткость - трудно вносить изменнея в код. Одно изменение вносит изменение в другие модули</li>
    <li>Хрупкость - свойство программы повреждаться во многих местах при внесении одного изменения</li>
    <li>Ненужная сложность - содержание элементов не используемых в данный момент</li>
    <li>Ненужные повторения - проблема дублирования кода</li>
    <li>Непрозрачность - трудность кода для понимания</li>
</ul>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="dry">DRY</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-dry">
<ul class="list-point">
    <li><bg-define>DRY</bg-define> (Don’t Repeat Yourself. Не повторяйся) - нацелен на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования</li>
    <li>Формулируется как: «Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы»</li>
    <li>Когда принцип DRY применяется успешно, изменение единственного элемента системы не требует внесения изменений в другие, логически не связанные элементы. Те элементы, которые логически связаны, изменяются предсказуемо и единообразно</li>
    <li>Нарушения принципа <u>DRY</u> называют <u>WET - «Write Everything Twice»</u> (Пиши всё по два раза) или <u>«We enjoy typing»</u> (Нам нравится печатать)</li>
</ul>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="kiss">KISS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-kiss">
<ul class="list-point">
    <li><bg-define>KISS</bg-define> («Keep it simple, stupid») - принцип утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются</li>
    <li>Принцип, запрещающий использование более сложных средств, чем необходимо</li>
</ul>

<h4>Принципы</h4>
<ul class="list-point">
    <li>Разбивайте задачу на множество более маленьких задач, каждая задача должна решаться одним или парой классов</li>
    <li>Сохраняйте ваши классы/методы маленькими. Каждый метод должен состоять не более чем из 30-40 строк. Каждый метод должен решать одну маленькую задачу, а не множество случаев</li>
</ul>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="yagni">YAGNI</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-yagni">
<ul class="list-point">
    <li><bg-define>YAGNI</bg-define> («You aren't gonna need it». «Вам это не понадобится») - процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, то есть отказ добавления функциональности, в которой нет непосредственной надобности</li>
</ul>

<h4>Последствия написание кода, который не нужно прямо сейчас</h4>
<ul class="list-point">
    <li>Тратится время на добавление, тестирование и улучшение необходимой функциональности</li>
    <li>Новые функции должны быть отлажены, документированы и сопровождаться</li>
    <li>Новая функциональность ограничивает то, что может быть сделано в будущем, - ненужные новые функции могут впоследствии помешать добавить новые нужные</li>
    <li>Пока новые функции действительно не нужны, трудно полностью предугадать, что они должны делать, и протестировать их. Если новые функции тщательно не протестированы, они могут неправильно работать, когда впоследствии понадобятся</li>
    <li>Это приводит к тому, что программное обеспечение становится более сложным</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="code-smell">Запахи кода (Code Smell)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-code-smell">
<ul class="list-point">
    <li><bg-define>Code Smell (Запахи кода)</bg-define> - код с признаками (запахами) проблем в системе</li>
    <li>Запахи кода - ключевые признаки необходимости рефакторинга</li>
    <li>Запахи кода - это не набор чётких правил, а описание мест, на которые нужно обращать внимание при рефакторинге</li>
</ul>

<h4>Общие запахи объектно-ориентированного кода</h4>
<ol class="list-num">
    <li><bg-code>Дублирование кода</bg-code> - использование одинаковых структур кода в нескольких местах</li>
    <li><bg-code>Длинный метод</bg-code></li>
    <li><bg-code>Большой класс</bg-code></li>
    <li><bg-code>Длинный список параметров</bg-code> - использование объектов позволяет, в случае изменения передаваемых данных, модифицировать только сам объект</li>
    <li><bg-code>Расходящиеся модификации</bg-code> - проблема возникает, когда при модификации в системе невозможно выделить определённое место, которое нужно изменить</li>
    <li><bg-code>Стрельба дробью</bg-code> - при выполнении любых модификаций приходится вносить множество мелких изменений в большое число классов</li>
    <li><bg-code>Завистливые функции</bg-code> - метод обращается к данным другого объекта чаще, чем к собственным данным</li>
    <li><bg-code>Группы данных</bg-code> - группы данных, встречающихся совместно, нужно превращать в самостоятельный класс</li>
    <li><bg-code>Одержимость элементарными типами</bg-code> - Проблема связана с использованием элементарных типов вместо маленьких объектов для небольших задач, таких как валюта, диапазоны, специальные строки для телефонных номеров и т.д.</li>
    <li><bg-code>Операторы типа switch</bg-code> - часто один и тот же блок switch оказывается разбросанным по разным местам программы. При добавлении в переключатель нового варианта приходится искать все эти блоки switch и модифицировать их</li>
    <li><bg-code>Параллельные иерархии наследования</bg-code> - всякий раз при порождении подкласса одного из классов приходится создавать подкласс другого класса</li>
    <li><bg-code>Ленивый класс</bg-code> - класс, затраты на существование которого не окупаются выполняемыми им функциями, должен быть ликвидирован</li>
    <li><bg-code>Теоретическая общность</bg-code> - на определённом этапе существования программы обеспечивается набор механизмов, который, возможно, потребуется для некоторой будущей функциональности. Программу становится труднее понимать и сопровождать</li>
    <li><bg-code>Временное поле</bg-code> поле, которое нужно объекту только при определённых обстоятельствах. Такое положение вещей трудно для понимания, так как ожидается, что объекту нужны все его поля</li>
    <li><bg-code>Цепочка вызовов</bg-code> появляется тогда, когда клиент запрашивает у одного объекта другой объект, другой объект запрашивает ещё один объект и т. д. Такие последовательности вызовов означают, что клиент связан с навигацией по структуре классов. Любые изменения промежуточных связей означают необходимость модификации клиента</li>
    <li><bg-code>Посредник</bg-code> - чрезмерное использование делегирования может привести к появлению классов, у которых большинство методов состоит только из вызова метода другого класса</li>
    <li><bg-code>Неуместная близость</bg-code> возникает тогда, когда классы чаще, чем следовало бы, погружены в закрытые части друг друга</li>
    <li><bg-code>Альтернативные классы с разными интерфейсами</bg-code> - два класса, в которых часть функциональности общая, но методы, реализующие её, имеют разные параметры</li>
    <li><bg-code>Неполнота библиотечного класса</bg-code> Библиотеки через некоторое время перестают удовлетворять требованиям пользователей. Естественное решение — поменять кое-что в библиотеках, но библиотечные классы не изменять</li>
    <li><bg-code>Классы данных</bg-code> - это классы, которые содержат только поля и методы для доступа к ним, это просто контейнеры для данных, используемые другими классами</li>
    <li><bg-code>Отказ от наследства</bg-code> Если наследник использует лишь малую часть унаследованных методов и свойств родителя, это является признаком неправильной иерархии</li>
    <li><bg-code>Комментарии</bg-code> Почувствовав потребность написать комментарий, попробуйте изменить структуру кода так, чтобы любые комментарии стали излишними</li>
</ol>
</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="refactoring">Рефакторинг</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-refactoring">
<ul class="list-point">
    <li><bg-define>Рефакторинг (refactoring)</bg-define> - процесс изменения внутренней структуры программы, не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В основе рефакторинга лежит последовательность небольших эквивалентных (то есть сохраняющих поведение) преобразований. Поскольку каждое преобразование маленькое, программисту легче проследить за его правильностью, и в то же время вся последовательность может привести к существенной перестройке программы и улучшению её согласованности и чёткости</li>
    <li>Цель рефакторинга — сделать код программы более легким для понимания; без этого рефакторинг нельзя считать успешным</li>
    <li>Рефакторинг следует отличать от <u>оптимизации производительности</u>. Как и рефакторинг, оптимизация обычно не изменяет поведение программы, а только ускоряет её работу. Но оптимизация часто затрудняет понимание кода, что противоположно рефакторингу</li>
    <li>С другой стороны, нужно отличать рефакторинг от <u>реинжиниринга</u>, который осуществляется для расширения функциональности программного обеспечения. Как правило, крупные рефакторинги предваряют реинжиниринг</li>
</ul>

<h4>Причины применения рефакторинга</h4>
<ol class="list-num">
    <li>Необходимо добавить новую функцию, которая недостаточно укладывается в принятое архитектурное решение</li>
    <li>Необходимо исправить ошибку, причины возникновения которой сразу не ясны</li>
    <li>Преодоление трудностей в командной разработке, которые обусловлены сложной логикой программы</li>
</ol>

<h4>Признаки плохого кода</h4>
<ol class="list-num">
    <li>Дублирование кода</li>
    <li>Длинный метод</li>
    <li>Большой класс</li>
    <li>Длинный список параметров</li>
    <li>"Жадные" функции — это метод, который чрезмерно обращается к данным другого объекта</li>
    <li>Избыточные временные переменные</li>
    <li>Классы данных</li>
    <li>Несгруппированные данные</li>
</ol>

<h4>Методы рефакторинга</h4>
<ul class="list-point">
    <li><bg-code>Изменение сигнатуры метода (change method signature)</bg-code> - добавление, изменение или удаление параметра метода. Изменив сигнатуру метода, необходимо скорректировать обращения к нему в коде всех клиентов. Это изменение может затронуть внешний интерфейс программы, кроме того, не всегда разработчику, изменяющему интерфейс, доступны все клиенты этого интерфейса, поэтому может потребоваться та или иная форма регистрации изменений интерфейса для последующей передачи их вместе с новой версией программы
    </li>

    <li><bg-code>Инкапсуляция поля (encapsulate field)</bg-code> В случае, если у класса имеется открытое поле, необходимо сделать его закрытым и обеспечить методы доступа. После «Инкапсуляции поля» часто применяется «Перемещение метода»</li>
    
    <li><bg-code>Выделение класса (extract class)</bg-code></li>
    <li><bg-code>Выделение интерфейса (extract interface)</bg-code></li>
    <li><bg-code>Выделение локальной переменной (extract local variable)</bg-code></li>
    <li><bg-code>Выделение метода (extract method)</bg-code> - выделение из длинного и/или требующего комментариев кода отдельных фрагментов и преобразовании их в отдельные методы, с подстановкой подходящих вызовов в местах использования. В этом случае действует правило: если фрагмент кода требует комментария о том, что он делает, то он должен быть выделен в отдельный метод. Также правило: один метод не должен занимать более чем один экран (25-50 строк, в зависимости от условий редактирования), в противном случае некоторые его фрагменты имеют самостоятельную ценность и подлежат выделению. Из анализа связей выделяемого фрагмента с окружающим контекстом делается вывод о перечне параметров нового метода и его локальных переменных</li>
    
    <li><bg-code>Генерализация типа (generalize type)</bg-code></li>
    <li><bg-code>Встраивание (inline)</bg-code></li>
    <li><bg-code>Введение фабрики (introduce factory)</bg-code></li>
    <li><bg-code>Введение параметра (introduce parameter)</bg-code></li>
    <li><bg-code>Подъём метода (pull up method)</bg-code></li>
    <li><bg-code>Спуск метода (push down method)</bg-code></li>
    <li><bg-code>Переименование метода (rename method)</bg-code></li>
    <li><bg-code>Перемещение метода (move method)</bg-code> применяется по отношению к методу, который чаще обращается к другому классу, чем к тому, в котором сам располагается</li>

    <li><bg-code>Замена условного оператора полиморфизмом (replace conditional with polymorphism)</bg-code> Условный оператор с несколькими ветвями заменяется вызовом полиморфного метода некоторого базового класса, имеющего подклассы для каждой ветви исходного оператора. Выбор ветви осуществляется неявно, в зависимости от того, экземпляру какого из подклассов оказался адресован вызов</li>
    
    <li><bg-code>Замена наследования делегированием (replace inheritance with delegation)</bg-code></li>
    <li><bg-code>Замена кода типа подклассами (replace type code with subclasses)</bg-code></li>
</ul>

<h4>Проблемы, возникающие при проведении рефакторинга</h4>
<ul class="list-point">
    <li>Проблемы, связанные с базами данных</li>
    <li>Проблемы изменения интерфейсов</li>
    <li>Трудности при изменении дизайна</li>
</ul>

<h4>Средства автоматизации рефакторинга</h4>
<ul class="list-point">
    Технические критерии для инструментов рефакторинга:
    <li>Базы данных программы</li>
    <li>Деревья синтаксического разбора</li>
    <li>Точность</li>
    Практические критерии для инструментов рефакторинга:
    <li>Скорость</li>
    <li>Отмена модификаций</li>
    <li>Интеграция с другими инструментами</li>
</ul>
</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="code-standart">Стандарты кода</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-code-standart">

<pre><code class="html">
<a href="https://google.github.io/styleguide/jsguide.html" target="_blank">Google JavaScript Style Guide</a>
<a href="https://github.com/leonidlebedev/javascript-airbnb" target="_blank">Airbnb</a>
<a href="https://github.com/rwaldron/idiomatic.js/tree/master/translations/ru_RU" target="_blank">idiomatic.js</a>
</code></pre>

<pre><code class="html">
<a href="https://netology-university.bitbucket.io/codestyle/javascript/" target="_blank">Нетология</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Стандарт оформления кода</bg-define> - набор правил и соглашений, используемых при написании исходного кода на некотором языке программирования</li>
    <li>Смысл кода должен быть виден из самого кода, без необходимости изучать контекст</li>
    <li>Ограничение размера кода по горизонтали (чтобы помещался на экране) и вертикали (чтобы весь код файла держался в памяти), а также функции или метода в размер одного экрана</li>
</ul>

<h4>Инструменты</h4>
<ul class="list-point">
    <li>Статические анализаторы JS кода. Избавляют от случайных ошиюок, помогают придерживаться единого корпоративного стиля кода</li>
    <li><bg-define>JSLint</bg-define> - первый статический анализатор. Один из самых строгих линтеров</li>
    <li><bg-define>JSHint</bg-define> - более гибок, нежели JSLint</li>
    <li><bg-define>ESlint</bg-define> - гибко настраивается, а также может расширяться за счет плагинов</li>
    <li><bg-define>Google Closure Compiler</bg-define> - он представляет собой не только программу для проверки, но и компилятор. Сообщает об ошибках в коде, и также создает минимизированные версии JS. Компилятор удаляет пустое пространство, комментарии и неиспользуемые переменные и упрощает длинные выражения, делая скрипт максимально компактным</li>
</ul>

<img src="img/js/code-style1.png">

</div>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Прочее</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-applications">Виды веб приложений</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><bg-define>SSR</bg-define> - Server-Side Rendering (рендеринг на стороне сервера)</li>
    <li><bg-define>SPA</bg-define> - Single-Page Application (одностраничное приложение)</li>
    <li><bg-define>PWA</bg-define> - Progressive Web App (прогрессивное веб-приложение)</li>
    <li>Стандартные HTML страницы</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="design">Эволюция веб-дизайна</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre>
<code class="js">
1990-2000  Нет дизайна
2000-2010  Скевоморфизм
2010-2013  Flat Design  
2014-2017  Material Design
2018-....  Fluent Design
</code>
</pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="framework">Фреймворки (особенности)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- структура приложения 
- паттерны проектирования
- строгая структура (модульность) приложения
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="mvc">MVC MVP MVVM</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- MVC (модель вид контроллер)
- MVP (модель вид представитель)
- MVVM (модель вид модель представления)
</code></pre>

<pre><code class="plaintext">
<em>MVC</em>
<em>model</em>      - бизнес-логика (просчитывание данных, операций)
<em>view</em>       - видимая часть
<em>controller</em> - берет данные из view и передает в model (запускает model)
</code></pre>



<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Паттерны проектирования</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="patterns">Паттерны проектирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-patterns">
<pre><code class="html">
<a href="https://refactoring.guru/ru/design-patterns/catalog" target="_blank">Каталог паттернов проектирования</a>
<a href="https://habr.com/ru/company/ruvds/blog/427293/" target="_blank">Паттерны проектирования в JavaScript</a>
<a href="https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9" target="_blank">Шаблоны проектирования в JavaScript</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Паттерн проектирования (design pattern)</bg-define> - это часто встречающееся решение определённой проблемы при проектировании архитектуры программ</li>
    <li>В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды программы</li>
    <li>Паттерны часто путают с <u>алгоритмами</u>, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах</li>
</ul>

<!------------------------------------------------------>
<h3>Классификация</h3>
<!------------------------------------------------------>
<ol class="list-num">
    <li><bg-define>Порождающие</bg-define> отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей</li>
    <ul class="list-point">
        <li><bg-code>Фабричный метод (Factory Method)</bg-code> Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов</li>
        <li><bg-code>Абстрактная фабрика (Abstract Factory)</bg-code> Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов. Интерфейс, который группирует другие фабрики, логически связанные друг с другом</li>
        <li><bg-code-accent>Строитель (Builder)</bg-code-accent> Позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов</li>
        <li><bg-code>Прототип (Prototype)</bg-code> Позволяет копировать объекты, не вдаваясь в подробности их реализации</li>
        <li><bg-code-accent>Одиночка (Singleton)</bg-code-accent> Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа</li>
    </ul>

    <li><bg-define>Структурные</bg-define> отвечают за построение удобных в поддержке иерархий классов. Показывают различные способы построения связей между объектами</li>
    <ul class="list-point">
        <li><bg-code>Адаптер (Adapter)</bg-code> Позволяет объектам с несовместимыми интерфейсами работать вместе</li>
        <li><bg-code>Мост (Bridge)</bg-code> Разделяет один или несколько классов на две отдельные иерархии - абстракцию и реализацию, позволяя изменять их независимо друг от друга</li>
        <li><bg-code>Компоновщик (Composite)</bg-code> Позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, как будто это единичный объект</li>
        <li><bg-code-accent>Декоратор (Decorator)</bg-code-accent> Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»</li>
        <li><bg-code-accent>Фасад (Facade)</bg-code-accent> Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку</li>
        <li><bg-code>Легковес (Flyweight)</bg-code> Позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте</li>
        <li><bg-code>Заместитель (Proxy)</bg-code> Позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу</li>
    </ul>

    <li><bg-define>Поведенческие</bg-define> решают задачи эффективного и безопасного взаимодействия между объектами программы</li>
    <ul class="list-point">
        <li><bg-code>Цепочка обязанностей (Chain of Responsibility)</bg-code> Позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи</li>
        <li><bg-code>Команда (Command)</bg-code> Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций</li>
        <li><bg-code>Итератор (Iterator)</bg-code> Даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления</li>
        <li><bg-code>Посредник (Mediator)</bg-code> Позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник</li>
        <li><bg-code>Снимок (Memento)</bg-code> Позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов</li>
        <li><bg-code-accent>Наблюдатель (Observer)</bg-code-accent> Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах</li>
        <li><bg-code>Состояние (State)</bg-code> Позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта</li>
        <li><bg-code>Стратегия (Strategy)</bg-code> Определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы</li>
        <li><bg-code>Шаблонный метод (Template method)</bg-code> Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры</li>
        <li><bg-code>Посетитель (Visitor)</bg-code> Позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться</li>
    </ul>

</ol>

<!------------------------------------------------------>
<h3>Зачем?</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-code>Проверенные решения</bg-code> Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда</li>
    <li><bg-code>Стандартизация кода</bg-code> Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так как все скрытые проблемы в них уже давно найдены</li>
    <li><bg-code>Общий программистский словарь</bg-code> Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, какой крутой дизайн вы придумали и какие классы для этого нужны</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-simple-factory">Паттерн «Простая фабрика»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-simple-factory">
<ul class="list-point">
    <li><bg-define>«Простая фабрика»</bg-define> - производит нужный экземпляр, не утруждая клиента тонкостями этого процесса</li>
    <li>Ненужно каждый раз создавать экземпляр класса</li>
</ul>
<pre><code class="js">
class WoodenDoor {
    constructor(width, height){
        this.width = width
        this.height = height
    }
    getWidth(){
        return this.width
    }
    getHeight(){
        return this.height
    }
}
const DoorFactory = {
    makeDoor(width, height) {
        return new WoodenDoor(width, height); 
    }
}
const door = DoorFactory.makeDoor(100, 200)
console.log('Width:', door.getWidth())
console.log('Height:', door.getHeight())
</code></pre>
</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-singleton">Паттерн «Синглтон»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-singleton">
<ul class="list-point">
    <li><bg-define>«Синглтон» (Singleton)</bg-define> порождающий паттерн проектирования, гарантирующий что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа в однопоточном приложении</li>
    <li>В рамках применения этого паттерна новый экземпляр некоего класса создаётся в том случае, если он пока не создан. Если же экземпляр класса уже существует, то, при попытке обращения к конструктору, возвращается ссылка на соответствующий объект. Последующие вызовы конструктора всегда будут возвращать тот же самый объект</li>

    <li><b>Зачем:</b> Использование конструктора плохая практика, особенно если у класса есть зависимости var user = new User()</li>
</ul>

<h4>Какие проблемы решает</h4>
<ol class="list-num">
    <li><bg-code>Гарантирует наличие единственного экземпляра класса</bg-code> Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных. Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект</li>
    <li><bg-code>Предоставляет глобальную точку доступа</bg-code> Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома</li>
</ol>

<!------------------------------------------------------>
<h3>Представление класса в виде синглтона</h3>
<!------------------------------------------------------>
<h4>Обычный класс a !== b</h4>
<pre><code class="js">
class usualClass {
    constructor() {
        // this.name = null;
    }
    testMethod() {
        return 'Hello'
    }
}

var a = new usualClass();
var b = new usualClass();
<bg-code>console.log(a === b); // false</bg-code>
console.log(a.testMethod());
</code></pre>


<div class="container-flex"><div class="container-half"><h4>Singleton ES5</h4><pre><code class="js">
const Universe = (function(){
    let instance = null;
    function func() {
        if (!instance) {
            instance = this;
            this.size = 100;
        }
        return instance;
    }
    func.prototype.getSize = function() {
       return this.size;
    }
    func.prototype.setSize = function(size) {
       this.size = size;
    }
    return func;
})();

var a = new Universe();
var b = new Universe();

<bg-code>console.log(a === b); // true</bg-code>
console.log(a.getSize(), b.getSize()); // 100, 100
a.setSize(200);
console.log(a.getSize(), b.getSize()); // 200, 200
</code></pre></div><div class="container-half"><h4>Singleton ES6</h4><pre><code class="js">
var instance = null;

class Singleton {
    constructor() {
        if(!instance){
            instance = this;
        }
        return instance;
    }
}
var a = new Singleton();
var b = new Singleton();
<bg-code>console.log(a === b); // true</bg-code>
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Представление класса в виде объектного литерала</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Всякий раз, когда мы обращаемся к переменной user, мы получаем ссылку на один и тот же объект</li>
</ul>
<pre><code class="js">
const user = {
    name: 'Tony',
    greet: function() {
        console.log('Hello!');
    }
};
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-decorator">Паттерн «Декоратор»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-decorator">

<ul class="list-point">
    <li><bg-define>«Декоратор»</bg-define> - структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»</li>
    <li>Расширения функционала объектов без модификации существующих классов или функций-конструкторов. Паттерн можно использовать для добавления к объектам неких возможностей без модификации кода, который ответственен за их создание</li>
    <li>Применяя «Декоратор», вы не меняете первоначальный класс и не создаёте дочерних классов</li>
</ul>

<pre><code class="js">
function Car(name) {
    this.name = name;
    this.color = 'White';
}

// создание нового объекта, который планируется декорировать
const tesla = new Car('Tesla Model 3');

// декорирование объекта - добавление нового функционала
tesla.setColor = function(color) {
    this.color = color;
}
tesla.setPrice = function(price) {
    this.price = price;
}

tesla.setColor('black');
tesla.setPrice(49000);
console.log(tesla.color); // выводит black
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-builder">Паттерн «Строитель»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-builder">
<ul class="list-point">
    <li><bg-define>«Строитель»</bg-define> - порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов</li>
    <li>Паттерн Строитель нужен, если объект может существовать в разных вариациях или процесс инстанцирования состоит из нескольких шагов</li>
</ul>

<h4>Пример гамбургера с разными компонентами</h4>
<pre><code class="js">
class BurgerBuilder {
    constructor(size) {
        this.size = size
    }
    addPepperoni() {
        this.pepperoni = true
        return this
    }
    addCheeze() {
        this.cheeze = true
        return this
    }
    build() {
        return new Burger(this)
    }
}
const burger = (new BurgerBuilder(14))
    .addPepperoni()
    .addCheeze()
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-observer">Паттерн «Наблюдатель»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-observer">
<ul class="list-point">
    <li><bg-define>«Наблюдатель»</bg-define> - поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах</li>
    <li>Основан на зависимости один ко многим: при изменении состояния одного объекта (Observer), все зависимые объекты (Observable) оповещаются об этом. Самое главное в общении этих двух объектов, что не нужна прямая связь между объектом и субъектом. Это позволяет добиться модульности клиентской части кода</li>
    <li><u>Observable</u> (Издатели) - наблюдаемый объект. Содержит список [Observer] и если у него что-то происходит, всех оповещает в цикле. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков</li>
    <li><u>[Observer]</u> (Подписчики) - наблюдатели (кучка объектов) за Observable</li>
</ul>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-module">Паттерн «Модуль»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-module">
<ul class="list-point">
    <li><bg-define>Модуль</bg-define> - прием, с помощью которого мы можем скрывать какие-то реализации. Самостоятельный фрагмент кода, который можно изменять, не затрагивая другой код проекта. Модули, кроме того, позволяют избегать такого явления, как загрязнение областей видимости, благодаря тому, что они создают отдельные области видимости для объявляемых в них переменных.</li>
    <li>Модуль использует <u>IIFE</u>, <u>замыкания</u> и <u>области видимости функций</u> для имитации концепции <u>инкапсуляции</u></li>
    <li><bg-code>Модуль при помощи замыканий</bg-code> – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется</li>
    <li>Все функции модуля будут иметь доступ к другим переменным и внутренним функциям этого же модуля через замыкание. Но снаружи программист, использующий модуль, может обращаться напрямую только к тем переменным и функциям, которые экспортированы. Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля</li>
    <li><b>Недостаток</b> приходится создавать публичные функции только для того, чтобы обращаться к приватным функциям и переменным</li>
</ul>

<pre><code class="js">
const myModule = (function() {
    const privateVariable = 'Hello World';
    function privateMethod() {
        console.log(privateVariable);
    }
    return {
        publicMethod: function() {
            privateMethod();
        }
    }
})();
</code></pre>

<pre><code class="js">
myModule.publicMethod(); // Выводит 'Hello World'
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-facade">Паттерн «Фасад»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-facade">
<ul class="list-point">
    <li><bg-define>«Фасад»</bg-define> - структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку</li>
</ul>

<pre><code class="js">
var $ = function(target) {
    return new MemeQuery(target);
}
function MemeQuery(target) {
    this.target = document.querySelector(target);
}
MemeQuery.prototype.html = function(html) {
    this.target.innerHTML = html;
    return this;
}

$('#myParagraph').html('Meeemee').html('Some JS design patterns');
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern-revealing-module">Паттерн «Открытый модуль»</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-pattern-revealing-module">

<ul class="list-point">
    <li><bg-define>Открытый модуль</bg-define> - в паттерне назначаем свойствам возвращаемого объекта приватные функции, которые хотим сделать общедоступными</li>
</ul>

<ul class="list-point">
    <b>Преимущества паттерна «Открытый модуль» перед паттерном «Модуль»</b>
    <li>«Открытый модуль» позволяет делать общедоступными скрытые сущности модуля (и снова скрывать их, если нужно), модифицируя, для каждой из них, лишь одну строку в объекте, возвращаемом после выполнения IIFE</li>
    <li>Возвращаемый объект не содержит определения функций. Всё, что находится справа от имён его свойств, определено в IIFE. Это способствует чистоте кода и упрощает его чтение</li>
</ul>

<pre><code class="js">
const myRevealingModule = (function() {
    let privateVar = 'Peter';
    const publicVar  = 'Hello World';
    function privateFunction() {
        console.log('Name: '+ privateVar);
    }
    function publicSetName(name) {
        privateVar = name;
    }
    function publicGetName() {
        privateFunction();
    }
    return {
        setName: publicSetName,
        greeting: publicVar,
        getName: publicGetName
    };
})();
</code></pre>

<pre><code class="js">
myRevealingModule.setName('Mark');
myRevealingModule.getName(); // Выводит Name: Mark
</code></pre>

</div>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Алгоритмы и структуры данных</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="big-o-notation">Big-O Notation (сложность алгоритмов)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-big-o-notation">

<pre><code class="html">
<a href="https://www.youtube.com/watch?v=ZRdOb4yR0kk" target="_blank">[YouTube] Оценка сложности алгоритма</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Big-O Notation</bg-define> показывает <b>верхнюю границу сложности алгоритма</b> зависимости между <b>входными параметрами</b> функции и <b>количеством операций</b>, которые выполнит процессор</li>

    <li>Нельзя оценивать работу алгоритм с точки зрения времени. Один и тот же алгоритм на разных машинах будет выполняться разное время. Алгоритм включает в себя число шагов. Идея Big-O - сколько шагов нужно сделать чтобы алгоритм завершил свое выполнение</li>

    <li><bg-define>Сложность алгоритма (вычислительная сложность)</bg-define> - функция зависимости объёма работы, которая выполняется некоторым алгоритмом, от размера входных данных</li>

    <li>Объём работы обычно измеряется временем и вычислительными ресурсами. Время определяется количеством элементарных шагов, необходимых для решения задачи. Ресурсы определяются объёмом памяти или места на носителе данных</li>
</ul>

<!------------------------------------------------------>
<h3>Верхняя граница (отбрасывание констант)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Мы говорим как будет вести себя алгоритм на бесконечности</li>
    <li>Если алгоритм для n-элементов выполняет n-тактов плюс один такт для вывода информацим на экран, то сложность такого алгоритма всё равно O(N), т.к. бесконечность гораздо больше единицы. Тоже самое касается алгоритмов, которые выполняются за O(2N) или более</li>
    <li>Big-O описывает только скорость роста. Поэтому мы отбрасываем константы при оценке сложности</li>
    <li>Алгоритм, описываемый как O(2N) должен описываться как O(N)</li>
</ul>

<!------------------------------------------------------>
<h3>O(формула_поведения_алгоритма)</h3>
<!------------------------------------------------------>
<pre><code class="bash">
<em>O(0)</em> # ничего не происходит
<em>O(1)</em> # постоянная величина (н-р: размер файлов не зависит на скорость передачи данных если они доставляются на самолете)
<em>O(N)</em> # зависимость прямо пропорциональна (линейная) и зависит от количества передаваемых бит (н-р: чем больше файлов, тем дольше их передавать по сети)
<em>O(N + N) = O(N)</em> # последователность действий - сложение
<em>O(N * N) = O(N<sup>2</sup>)</em> # вложенные действия - умножение
</code></pre>

<!------------------------------------------------------>
<h3>Быстродействие</h3>
<!------------------------------------------------------>
<h4>Рекурсия => Быстродействие: O(N)</h4>
<pre><code class="js">
function pow(x, n) {
    if (n != 1) {
        return x * pow(x, n - 1);
    } else {
        return x;
    }
}
</code></pre>

<h4>Сложение чисел => Быстродействие: O(1)</h4>
<pre><code class="js">
function sum(a, b) {
    return a + b;
}
</code></pre>

<h4>Быстродействие: O(N)</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
let min = 1;
let max = 10;
for(let i=0; i<=100; i++) {
    if (i < min) min = i;
    if (i > max) max = i;
}
</code></pre></div><div class="container-half"><pre><code class="js">
let min = 1;
let max = 10;
for(let i=0; i<=100; i++) {
    if (i < min) min = i;
}
for(let i=0; i<=100; i++) {
    if (i > max) max = i;
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Сложение и умножение</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half">
<b>Быстродействие: O(A + B)</b>
<pre><code class="js">
let arrA = [1,2,3];
let arrB = [1,2,3];
for(let i=0; i<=arrA; i++) {
    console.log(i);
}
for(let i=0; i<=arrB; i++) {
    console.log(i);
}
// Проход по массивам выполняется последовательно
// Выполнение первого цикла не зависит от выполнения второго
// A - длина массива arrA
// B - длина массива arrB
</code></pre></div><div class="container-half">
<b>Быстродействие: O(A * B)</b>
<pre><code class="js">
let arrA = [1,2,3];
let arrB = [1,2,3];
for(let a=0; a<=arrA; a++) {
    for(let b=0; b<=arrB; b++) {
        console.log(a, b);
    }
}
// Выполнить что-то N раз, пока делаешь что-то свое
// Цикл по "B" зависим от цикла по "A"
</code></pre></div></div>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="structure-data">Структуры данных</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-structure-data">

<ul class="list-point">
    <li><bg-define>Структуры данных</bg-define> - способы хранить и организовывать множество однотипных и/или логически связанных данных</li>
    <li>Структуры данных позволяют производить 4 основных типа действий: доступ, поиск, вставку и удаление</li>    
</ul>

<!------------------------------------------------------>
<h3>List (Список)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>List (Список)</bg-define> - представление пронумерованной последовательности значений, где одно и то же значение может присутствовать сколько угодно раз</li>
    <li>Обычный список позволяет очень быстро получить доступ к памяти, поскольку вы уже знаете нужный адрес</li>
    <li>У списков есть порядковые номера, поэтому можно вставлять значения в начало, середину и конец</li>
    <li>Списки отлично справляются с быстрым доступом к элементам в своём конце и работой с ними. Однако, для элементов из начала или середины они не слишком хороши, так как приходится вручную обрабатывать адреса памяти</li>
</ul>

<h4>Push (добавить в конец), Pop (удалить из конца) <bg-code>O(1)</bg-code></h4>
<pre><code class="bash">
# являются простыми операциями, поскольку не затрагивают весь остальной список
</code></pre>

<h4>Unshift (добавить в начало) <bg-code>O(N)</bg-code></h4>
<pre><code class="bash">
# чтобы добавить новый элемент в начало списка, нужно освободить пространство для этого значения, 
# сдвинув на один все последующие значения
[a, b, c, d, e]
 0  1  2  3  4
  ⬊  ⬊  ⬊  ⬊  ⬊
    1  2  3  4  5
[x, a, b, c, d, e]
</code></pre>

<h4>Shift (удалить из начала) <bg-code>O(N)</bg-code></h4>
<pre><code class="bash">
# удаляем первое значение и затем сдвигаем каждый элемент списка на предшествующий адрес
[x, a, b, c, d, e]
    1  2  3  4  5
  ⬋  ⬋  ⬋  ⬋  ⬋
 0  1  2  3  4
[a, b, c, d, e]
</code></pre>

<!------------------------------------------------------>
<h3>Stack (Стек)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Stack (Стек)</bg-define> - абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»)</li>
    <li>Зачастую стек реализуется в виде однонаправленного списка (каждый элемент в списке содержит помимо хранимой информации в стеке указатель на следующий элемент стека). Но также часто стек располагается в одномерном массиве с упорядоченными адресами</li>
    <li><b>Операции</b>: добавление элемента (push), удаление (pop), чтение головного элемента (peek)</li>
    <li><b>push</b> добавляется новый элемент, указывающий на элемент, бывший до этого головой. Новый элемент теперь становится головным</li>
    <li><b>pop</b> убирается первый, а головным становится тот, на который был указатель у этого объекта (следующий элемент). При этом значение убранного элемента возвращается</li>
</ul>

<div class="container-flex"><div class="container-half">
<img src="img/js/structure-stack1.png" width="100%">
</div><div class="container-half">
<img src="img/js/structure-stack2.png" width="100%">
<ul class="list-point">
    <li>Организация стека в виде одномерного упорядоченного по адресам массива. push и pop</li>
</ul>
</div></div>

<!------------------------------------------------------>
<h3>Queue (Очередь)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Queue (Очередь)</bg-define> - абстрактный тип данных с доступом к элементам «первый пришёл — первый вышел» (FIFO, англ. first in, first out)</li>
    <li>Добавление элемента (<u>enqueue</u> — поставить в очередь) возможно лишь в конец очереди, выборка - только из начала очереди (<u>dequeue</u> - убрать из очереди), при этом выбранный элемент из очереди удаляется</li>
</ul>

<!------------------------------------------------------>
<h3>Дерево</h3>
<!------------------------------------------------------>
<pre><code class="html">
<a href="https://www.youtube.com/watch?v=wtgLQE9hjuk" target="_blank">[YouTube] Алгоритмы и структуры данных. Деревья</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Деревья</bg-define> - эмулирует древовидную структуру в виде набора связанных узлов (вершин) и ребер</li>
    <li>Дерево должно начинаться с единственного родителя, «корня» дерева</li>
    <li>Дерево считается ориентированным, если в корень не заходит ни одно ребро</li>
    <li><b>Определяющее свойство дерева</b> - существование только одного пути, соединяющего любые два узла</li>
</ul>

<h4>Определения</h4>

<div class="container-flex"><div class="container-half">
<ul class="list-point">
    <li><u>Вершина (узел)</u> - простой объект</li>
    <li><u>Ребро</u> - связь между двумя верщинами</li>
    <li><u>Путь в дереве</u> - список отдельных вершин, в котором следующие друг за другом вершины соединяются ребрами дерева</li>
    <li><u>Корневой узел</u> - самый верхний узел дерева (узел 8 на примере)</li>
    <li><u>Корень</u> - одна из вершин, по желанию наблюдателя</li>
    <li><u>Лист, листовой или терминальный узел</u> - узел, не имеющий дочерних элементов (узлы 1, 4, 7, 13)</li>
    <li><u>Внутренний узел</u> - любой узел дерева, имеющий потомков, и таким образом, не являющийся листовым узлом (3, 6, 10, 14)</li>
</ul>
</div><div class="container-half">
<img src="img/js/structure-tree1.png" width="200px">
</div></div>

<h4>Представление дерева</h4>
<img src="img/js/structure-tree2.jpg">

<h4>Общие операции</h4>
<ul class="list-point">
    <li>Вставка нового элемента в определённую позицию</li>
    <li>Вставка поддерева</li>
    <li>Добавление ветви дерева</li>
    <li>Нахождение корневого элемента для любого узла</li>
    <li>Нахождение наименьшего общего предка двух вершин</li>
    <li>Перебор всех элементов дерева</li>
    <li>Перебор элементов ветви дерева</li>
    <li>Поиск изоморфного поддерева</li>
    <li>Поиск элемента;</li>
    <li>Удаление ветви дерева</li>
    <li>Удаление поддерева</li>
    <li>Удаление элемента</li>
</ul>

<h4>Обход дерева</h4>
<img src="img/js/structure-tree3.jpg" height="200px">

<h4>Обход двоичного дерева в глубину (DFS - Depth First Search)</h4>
<ul class="list-point">
    <li>Используется стек</li>
</ul>
<ol class="list-num">
    <li>Обработка узла поддерева</li>
    <li>Рекурсивный обход левого поддерева</li>
    <li>Рекурсивный обход правого поддерева</li>
</ol>

<ul class="list-point">
    <u>Прямой обход (сверху-вниз, pre-order)</u>
    <li>вначале обрабатывается узел, затем посещается левое и правое поддерево</li>
</ul>
<pre><code class="bash">
E, D, B, A, C, H, F, G
</code></pre>

<ul class="list-point">
    <u>Обратный обход (снизу вверх, post-order)</u>
    <li>вначале посещается левое и правое поддерево, затем обрабатывается узел</li>
</ul>
<pre><code class="bash">
A, C, B, D, G, F, H, E
</code></pre>

<ul class="list-point">
    <u>Поперечный обход (слева-направо, in-order)</u>
    <li>вначале посещается левое поддерево, затем узел и правое поддерево</li>
</ul>
<pre><code class="bash">
A, B, C, D, E, F, G, H
</code></pre>


<h4>Обход двоичного дерева в ширину (BFS - Breadth First Search)</h4>
<ul class="list-point">
    <li>Используется очередь, содержащая вершины, требующие просмотра</li>
    <li>Выполняется по слоям начиная от корня</li>
</ul>
<ol class="list-num">
    За одну итерацию алгоритма:
    <li>если очередь не пуста, извлекается вершина из очереди</li>
    <li>обрабатывается извлеченная вершина</li>
    <li>в очередь помещаются все дочерние</li>
</ol>
<pre><code class="bash">
E, D, H, B, F, A, C, G
</code></pre>




<!------------------------------------------------------>
<h3>Куча</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Куча</bg-define> - специализированная структура данных типа дерево, которая удовлетворяет свойству кучи: если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B). Из этого следует, что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда такие кучи называют max-кучами (в качестве альтернативы, если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами)</li>
    <li><b>Реализация</b>: массив</li>
</ul>

<h4>Операции</h4>
<ul class="list-point">
    <li>Найти максимум или найти минимум: найти максимальный элемент в max-куче или минимальный элемент в min-куче, соответственно</li>
    <li>Удалить максимум или удалить минимум: удалить корневой узел в max- или min-куче, соответственно</li>
    <li>Увеличить ключ или уменьшить ключ: обновить ключ в max- или min-куче, соответственно</li>
    <li>Добавить: добавление нового ключа в кучу</li>
    <li>Слияние: соединение двух куч с целью создания новой кучи, содержащей все элементы обеих исходных</li>
</ul>

<!------------------------------------------------------>
<h3>Хеш-таблица</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Хеш-таблица</bg-define> - это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу</li>
</ul>

<!------------------------------------------------------>
<h3>Граф</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Граф</bg-define> - есть множество «вершин» (A, B, C, D, ...), связанных линиями</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="basic-algoritms-sort">Алгоритмы сотрировки</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-basic-algoritms-sort">

<!------------------------------------------------------>
<h3>Сортировка</h3>
<!------------------------------------------------------>
<ol class="list-num">
    <li>Пузырьковая сортировка</li>
    <li>Сортировка выбором</li>
    <li>Сортировка вставками</li>
    <li>Быстрая сортировка</li>
</ol>

<h4>Метод sort</h4>
<pre><code class="js">
arr.sort(function(a, b){ 
    if(a < b) {
        return 1;
    } else {
        return -1
    }
});
</code></pre>

<h4>Пузырьковая сортировка</h4>
<ul class="list-point">
    <li><b>Суть</b>: сравнение соседних элементов и их обмене, если они находятся не в надлежащем порядке. Неоднократно выполняя это действие, мы заставляем наибольший элемент "всплывать" к концу массива. Следующий проход приведет к всплыванию второго наибольшего элемента, и так до тех пор, пока после n-1 итерации массив не будет полностью отсортирован</li>
    <li><b>Плюс</b>: простая реализация</li>
    <li><b>Минусы</b>: эффективен он лишь для небольших массивов</li>
    <li><b>Сложность</b>: O(N<sup>2</sup>)</li>
</ul>
<pre><code class="js">
function BubbleSort(A){
    var n = A.length;
    for (var i = 0; i < n-1; i++) { 
        for (var j = 0; j < n-1-i; j++) { 
            if (A[j+1] < A[j]) { 
                var t = A[j+1]; A[j+1] = A[j]; A[j] = t; 
            }
        }
    }                     
    return A;
}
</code></pre>

<h4>Сортировка выбором</h4>
<ul class="list-point">
    <li><b>Суть</b>: начинается с поиска наименьшего элемента в списке и обмена его с первым элементом (таким образом, наименьший элемент помещается в окончательную позицию в отсортированном массиве). Затем мы сканируем массив, начиная со второго элемента, в поисках наименьшего среди оставшихся n-1 элементов и обмениваем найденный наименьший элемент со вторым, т.е. помещаем второй наименьший элемент в окончательную позицию в отсортированном массиве. В общем случае, при i-ом проходе по списку (0<=i<=n-2) алгоритм ищет наименьший элемент среди последних n-i элементов и обменивает его с A[i]. После выполнения n-1 проходов список оказывается отсортирован</li>
</ul>
<pre><code class="js">
function SelectionSort(A) {
    var n = A.length;
    for (var i = 0; i < n - 1; i++) {
        var min = i;
        for (var j = i + 1; j < n; j++) {
            if (A[j] < A[min]) min = j;
        }
        var t = A[min];
        A[min] = A[i];
        A[i] = t;
    }
    return A;
}
</code></pre>

<h4>Сортировка вставками</h4>
<ul class="list-point">
    <li><b>Суть</b>: На каждом шаге алгоритма сортировки встаками выбирается один из элементов входного массива и вставляется на нужную позицию в уже отсортированном массиве, до тех пор, пока входных элементы не будут исчерпана. Метод выбора очередного элемента из исходного массива произволен; может использоваться практически любой алгоритм выбора</li>
</ul>
<pre><code class="js">
function InsertionSort(A) {
    var n = A.length;
    for (var i = 0; i < n; i++) {
        var v = A[i],
            j = i - 1;
        while (j >= 0 && A[j] > v) {
            A[j + 1] = A[j];
            j--;
        }
        A[j + 1] = v;
    }
    return A;
}
</code></pre>

<h4>Быстрая сортировка</h4>
<pre><code class="js">
function QuickSort(A) {
    if (A.length == 0) return [];
    var a = [],
        b = [],
        p = A[0];
    for (var i = 1; i < A.length; i++) {
        if (A[i] < p) a[a.length] = A[i];
        else b[b.length] = A[i];
    }
    return QuickSort(a).concat(p, QuickSort(b));
}
</code></pre>

</div>



<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Тестирование</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="testing-test">Тестирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-testing-test">

<ul class="list-point">
    <li><bg-define>Тестирование ПО</bg-define> - процесс исследования, испытания программного продукта, имеющий своей целью проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе тестов, выбранных определенным образом</li>
    <li><bg-define>Тестовые сценарии</bg-define> используются на разных уровнях: как в компонентном, так и в интеграционном и системном тестировании. Тестовые сценарии, как правило, пишутся для проверки компонентов, в которых наиболее высока вероятность появления ошибок</li>
    <li><bg-define>Покрытие кода</bg-define> показывает процент исходного кода программы, который был выполнен («покрыт») в процессе тестирования. По способам измерения выделяют покрытие операторов, покрытие условий, покрытие путей, покрытие функций и др.</li>
</ul>

<!------------------------------------------------------>
<h3>Уровни тестирования</h3>
<!------------------------------------------------------>
<ol class="list-num">
    <li><bg-define>Тестирование компонентов</bg-define> - тестируется минимально возможный для тестирования компонент, например, отдельный класс или функция. Часто тестирование компонентов осуществляется разработчиками программного обеспечения</li>
    <li><bg-define>Интеграционное тестирование</bg-define> - тестируются интерфейсы между компонентами, подсистемами или системами. При наличии резерва времени на данной стадии тестирование ведётся итерационно, с постепенным подключением последующих подсистем</li>
    <li><bg-define>Системное тестирование</bg-define> - тестируется интегрированная система на её соответствие требованиям</li>
    <ul class="lisy-point">
        <li><bg-define>Альфа-тестирование</bg-define> имитация реальной работы с системой. Чаще всего альфа-тестирование проводится на ранней стадии разработки продукта, но в некоторых случаях может применяться для законченного продукта в качестве внутреннего приёмочного тестирования. Иногда альфа-тестирование выполняется под отладчиком или с использованием окружения, которое помогает быстро выявлять найденные ошибки. Обнаруженные ошибки могут быть переданы тестировщикам для дополнительного исследования в окружении, подобном тому, в котором будет использоваться программа</li>
        <li><bg-define>Бета-тестирование</bg-define> в некоторых случаях выполняется распространение предварительной версии (в случае проприетарного программного обеспечения иногда с ограничениями по функциональности или времени работы) для некоторой большей группы лиц с тем, чтобы убедиться, что продукт содержит достаточно мало ошибок. Иногда бета-тестирование выполняется для того, чтобы получить обратную связь о продукте от его будущих пользователей</li>
    </ul>
</ol>

<!------------------------------------------------------>
<h3>Виды тестирования</h3>
<!------------------------------------------------------>
<ol class="list-num">
    <li><bg-define>Статическое тестирование</bg-define> программный код не выполняется - анализ программы происходит на основе исходного кода, который вычитывается вручную, либо анализируется специальными инструментами</li>
    <li><bg-define>Динамическое тестирование</bg-define> - код исполняется</li>
    <ul class="list-point">
        <li><bg-define>Тестирование «белого ящика»</bg-define> - разработчик теста имеет доступ к исходному коду программ и может писать код, который связан с библиотеками тестируемого программного обеспечения. Это типично для компонентного тестирования, при котором тестируются только отдельные части системы. Оно обеспечивает то, что компоненты конструкции работоспособны и устойчивы, до определённой степени</li>
        <li><bg-define>Тестирование «чёрного ящика»</bg-define> - тестировщик имеет доступ к программе только через те же интерфейсы, что и заказчик или пользователь, либо через внешние интерфейсы, позволяющие другому компьютеру либо другому процессу подключиться к системе для тестирования. Например, тестирующий компонент может виртуально нажимать клавиши или кнопки мыши в тестируемой программе с помощью механизма взаимодействия процессов</li>
        <li><bg-define>Тестирование «серого ящика»</bg-define> - разработчик теста имеет доступ к исходному коду, но при непосредственном выполнении тестов доступ к коду, как правило, не требуется</li>
    </ul>
    <li><bg-define>Регрессионное тестирование</bg-define> - после внесения изменений в очередную версию программы, регрессионные тесты подтверждают, что сделанные изменения не повлияли на работоспособность остальной функциональности приложения. Регрессионное тестирование может выполняться как вручную, так и средствами автоматизации тестирования</li>
</ol>

<img src="img/js/testing-table.png">

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="testing-pyramid">Пирамида тестирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-testing-pyramid">

<div class="container-flex"><div class="container-half">
<img src="img/js/testing-pyramid1.png" class="center" height="200px">
</div><div class="container-half">
<img src="img/js/testing-pyramid2.png" class="center" height="200px">
</div></div>

<pre><code class="bash">
1. Unit Testing
2. Integration Testing
3. System Testing
4. E2E Testing
</code></pre>

<ul class="list-point">
    <li>Нижняя часть — это самые быстрые, простые и самые изолированные тесты, а верхние — самые дорогие, самые медленные и охватывают всё приложение в целом</li>
</ul>

<ul class="list-point">
    <b>Google часто предлагает разделение <bg-code>70/20/10</bg-code>:</b>
    <li>70% unit тестов</li>
    <li>20% интеграционных тестов</li>
    <li>10% E2E тестов</li>
</ul>

<ol class="list-num">
    <li>Модульные тесты реализовывать быстрее, чем GUI тесты (время на разработку меньше). Модульные тесты отрабатывают быстрее, чем GUI</li>
    <li>Модульные тесты дешевле, чем GUI тесты (однако, стремясь к вершине пирамиды, мы получаем большую уверенность в том, что все работает как ожидалось)</li>
    <li>Тестирование должно быть разносторонним, но соотношение тестов должно быть таково, что модульных количественно больше, чем GUI. Системные тесты занимают середину</li>
</ol>

<h4>Виды тестирования по степени изолированности кода</h4>
<ol class="list-num">
    <li><bg-define>Блочное (Unit testing)</bg-define> - тестирование одного модуля в изоляции</li>
    <li><bg-define>Интеграционное (Integration Testing)</bg-define> - тестирование группы взаимодействующих модулей</li>
    <li><bg-define>Системное (System Testing)</bg-define> - тестирование системы в целом. Для небольших проектов это, как правило, ручное тестирование - запустил, пощелкал, убедился, что (не) работает. Можно автоматизировать. К автоматизации есть два подхода</li>
    <ul class="list-point">
        <li>Использовать вариацию MVC паттерна - Passive View и формализовать взаимодействие пользователя с GUI в коде. Тогда системное тестирование сводится к тестированию Presenter классов, а также логики переходов между View</li>
        <li>Использовать специальные инструменты для записи действий пользователя. То есть в итоге запускается сама программа, но щелканье по кнопкам осуществляется автоматически</li>
    </ul>
</ol>

<h4>Принципы</h4>
<ol class="list-num">
    <li>Писать тесты разной детализации</li>
    <li>Чем выше уровень, тем меньше тестов</li>
</ol>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="testing-unit">Юнит-тесты</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-testing-unit">

<ul class="list-point">
    <li><bg-define>Юнит-тесты</bg-define> позволяет проверить на корректность отдельные модули исходного кода программы (функции, методы и классы) в изоляции от остальной программы (а всё остальное имитируется/заменяется). Они должны быть написаны на том же языке, что и тестируемый продукт и храниться в том же репозитории. Обычно пишутся разработчиками. Они часто прогоняются как часть сборки, чтобы сразу же увидеть успешно ли завершается тест или нет</li>
    <li>Тест является спецификацией метода класса, контрактом: какие входные параметры ожидает этот метод, и что остальные компоненты системы ждут от него на выходе</li>
    <li><u>Тесты белого ящика</u></li>
    <li><b>Цель</b>: изолировать отдельные части программы и показать, что по отдельности эти части работоспособны</li>

    <li><b>Идея</b>: писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок</li>
</ul>

<h4>Преимущества</h4>
<ol class="list-num">
    <li><u>Поощрение изменений</u>. Поощряет программистов к изменениям кода, поскольку достаточно легко проверить, что код работает и после изменений</li>
    <li><u>Упрощение интеграции</u>. Может быть использовано для подхода к тестированию «снизу вверх»: сначала тестируя отдельные части программы, а затем программу в целом</li>
    <li><u>Документирование кода</u>. Можно рассматривать как «живой документ» для тестируемого класса</li>
    <li><u>Отделение интерфейса от реализации</u>. Поскольку некоторые классы могут использовать другие классы, тестирование отдельного класса часто распространяется на связанные с ним. Например, класс пользуется базой данных; в ходе написания теста программист обнаруживает, что тесту приходится взаимодействовать с базой. Это ошибка, поскольку тест не должен выходить за границу класса. В результате разработчик абстрагируется от соединения с базой данных и реализует этот интерфейс, используя свой собственный mock-объект. Это приводит к менее связанному коду, минимизируя зависимости в системе</li>
    
    <ul class="list-point">
        <li><bg-define>Mock-объект (mock object «объект-имитация»)</bg-define> - в ООП тип объектов, реализующих заданные аспекты моделируемого программного окружения. Mock-объект представляет собой конкретную фиктивную реализацию интерфейса, предназначенную исключительно для тестирования взаимодействия и относительно которого высказывается утверждение</li>
    </ul>
</ol>

<h4>Когда не работает</h4>
<ol class="list-num">
    <li><u>Сложный код</u></li>
    <li><u>Результат известен лишь приблизительно</u></li>
    <li><u>Код, взаимодействующий с системой</u>. Код, взаимодействующий с портами, таймерами и прочими «нестабильными» частями системы, крайне сложно проверить в изолированном окружении</li>
    <li><u>Ошибки интеграции и производительности</u>. При выполнении юнит-тестов происходит тестирование каждого из модулей по отдельности. Это означает, что ошибки интеграции, системного уровня, функций, исполняемых в нескольких модулях, не будут определены</li>
    <li><u>При общей низкой культуре программирования</u>. Для получения выгоды от модульного тестирования требуется строго следовать технологии тестирования на всём протяжении процесса разработки программного обеспечения. Нужно хранить не только записи обо всех проведённых тестах, но и обо всех изменениях исходного кода во всех модулях. С этой целью следует использовать систему контроля версий ПО. Таким </li>
    <li><u>Проблемы с объектами-заглушками</u></li>
</ol>

<h4>Библиотеки для JavaScript</h4>
<ul class="list-point">
    <li>Mocha (тестовый фреймворк)</li>
    <li>Jest</li>
    <li>Chai («assertion library», используется совместно с тестовым framework’ом)</li>
    <li>Sinon.JS (библиотека для создания mock’ов, stub’ов, spy’ев, используется совместно с тестовым framework’ом)</li>
    <li>Karma runner (от создателей Angular.JS, «test runner» — организует среду выполнения тестов)</li>
    <li>QUnit (от создателей jQuery)</li>
    <li>JsUnit (больше не поддерживается создателями)</li>
    <li>Jasmine (рекомендован создателями jsUnit)</li>
    <li>D.O.H</li>
</ul>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="testing-integration">Интеграционные тесты</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-testing-integration">

<ul class="list-point">
    <li><bg-define>Интеграционные тесты (сервисные / компонентные тесты)</bg-define> на соответствие требований проверяется интеграция модулей/компонентов, их взаимодействие между собой, а также интеграция подсистем в одну общую систему. Это может быть набор классов/методов/функций, модуль, подсистема или даже само приложение. Для интеграционного тестирования используются компоненты, уже проверенные с помощью модульного тестирования, которые группируются в множества. Данные множества проверяются в соответствии с планом тестирования, составленным для них, а объединяются они через свои интерфейсы. Так как модули соединяются между собой с помощью предусмотренных реализацией интерфейсов и в процессе тестирования у нас нет потребности рассматривать внутреннюю структуру компонентов</li>
    <li><u>Тесты черного ящика</u></li>

    <li><b>Цель</b>: проверка соответствия проектируемых единиц функциональным, приёмным и требованиям надежности</li>
    <li>Для автоматизации интеграционного тестирования применяются <u>системы непрерывной интеграции</u>. Автоматические интеграционные тесты выполняются сразу же после внесения изменений, что позволяет обнаруживать и устранять ошибки в короткие сроки</li>
</ul>

<h4>Подходы</h4>
<ul class="list-point">
    <li><u>Снизу вверх (Bottom Up Integration)</u> Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения</li>

    <li><u>Сверху вниз (Top Down Integration)</u> Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами</li>

    <li><u>Большой взрыв ("Big Bang" Integration)</u> Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования</li>
</ul>

<h4>Уровни интеграционного тестирования</h4>
<ul class="list-point">
    <li><u>Компонентный интеграционный уровень (Component Integration testing)</u> Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования</li>
    <li><u>Системный интеграционный уровень (System Integration Testing)</u> Проверяется взаимодействие между разными системами после проведения системного тестирования</li>
</ul>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="testing-e2e">E2E-тесты</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-testing-e2e">

<ul class="list-point">
    <li><bg-define>E2E (End-to-End) или сквозные тесты</bg-define> тестирование всей системы от начала до конца, тестирование пользовательских функций. Это включает в себя обеспечение того, чтобы все интегрированные части приложения функционировали и работали вместе, как ожидалось. E2E тесты моделируют реальные сценарии пользователя, в основном проверяя, как реальный пользователь будет использовать приложение</li>
    <li>Эмулируют реальную пользовательскую среду. В интернете это тесты, запущенные в браузере, имитирующие щелчки мышью и нажатия клавиш</li>

    <li><u>Тесты черного ящика</u></li>
    <li>Кроме того, эти тесты запускаются как можно чаще, чтобы обеспечить обратную связь и добавить понимания что наша система осталась рабочей</li>
    <li>Тесты E2E позволяют нам охватывать разделы приложения, которые не проверяются unit тестами и интеграционными тестами. Это связано с тем, что unit тесты и интеграционные тесты покрывают отдельные части приложения и тестируют изолированную часть функционала. Даже если эти части работают хорошо сами по себе, вы не уверены, будут ли они работать вместе. Таким образом, наличие набора E2E тестов поверх unit и интеграции позволяет нам тестировать все наше приложение</li>
</ul>

<ol class="list-num">
    <b>Примером</b> для E2E для регистрации пользователя. Тест включал бы:
    <li>Открытие сайта в браузере и поиск определенных элементов</li>
    <li>Затем заполнить несколько форм регистрации</li>
    <li>Затем убедитесь, что пользователь успешно создан</li>
</ol>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="testing-tdd">TDD</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-testing-tdd">

<ul class="list-point">
    <li><bg-define>Test-Diven Development, TDD (Разработка через тестирование)</bg-define> техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим стандартам</li>
    <li>Разработка через тестирование требует от разработчика создания автоматизированных модульных тестов, определяющих требования к коду непосредственно перед написанием самого кода. Тест содержит проверки условий, которые могут либо выполняться, либо нет. Когда они выполняются, говорят, что тест пройден. Прохождение теста подтверждает поведение, предполагаемое программистом</li>
    <li>Разработка через тестирование тесно связана с такими принципами KISS и YAGNI</li>

    <li><bg-define>Acceptance Test-driven Development, ATDD (разработка через приёмочное тестирование)</bg-define> критерии, описанные заказчиком, автоматизируются в приёмочные тесты, используемые потом в обычном процессе разработки через модульное тестирование (unit test-driven development, UTDD). При разработке через приёмочное тестирование, команда разработчиков сконцентрирована на чёткой задаче: удовлетворить приёмочные тесты, которые отражают соответствующие требования пользователя</li>
</ul>

<h4>Недостатки</h4>
<ul class="list-point">
    <li>Требуется больше времени на разработку и поддержку</li>
    <li>Существуют задачи, которые невозможно (по крайней мере, на текущий момент) решить только при помощи тестов. В частности, TDD не позволяет механически продемонстрировать адекватность разработанного кода в области безопасности данных и взаимодействия между процессами</li>
    <li>Разработку через тестирование сложно применять в тех случаях, когда для тестирования необходимо прохождение функциональных тестов. Примерами может быть: разработка интерфейсов пользователя, программ, работающих с базами данных, а также того, что зависит от специфической конфигурации сети</li> 
</ul>

<!------------------------------------------------------>
<h3>Цикл разработки через тестирование</h3>
<!------------------------------------------------------>

<img src="img/js/tdd1.png" width="500px" class="center">

<ol class="list-num">
    <li><u>Добавление теста</u> При разработке через тестирование, добавление каждой новой функциональности (англ. feature) в программу начинается с написания теста. Неизбежно этот тест не будет проходить, поскольку соответствующий код ещё не написан. Чтобы написать тест, разработчик должен чётко понимать предъявляемые к новой возможности требования. Для этого рассматриваются возможные сценарии использования и пользовательские истории. Новые требования могут также повлечь изменение существующих тестов</li>
    <li><u>Запуск всех тестов: убедиться, что новые тесты не проходят</u></li>
    <li><u>Написать код</u> На этом этапе пишется новый код так, что тест будет проходить</li>
    <li><u>Запуск всех тестов: убедиться, что все тесты проходят</u></li>
    <li><u>Рефакторинг</u></li>
    <li><u>Повторить цикл</u> Шаги следует делать небольшими, от 1 до 10 изменений между запусками тестов</li>
</ol>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="testing-bdd">BDD</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-testing-bdd">

<ul class="list-point">
    <li><bg-define>Behavior-Driven Development, BDD (Разработка через поведение)</bg-define> - методология разработки программного обеспечения, являющаяся ответвлением от методологии разработки через тестирование (TDD) в том смысле, что перед тем как написать какой-либо тест необходимо сначала описать желаемый результат от добавляемой функциональности на предметно-ориентированном языке. После того как это будет проделано, конструкции этого языка переводятся специалистами или специальным программным обеспечением в описание теста</li>

    <li><b>Идея</b>: совмещение в процессе разработки чисто технических интересов и интересов бизнеса, позволяя тем самым управляющему персоналу и программистам говорить на одном языке. Для общения между этими группами персонала используется предметно-ориентированный язык, основу которого представляют конструкции из естественного языка, понятные неспециалисту, обычно выражающие поведение программного продукта и ожидаемые результаты</li>
    <li>Считается, что данный подход эффективен, когда предметная область, в которой работает программный продукт, описывается очень комплексно</li>

    <li><u>Jasmine</u> - реализация на JavaScript</li>
</ul>

<h4>BDD фокусируется на следующих вопросах</h4>
<ol class="list-num">
    <li>С чего начинается процесс</li>
    <li>Что нужно тестировать, а что нет</li>
    <li>Сколько проверок должно быть совершено за один раз</li>
    <li>Что можно назвать проверкой</li>
    <li>Как понять, почему тест не прошёл</li>
</ol>

<h4>Принципы</h4>
<ol class="list-num">
    Тесты для некоторой единицы программного обеспечения должны быть описаны с точки зрения желаемого (имеет ценность для бизнеса) поведения программируемого устройства. Описание желаемого поведения даётся с помощью спецификации поведения (Behavioral Specification). Спецификация поведения строится в полуформальной форме. Структура
    <li><u>Заголовок (Title)</u> - описание бизнес-цели</li>
    <li><u>Описание (Narrative)</u> раскрыты следующие вопросы:<br>
    - Кто является заинтересованным лицом данной истории<br>
    - Что входит в состав данной истории<br>
    - Какую ценность данная история предоставляет для бизнеса
    </li>
    <li><u>Сценарии (Scenarios)</u> может быть один и более сценариев, каждый из которых раскрывает одну из ситуаций поведения пользователя, тем самым конкретизируя описание спецификации. Каждый сценарий обычно строится по одной и той же схеме:<br>
    - Начальные условия (одно или несколько)<br>
    - Событие, которое инициирует начало этого сценария<br>
    - Ожидаемый результат или результаты<br>
    </li>
</ol>

</div>

<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h1>Deployment</h1>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="deployment-software">Software Deployment</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-deployment-software">

<ul class="list-point">
    <li><bg-define>Software Deployment (Развёртывание ПО)</bg-define> - все действия, которые делают программную систему готовой к использованию. Данный процесс является частью жизненного цикла программного обеспечения</li>
    <li>В целом процесс развертывания состоит из нескольких взаимосвязанных действий с возможными переходами между ними. Эта активность может происходить как со стороны производителя, так и со стороны потребителя. Поскольку каждая программная система является уникальной, трудно предсказать все процессы и процедуры во время развертывания. Поэтому «развертывание» можно трактовать как общий процесс, соответствующий определенным требованиям и характеристикам. Развертывание может осуществляться программистом и в процессе разработки программного обеспечения</li>
</ul> 

<h4>Действия при развертывании</h4>
<ol class="list-num">
    <li>Выпуск</li>
    <li>Установка и активация</li>
    <li>Деактивация</li>
    <li>Адаптация</li>
    <li>Обновление</li>
    <li>Встройка</li>
    <li>Отслеживание версий</li>
    <li>Удаление</li>
    <li>Изъятие из обращения</li>
</ol>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="deployment-continuous">Continuous Deployment</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-deployment-continuous">

<ul class="list-point">
    <li><bg-define>Continuous Integration (Непрерывная интеграция)</bg-define> - короткоживущие функциональные ветки, команда сливает их с основной веткой разработки по несколько раз в день, процессы сборки и тестирования полностью автоматизированы, результат имеем в пределах 10 минут; развертывание выполняется вручную</li>
    <li><bg-define>Continuous Delivery (Непрерывная доставка)</bg-define> автоматизируется CI + весь процесс релиза ПО. Может состоять из нескольких этапов. Развертывание в продакшен выполняется вручную</li>
    <li><bg-define>Continuous Deployment (Непрерывное развертывание)</bg-define> CI + CD + полностью автоматизированное развертывание в продакшен</li>
</ul>

<ul class="list-point">
    <li><bg-define>Continuous Deployment (Непрерывное развертывание)</bg-define> - располагается «на уровень выше» непрерывной доставки. В данном случае все изменения, вносимые в исходный код, автоматически развертываются в продакшен, без явной отмашки от разработчика. Как правило, задача разработчика сводится к проверке запроса на включение (pull request) от коллеги и к информированию команды о результатах всех важных событий</li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="deployment-ci">Continuous Integration</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-deployment-ci">

<ul class="list-point">
    <li><bg-define>Continuous Integration, CI (непрерывная интеграция)</bg-define> - практика разработки программного обеспечения, которая заключается в постоянном слиянии рабочих копий в общую основную ветвь разработки (до нескольких раз в день) и выполнении частых автоматизированных сборок проекта для скорейшего выявления потенциальных дефектов и решения интеграционных проблем</li>
    <li>В обычном проекте, где над разными частями системы разработчики трудятся независимо, стадия интеграции является заключительной. Она может непредсказуемо задержать окончание работ. Переход к непрерывной интеграции позволяет снизить трудоёмкость интеграции и сделать её более предсказуемой за счёт наиболее раннего обнаружения и устранения ошибок и противоречий, но основным преимуществом является сокращение стоимости исправления дефекта, за счёт раннего его выявления</li>

    <li><bg-define>Continuous Integration System (CIS)</bg-define> - системы непрерывной интеграции применяются для автоматизации интеграционного тестирования</li>
    <li>Автоматические интеграционные тесты выполняются сразу же после внесения изменений, что позволяет обнаруживать и устранять ошибки в короткие сроки</li>
</ul> 

<h4>Задачи службы</h4>
<ol class="list-num">
    Для организации процесса непрерывной интеграции на выделенном сервере запускается служба, в задачи которой входят
    <li>Получение исходного кода из репозитория</li>
    <li>Сборка проекта</li>
    <li>Выполнение тестов</li>
    <li>Развёртывание готового проекта</li>
    <li>Отправка отчетов</li>
</ol>

<h4>Сборка</h4>
<ul class="list-point">
    Локальная сборка может осуществляться по внешнему запросу, по расписанию, по факту обновления репозитория и по другим критериям
    <li><u>Сборки по расписанию (Daily Build - ежедневная сборка)</u> как правило, проводятся в нерабочее время, ночью (Nightly Build), планируются таким образом, чтобы к началу очередного рабочего дня были готовы результаты тестирования</li>
    <li>Для различия дополнительно вводится система нумерации сборок — обычно, каждая сборка нумеруется натуральным числом, которое увеличивается с каждой новой сборкой. Исходные тексты и другие исходные данные при взятии их из репозитория системы контроля версий помечаются номером сборки. Благодаря этому, точно такая же сборка может быть точно воспроизведена в будущем — достаточно взять исходные данные по нужной метке и запустить процесс снова. Это даёт возможность повторно выпускать даже очень старые версии программы с небольшими исправлениями</li>
</ul>

<h4>Плюсы</h4>
<ul class="list-point">
    <li>проблемы интеграции выявляются и исправляются быстро, что оказывается дешевле</li>
    <li>немедленный прогон модульных тестов для свежих изменений</li>
    <li>постоянное наличие текущей стабильной версии вместе с продуктами сборок — для тестирования, демонстрации</li>
    <li>немедленный эффект от неполного или неработающего кода приучает разработчиков к работе в итеративном режиме с более коротким циклом</li>
</ul>

<h4>Минусы</h4>
<ul class="list-point">
    <li>значительные затраты на поддержку работы непрерывной интеграции</li>
    <li>необходимость в дополнительных вычислительных ресурсах под нужды непрерывной интеграции</li>
</ul>

<h4>Принцип действия</h4>
<ol class="list-num">
    <li>CIS производит мониторинг системы контроля версий</li>
    <li>При изменении исходных кодов в репозитории производится обновление локального хранилища</li>
    <li>Выполняются необходимые проверки и модульные тесты</li>
    <li>Исходные коды компилируются в готовые выполняемые модули</li>
    <li>Выполняются тесты интеграционного уровня</li>
    <li>Генерируется отчет о тестировании</li>
</ol>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="deployment-cd">Continuous Delivery</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-deployment-cd">
    
<ul class="list-point">
    <li><bg-define>Continuous Delivery, CD (Непрерывная поставка/доставка)</bg-define> - подход к разработке программного обеспечения, при котором все изменения, включая новые функции, изменения конфигурации, исправления ошибок и эксперименты — поставляются пользователям максимально быстро и безопасно</li>
    <li><b>Идея</b>: выполнять CI, плюс автоматически готовить и вести релиз к продакшену. Как правило, в процессе непрерывной доставки требуется выполнять вручную как минимум один этап: одобрить развертывание в продакшен и запустить его</li>
    <li>На протяжении всего процесса непрерывной доставки, мы постоянно получаем обратную связь</li>
    <li>Автоматизируя большинство операций, таких как развертывание, настройки окружения, тестирование, мы сокращаем время поставки новой функциональности</li>
    <li>Позволяет нам доставлять ценность пользователям, небольшими, но частыми партиями. Это позволяет нам как можно скорее получать обратную связь от пользователей, проверять большее количество гипотез и поставлять действительно ценное программное обеспечение</li>
</ul>

<h4>Процесс</h4>
<ol class="list-num">
    <li>[CI] Разработчик отправляет свои изменения в систему контроля версии</li>
    <li>[CI] На сервере сборки начинается процесс сборки поступивших изменений</li>
    <li>[CI] Запускаются Юнит-тесты</li>
    <li>Собранный пакет, после успешной интеграции, выкладывается на тестовый сервер</li>
    <li>Заинтересованные лица, получают уведомления о выкладке новой версии ПО на тестовую площадку. Начинается вторая фаза тестирования, запускаются интеграционные, ручные, приёмочные, UI тесты</li>
    <li>После успешного прохождения предыдущих шагов, мы имеем готовый к публикации пакет, новой версии ПО</li>
</ol>


</div>




</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
