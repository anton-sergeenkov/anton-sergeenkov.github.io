<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>

	<div class="theme">Парадигмы программирования</div>
    <a href="#paradigms">Парадигмы</a>
    <a href="#paradigms-imper">1. Императивное</a>
    <a href="#paradigms-decl">2. Декларативное</a>
    <a href="#paradigms-func">3. Функциональное</a>
    <a href="#paradigms-oop">4. Объектно-ориентированное</a>
    <a href="#composition">Композиция</a>
    <a href="#currying">Каррирование</a>
    
    <div class="theme">Методологии разработки</div>
    <a href="#method-waterfall">Waterfall</a>
    <a href="#method-agile">Agile</a>
    <a href="#method-scrum">Scrum</a>
    <a href="#method-kanban">Kanban</a>

    <div class="theme">Прочее</div>
    <a href="#web-applications">Виды веб приложений</a>
    <a href="#design">Эволюция веб-дизайна</a>
    <a href="#framework">Фреймворки</a>
    <a href="#pattern">Паттерны проектирования</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms">Парадигмы программирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms">
<ol class="list-num">
    <li>Императивное (C, C++, Java)</li>
    <li>Декларативное (HTML, SQL)</li>
    <li>Структурное (Pascal, C)</li>
    <li>Функциональное (F#, Lisp, Erlang, Scala)</li>
    <li>Логическое</li>
    <li>Объектно-ориентированное (С#, Java)</li>
    <li>Аспектно-ориентированное</li>
</ol>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-imper">Императивное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-imper">

<ul class="list-point">
    <li><bg-define>Императивное программирование</bg-define> В исходном коде программы записываются инструкции (команды), которые выполняются последовательно</li>
</ul>

<b class="margin-top">Используется</b>
<ol class="list-num">
    <li>Именованные переменные</li>
    <li>Операторы присваивания</li>
    <li>Составные выражения</li>
    <li>Подпрограммы</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает как решить задачу (явное указание всех шагов)</li>
    <li>Изменение состояния (переменных)</li>
    <li>При вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию состояния переменных</li>
</ol>

<pre><code class="js">
function double (arr) {
    let results = []
    for (let i = 0; i < arr.length; i++){
        results.push(arr[i] * 2)
    }
    return results
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-decl">Декларативное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-decl">

<ul class="list-point">
    <li><bg-define>Декларативное программирование</bg-define></li>
</ul>

<b class="margin-top">Не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает что должно быть сделано</li>
    <li>Неизменяемость</li>
    <li>Многие декларативные подходы имеют определённый слой императивных абстракций</li>
    <li>Код является контекстно-независимым - его можно использовать в любой программе без изменений</li>
</ol>

<pre><code class="js">
function double (arr) {
    return arr.map((item) => item * 2)
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-func">Функциональное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-func">

<ul class="list-point">
    <li><bg-define>Функциональное программирование</bg-define> - последовательный вызов набора функций</li>
    <li>Процесс вычисления трактуется как вычисление значений функций в математическом понимании</li>
    <li>Специфические возможности по работе с функциями: передача функций другим функциям в качестве аргументов и возврат функций из других функций</li>
    <li>Предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций</li>
    <li>Описывает математические отношения между данными и целью</li>
    <li>Один из видов декларативного программрования</li>
    <li>Нужно что-то посчитать, но функция которая это считает возвращает не результат, а рецепт для вычисления результата, т.е. возвращает функцию, которая посчитает результат</li>
    <li>Методы для функционального программирования в JavaScript: arr.map, arr.forEach, arr.filter, arr.sort, arr.concat, arr.join, arr.reduce, arr.reduceRight, Object.assign, Object.keys()</li>
</ul>

<b class="margin-top">Что не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>При вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных</li>
    <li>То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций</li>
    <li>Не нужно описывать шаги, нужно определить функцию, выполнить функции последовательно и в результате выполнения набор функций будет получен результат</li>
    <li>Разделение функций и данных</li>
</ol>

<b class="margin-top">Концепции</b>
<ol class="list-num">
    <li><bg-define>Чистые функции</bg-define> (pure functions) - функция, которая при одинаковых аргументах всегда возвращает одни и те же значения и не имеет видимых побочных эффектов (side effects) ввода-вывода и памяти. Зависят только от своих параметров и возвращают только свой результат. Не влияют на состояние программы</li>
    <ul class="list-point">
        <b>Условия</b>
        <li><u>Детерменированная</u> - для одного и того же набора входных значений возвращает одинаковый результат</li>
        <li><u>Без побочных эффектов</u> В императивных языках некоторые функции в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывая их обработчики. Они называются функциями с побочными эффектами</li>
        <li>Для замены циклов в JS можно использовать map и reduce</li>
    </ul>

    <li><bg-define>Функции высшего порядка</bg-define> - функция принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата</li>

    <li><bg-define>Каррирование функций</bg-define> - все функции могут быть от одного аргумента. Преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному</li>

    <li><bg-define>Рекурсия</bg-define> В функциональных языках цикл обычно реализуется в виде рекурсии. Рекурсивные функции вызывают сами себя, позволяя операции выполняться снова и снова</li>

    <li><bg-define>Лямбда-исчисление</bg-define> - механизм «анонимных функций» - callback-функций, которые можно определить прямо в том месте, где они используются, и которые имеют доступ к локальным переменным текущей функции</li>

    <li><bg-define>Иммутабельность</bg-define> - свойство объектов не изменяться (н-р строка. строку нельзя поменять на месте, для изменения нужно создать новую строку). Принцип иммутабельности в ФП должен применяется для другими страктурами данных (списки, словари). Иммутабельный список - список в который нельзя добавить / удалить элемент, можно только итерироваться по ним. Можно создать новый список который содежит все элементы +1, при этом старый остается валадным</li>

    <li><bg-define>Замыкания</bg-define></li>
</ol>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-oop">Объектно-ориентированное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-oop">

<ul class="list-point">
    <li><bg-define>Объектно-ориентированное программирование</bg-define> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования</li>
</ul>

<b class="margin-top">Механизмы</b>
<ol class="list-point">
    <li><bg-define>Инкапсуляция</bg-define> - механизм языка, позволяющий ограничить доступ одних компонентов программы к другим. Группировка свойств и методов в один класс</li>
    <li>Инкапсуляция – отделение и защита внутреннего интерфейса от внешнего</li>
    <li><u>Внутренний интерфейс</u> – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными»</li>
    <li><u>Внешний интерфейс</u> – это свойства и методы, доступные снаружи объекта, их называют «публичными»</li>
    <li>Мы обращаемся с объектами как с единой сущностью, а не как с набором отдельных полей и методов, тем самым скрываем и защищаем реализацию класса. Если клиентский код не знает ничего, кроме публичного интерфейса, он не может зависеть от деталей реализации</li>

    <li><bg-define>Наследование</bg-define> - описание нового класса на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом</li>
    <li>Наследование транзитивно: класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса (Object). Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию</li>
    
    <li><bg-define>Полиморфизм</bg-define> - возможность объектов с одинаковой спецификацией иметь различную реализацию. «Один интерфейс, множество реализаций». Переопеределение методов у дочерних классов. Возможность единообразно обрабатывать объекты с различной реализацией при условии наличия общего интерфейса</li>
    
    <li><bg-define>Абстракция</bg-define> - придание объекту характеристик, которые чётко определяют его концептуальные границы, отличая от всех других объектов. Основная идея состоит в том, чтобы отделить способ использования составных объектов данных от деталей их реализации в виде более простых объектов</li>
</ol>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="composition">Композиция</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-composition">

<ul class="list-point margin-top">
    <li><bg-define>Композиция и Агрегация</bg-define> - расширение функционала класса за счет "внедрения" других классов</li>
    <li>Об агрегировании также часто говорят как об «отношении принадлежности» по принципу «у машины есть корпус, колёса и двигатель»</li>

    <li><bg-define>Агрегация (агрегирование по ссылке)</bg-define> - отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое - нет</li>

    <li><bg-define>Композиция (агрегирование по значению)</bg-define> - более строгий вариант агрегирования, когда включаемый объект может существовать только как часть класса. Если класс будет уничтожен, то и включённый объект тоже будет уничтожен. Объект не может выйти за рамки своего класса. Объект будет создаваться внутри класса при создании класса и будет уничтожаться перед уничтожением родительского класса</li>

    <li><bg-define>Функциональная композиция</bg-define> - передача результа вызова одной функции в качестве аргумента другой функции</li>
</ul>

<pre><code class="light">
<img src="img/js/composition.png"></code></pre>

<ul class="list-point">
    <li><em>Агрегация</em>: <bg-code>профессора - факультеты</bg-code>, профессора остаются жить после разрушения факультета</li>
    <li><em>Композиция</em>: <bg-code>университет - факультеты</bg-code>, факультеты без университета уничтожаются</li>
</ul>

<h4>Наследование и композиция</h4>
<div class="container-flex"><div class="container-half">
<ul class="list-point">
    <li><b>Наследование</b> - когда класс-наследник имеет все поля и методы родительского класса, и, как правило, добавляет какой-то новый функционал или/и поля</li>
    <li><b>Наследование предполагает</b> принадлежность к какой-то общности (похожесть). Наследуются атрибуты, т.е. возможности, другого класса, при этом объектов непосредственно родительского класса не создается</li>
    <li><b>Минус наследования</b> влияние родительского класса на дочерние</li>
</ul>
</div><div class="container-half">
<ul class="list-point">
    <li><b>Ассоциация (частные случаи: Композиция и Агрегация)</b> – когда один класс включает в себя другой класс в качестве одного из полей</li>
    <li><b>Композиция предполагает</b> формирование целого из частей. При композиции класс-агрегатор создает объекты других классов</li>
</ul>
</div></div>

<h4>Dependency Injection</h4>
<pre><code class="js">
function makeCoffee(coffee) {}
function produceCoffee() {
    return { iCoffee:true }
}
function barista(makeCoffee, produceCoffee) {
    let coffee = makeCoffee(produceCoffee());
}
barista(makeCoffee, produceCoffee);
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="currying">Каррирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-currying">

<ul class="list-point">
    <li><bg-define>Каррирование / Карринг (Currying)</bg-define> - в функциональном программирование - это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму <u>замыканий</u>, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат.
    <li>При каррировании число вложенных функций равно числу аргументов исходной функции. Каждая из этих функций ожидает собственный аргумент. Если функция аргументов не принимает, или принимает лишь один аргумент, то каррировать её нельзя</li>

    <li><bg-define>Частичное применение функций (Partial Function Application)</bg-define> - функцию преобразуют в другую функцию, обладающую меньшим числом аргументов. Некоторые аргументы такой функции оказываются зафиксированными (для них задаются значения по умолчанию</li>

    <li>Каррирование и преобразования функций реализуются в JavaScript благодаря замыканиям и тому, что функции в JS являются объектами первого класса (их можно передавать в качестве аргументов другим функциям, возвращать из них, присваивать переменным)</li>
</ul>

<!------------------------------------------------------>
<h3>Каррирование</h3>
<!------------------------------------------------------>
<h4>Пример 1</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
// исходная функция
function multiply(a, b, c) {
    return a * b * c;
}
multiply(1,2,3); // 6
<br><br><br><br><br><br><br><br>
</code></pre></div><div class="container-half"><pre><code class="js">
// каррирование
function multiply(a) {
    return (b) => {
        return (c) => {
            return a * b * c
        }
    }
}
log(multiply(1)(2)(3)) // 6

//const mul1 = multiply(1);
//const mul2 = mul1(2);
//const result = mul2(3);
//log(result); // 6
</code></pre></div></div>

<h4>Пример 2</h4>
<pre><code class="js">
function add(x){
    return function() {
        return x + y;
    }
}
inc = add(1);
console.log(inc(15));   // 16
console.log(add(8)(7)); // 15
</code></pre>

<!------------------------------------------------------>
<h3>Частичное применение функций</h3>
<!------------------------------------------------------>
<pre><code class="js">
function volume(l) {
    return (w, h) => {
        return l * w * h
    }
}
</code></pre>

<div class="container-flex"><div class="container-half"><pre><code class="js">
// вариант использования 1
const hV = volume(70);
hV(203,142);
hV(220,122);
hV(120,123);
</code></pre></div><div class="container-half"><pre><code class="js">
// вариант использования 2
volume(70)(90,30);
volume(70)(390,320);
volume(70)(940,340);
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Частичная функция через bind</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Вызов <u>bind</u> позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз</li>
    <li>Если в bind указаны аргументы - они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове</li>
</ul>

<pre><code class="html">
<a href="js.html#methods-this-bind" target="_blank">[Local] bind()</a>
</code></pre>

<pre><code class="js">
function mul(a, b) {
    return a * b;
};

// double умножает только на два
var double = mul.bind(null, 2); // контекст фиксируем null, он не используется

console.log( double(3) ); // = mul(2, 3) = 6
console.log( double(4) ); // = mul(2, 4) = 8
console.log( double(5) ); // = mul(2, 5) = 10
</code></pre>

<ul class="list-point">
    <li>При вызове double будет передавать свои аргументы исходной функции mul после тех, которые указаны в bind, то есть в данном случае после зафиксированного первого аргумента 2</li>
    <li>"double" является «частичной функцией» (partial function) от mul</li>
    <li>При помощи bind мы можем получить из функции её «частный вариант» как самостоятельную функцию</li>
</ul>

</div>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- Методологии разработки -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-waterfall">Waterfall</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-waterfall">

<ul class="list-point">
    <li>Каскадная модель (waterfall model) - модель процесса разработки программного обеспечения, в которой процесс разработки выглядит как поток, последовательно проходящий фазы анализа требований, проектирования, реализации, тестирования, интеграции и поддержки</li>
    <li>Переход от одной фазы к другой происходит только после полного и успешного завершения предыдущей</li>
</ul>

<ul class="list-num">
    <b>Шаги</b>
    <li><u>Определение требований</u> - список требований к ПО</li>
    <li><u>Проектирование</u> - создаются документы, подробно описывающие для программистов способ и план реализации указанных требований</li>
    <li><u>Конструирование</u> (также «реализация» либо «кодирование»)</li>
    <li><u>Воплощение</u> - интеграция отдельных компонентов, разрабатываемых различными командами программистов</li>
    <li><u>Тестирование и отладка</u> (также «верификация»)</li>
    <li><u>Инсталляция</u></li>
    <li><u>Поддержка</u></li>
</ul>


</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-agile">Agile</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-agile">

<ul class="list-point">
    <li></li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-scrum">Scrum</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-scrum">

<ul class="list-point">
    <li></li>
</ul>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-kanban">Kanban</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-kanban">

<ul class="list-point">
    <li></li>
</ul>

</div>






<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- OTHER -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-applications">Виды веб приложений</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><bg-define>SSR</bg-define> - Server-Side Rendering (рендеринг на стороне сервера)</li>
    <li><bg-define>SPA</bg-define> - Single-Page Application (одностраничное приложение)</li>
    <li><bg-define>PWA</bg-define> - Progressive Web App (прогрессивное веб-приложение)</li>
    <li>Стандартные HTML страницы</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="design">Эволюция веб-дизайна</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre>
<code class="js">
1990-2000  Нет дизайна
2000-2010  Скевоморфизм
2010-2013  Flat Design  
2014-2017  Material Design
2018-....  Fluent Design
</code>
</pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="framework">Фреймворки (особенности)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- структура приложения 
- паттерны проектирования
- строгая структура (модульность) приложения
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern">Шаблоны проектирования (ММС...)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- MVC (модель вид контроллер)
- MVP (модель вид представитель)
- MVVM (модель вид модель представления)
</code></pre>

<pre><code class="plaintext">
<em>MVC</em>
<em>model</em>      - бизнес-логика (просчитывание данных, операций)
<em>view</em>       - видимая часть
<em>controller</em> - берет данные из view и передает в model (запускает model)
</code></pre>




</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
