<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>

	<div class="theme">Парадигмы программирования</div>
    <a href="#paradigms">Парадигмы</a>
    <a href="#paradigms-imper">1. Императивное</a>
    <a href="#paradigms-decl">2. Декларативное</a>
    <a href="#paradigms-func">3. Функциональное</a>
    <a href="#paradigms-oop">4. Объектно-ориентированное</a>
    <a href="#composition">Композиция</a>
    
    <div class="theme">Прочее</div>
    <a href="#web-applications">Виды веб приложений</a>
    <a href="#design">Эволюция веб-дизайна</a>
    <a href="#framework">Фреймворки</a>
    <a href="#pattern">Паттерны проектирования</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms">Парадигмы программирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-num">
    <li>Императивное (C, C++, Java)</li>
    <li>Декларативное (HTML, SQL)</li>
    <li>Структурное (Pascal, C)</li>
    <li>Функциональное (F#, Lisp, Erlang, Scala)</li>
    <li>Логическое</li>
    <li>Объектно-ориентированное (С#, Java)</li>
    <li>Аспектно-ориентированное</li>
</ol>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-imper">Императивное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><bg-define>Императивное программирование</bg-define> В исходном коде программы записываются инструкции (команды), которые выполняются последовательно</li>
</ul>

<b class="margin-top">Используется</b>
<ol class="list-num">
    <li>Именованные переменные</li>
    <li>Операторы присваивания</li>
    <li>Составные выражения</li>
    <li>Подпрограммы</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает как решить задачу (явное указание всех шагов)</li>
    <li>Изменение состояния (переменных)</li>
    <li>При вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию состояния переменных</li>
</ol>

<pre><code class="js">
function double (arr) {
    let results = []
    for (let i = 0; i < arr.length; i++){
        results.push(arr[i] * 2)
    }
    return results
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-decl">Декларативное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><bg-define>Декларативное программирование</bg-define></li>
</ul>

<b class="margin-top">Не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает что должно быть сделано</li>
    <li>Неизменяемость</li>
    <li>Многие декларативные подходы имеют определённый слой императивных абстракций</li>
    <li>Код является контекстно-независимым - его можно использовать в любой программе без изменений</li>
</ol>

<pre><code class="js">
function double (arr) {
    return arr.map((item) => item * 2)
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-func">Функциональное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><bg-define>Функциональное программирование</bg-define> - последовательный вызов набора функций</li>
    <li>Процесс вычисления трактуется как вычисление значений функций в математическом понимании</li>
    <li>Специфические возможности по работе с функциями: передача функций другим функциям в качестве аргументов и возврат функций из других функций</li>
    <li>Предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций</li>
    <li>Описывает математические отношения между данными и целью</li>
    <li>Один из видов декларативного программрования</li>
    <li>Нужно что-то посчитать, но функция которая это считает возвращает не результат, а рецепт для вычисления результата, т.е. возвращает функцию, которая посчитает результат</li>
</ul>

<b class="margin-top">Что не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>При вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных</li>
    <li>То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций</li>
    <li>Не нужно описывать шаги, нужно определить функцию, выполнить функции последовательно и в результате выполнения набор функций будет получен результат</li>
    <li>Разделение функций и данных</li>
</ol>

<b class="margin-top">Концепции</b>
<ol class="list-num">
    <li><bg-define>Чистые функции</bg-define> (pure functions) - функция, которая при одинаковых аргументах всегда возвращает одни и те же значения и не имеет видимых побочных эффектов (side effects) ввода-вывода и памяти. Зависят только от своих параметров и возвращают только свой результат. Не влияют на состояние программы</li>
    <ul class="list-point">
        <b>Условия</b>
        <li><u>Детерменированная</u> - для одного и того же набора входных значений возвращает одинаковый результат</li>
        <li><u>Без побочных эффектов</u> В императивных языках некоторые функции в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывая их обработчики. Они называются функциями с побочными эффектами</li>
        <li>Для замены циклов в JS можно использовать map и reduce</li>
    </ul>

    <li><bg-define>Функции высшего порядка</bg-define> - функция принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата</li>

    <li><bg-define>Каррирование функций</bg-define> - все функции могут быть от одного аргумента. Преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному</li>

    <li><bg-define>Рекурсия</bg-define> В функциональных языках цикл обычно реализуется в виде рекурсии. Рекурсивные функции вызывают сами себя, позволяя операции выполняться снова и снова</li>

    <li><bg-define>Лямбда-исчисление</bg-define> - механизм «анонимных функций» - callback-функций, которые можно определить прямо в том месте, где они используются, и которые имеют доступ к локальным переменным текущей функции</li>

    <li><bg-define>Иммутабельность</bg-define> - свойство объектов не изменяться (н-р строка. строку нельзя поменять на месте, для изменения нужно создать новую строку). Принцип иммутабельности в ФП должен применяется для другими страктурами данных (списки, словари). Иммутабельный список - список в который нельзя добавить / удалить элемент, можно только итерироваться по ним. Можно создать новый список который содежит все элементы +1, при этом старый остается валадным</li>

    <li><bg-define>Замыкания</bg-define></li>
</ol>

<h4>Каррирование</h4>
<pre><code class="js">
function add(x){
    return function() {
        return x + y;
    }
}
inc = add(1);
console.log(inc(15));   // 16
console.log(add(8)(7)); // 15

function add(x){
    return function() {
        return function() {
            return function() {
                return x + y;
            }
        }
    }
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-oop">Объектно-ориентированное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
    <li><bg-define>Объектно-ориентированное программирование</bg-define> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования</li>
</ul>

<b class="margin-top">Механизмы</b>
<ol class="list-num">
    <li><bg-define>Инкапсуляция</bg-define> - механизм языка, позволяющий ограничить доступ одних компонентов программы к другим. Группировка свойств и методов в один класс</li>
    <li>Инкапсуляция – отделение и защита внутреннего интерфейса от внешнего</li>
    <li>Внутренний интерфейс – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными»</li>
    <li>Внешний интерфейс – это свойства и методы, доступные снаружи объекта, их называют «публичными»</li>

    <li><bg-define>Наследование</bg-define> - класс может наследовать данные и функциональность некоторого существующего типа, способствуя повторному использованию компонентов</li>
    
    <li><bg-define>Полиморфизм</bg-define> - возможность объектов с одинаковой спецификацией иметь различную реализацию. «Один интерфейс, множество реализаций». Переопеределение методов у дочерних классов</li>
    
    <li><bg-define>Абстракция</bg-define> - придание объекту характеристик, которые чётко определяют его концептуальные границы, отличая от всех других объектов. Основная идея состоит в том, чтобы отделить способ использования составных объектов данных от деталей их реализации в виде более простых объектов</li>
</ol>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="composition">Композиция</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    Противопоставление наследованию
</ul>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-applications">Виды веб приложений</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><bg-define>SSR</bg-define> - Server-Side Rendering (рендеринг на стороне сервера)</li>
    <li><bg-define>SPA</bg-define> - Single-Page Application (одностраничное приложение)</li>
    <li><bg-define>PWA</bg-define> - Progressive Web App (прогрессивное веб-приложение)</li>
    <li>Стандартные HTML страницы</li>
</ul>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="design">Эволюция веб-дизайна</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre>
<code class="js">
1990-2000  Нет дизайна
2000-2010  Скевоморфизм
2010-2013  Flat Design  
2014-2017  Material Design
2018-....  Fluent Design
</code>
</pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="framework">Фреймворки (особенности)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- структура приложения 
- паттерны проектирования
- строгая структура (модульность) приложения
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern">Шаблоны проектирования (ММС...)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- MVC (модель вид контроллер)
- MVP (модель вид представитель)
- MVVM (модель вид модель представления)
</code></pre>

<pre><code class="plaintext">
<em>MVC</em>
<em>model</em>      - бизнес-логика (просчитывание данных, операций)
<em>view</em>       - видимая часть
<em>controller</em> - берет данные из view и передает в model (запускает model)
</code></pre>













</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
