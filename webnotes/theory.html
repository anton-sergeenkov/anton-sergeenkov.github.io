<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>

	<div class="theme">Парадигмы программирования</div>
    <a href="#paradigms">Парадигмы</a>
    <a href="#paradigms-imper">1. Императивное</a>
    <a href="#paradigms-decl">2. Декларативное</a>
    <a href="#paradigms-func">3. Функциональное</a>
    <a href="#paradigms-oop">4. Объектно-ориентированное</a>
    <a href="#composition">Композиция</a>
    <a href="#currying">Каррирование</a>
    
    <div class="theme">Принципы программирования</div>
    <a href="#solid">SOLID</a>
    <a href="#dry">DRY</a>
    <a href="#kiss">KISS</a>
    <a href="#yagni">YAGNI</a>
    
    <div class="theme">Методологии разработки</div>
    <a href="#method-dev">Методологии разработки</a>
    <a href="#method-waterfall">Waterfall</a>
    <a href="#method-agile">Agile / Scrum / Kanban</a>
    <a href="#estimation">Эстимация</a>

    <div class="theme">Прочее</div>
    <a href="#web-applications">Виды веб приложений</a>
    <a href="#design">Эволюция веб-дизайна</a>
    <a href="#framework">Фреймворки</a>
    <a href="#pattern">Паттерны проектирования</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms">Парадигмы программирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms">
<ol class="list-num">
    <li>Императивное (C, C++, Java)</li>
    <li>Декларативное (HTML, SQL)</li>
    <li>Структурное (Pascal, C)</li>
    <li>Функциональное (F#, Lisp, Erlang, Scala)</li>
    <li>Логическое</li>
    <li>Объектно-ориентированное (С#, Java)</li>
    <li>Аспектно-ориентированное</li>
</ol>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-imper">Императивное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-imper">

<ul class="list-point">
    <li><bg-define>Императивное программирование</bg-define> В исходном коде программы записываются инструкции (команды), которые выполняются последовательно</li>
</ul>

<b class="margin-top">Используется</b>
<ol class="list-num">
    <li>Именованные переменные</li>
    <li>Операторы присваивания</li>
    <li>Составные выражения</li>
    <li>Подпрограммы</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает как решить задачу (явное указание всех шагов)</li>
    <li>Изменение состояния (переменных)</li>
    <li>При вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию состояния переменных</li>
</ol>

<pre><code class="js">
function double (arr) {
    let results = []
    for (let i = 0; i < arr.length; i++){
        results.push(arr[i] * 2)
    }
    return results
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-decl">Декларативное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-decl">

<ul class="list-point">
    <li><bg-define>Декларативное программирование</bg-define></li>
</ul>

<b class="margin-top">Не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>Описывает что должно быть сделано</li>
    <li>Неизменяемость</li>
    <li>Многие декларативные подходы имеют определённый слой императивных абстракций</li>
    <li>Код является контекстно-независимым - его можно использовать в любой программе без изменений</li>
</ol>

<pre><code class="js">
function double (arr) {
    return arr.map((item) => item * 2)
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-func">Функциональное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-func">

<ul class="list-point">
    <li><bg-define>Функциональное программирование</bg-define> - последовательный вызов набора функций</li>
    <li>Процесс вычисления трактуется как вычисление значений функций в математическом понимании</li>
    <li>Специфические возможности по работе с функциями: передача функций другим функциям в качестве аргументов и возврат функций из других функций</li>
    <li>Предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций</li>
    <li>Описывает математические отношения между данными и целью</li>
    <li>Один из видов декларативного программрования</li>
    <li>Нужно что-то посчитать, но функция которая это считает возвращает не результат, а рецепт для вычисления результата, т.е. возвращает функцию, которая посчитает результат</li>
    <li>Методы для функционального программирования в JavaScript: arr.map, arr.forEach, arr.filter, arr.sort, arr.concat, arr.join, arr.reduce, arr.reduceRight, Object.assign, Object.keys()</li>
</ul>

<b class="margin-top">Что не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>При вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных</li>
    <li>То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций</li>
    <li>Не нужно описывать шаги, нужно определить функцию, выполнить функции последовательно и в результате выполнения набор функций будет получен результат</li>
    <li>Разделение функций и данных</li>
</ol>

<b class="margin-top">Концепции</b>
<ol class="list-num">
    <li><bg-define>Чистые функции</bg-define> (pure functions) - функция, которая при одинаковых аргументах всегда возвращает одни и те же значения и не имеет видимых побочных эффектов (side effects) ввода-вывода и памяти. Зависят только от своих параметров и возвращают только свой результат. Не влияют на состояние программы</li>
    <ul class="list-point">
        <b>Условия</b>
        <li><u>Детерменированная</u> - для одного и того же набора входных значений возвращает одинаковый результат</li>
        <li><u>Без побочных эффектов</u> В императивных языках некоторые функции в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывая их обработчики. Они называются функциями с побочными эффектами</li>
        <li>Для замены циклов в JS можно использовать map и reduce</li>
    </ul>

    <li><bg-define>Функции высшего порядка</bg-define> - функция принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата</li>

    <li><bg-define>Каррирование функций</bg-define> - все функции могут быть от одного аргумента. Преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному</li>

    <li><bg-define>Рекурсия</bg-define> В функциональных языках цикл обычно реализуется в виде рекурсии. Рекурсивные функции вызывают сами себя, позволяя операции выполняться снова и снова</li>

    <li><bg-define>Лямбда-исчисление</bg-define> - механизм «анонимных функций» - callback-функций, которые можно определить прямо в том месте, где они используются, и которые имеют доступ к локальным переменным текущей функции</li>

    <li><bg-define>Иммутабельность</bg-define> - свойство объектов не изменяться (н-р строка. строку нельзя поменять на месте, для изменения нужно создать новую строку). Принцип иммутабельности в ФП должен применяется для другими страктурами данных (списки, словари). Иммутабельный список - список в который нельзя добавить / удалить элемент, можно только итерироваться по ним. Можно создать новый список который содежит все элементы +1, при этом старый остается валадным</li>

    <li><bg-define>Замыкания</bg-define></li>
</ol>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="paradigms-oop">Объектно-ориентированное программирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-paradigms-oop">

<ul class="list-point">
    <li><bg-define>Объектно-ориентированное программирование</bg-define> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования</li>
</ul>

<b class="margin-top">Механизмы</b>
<ol class="list-point">
    <li><bg-define>Инкапсуляция</bg-define> - механизм языка, позволяющий ограничить доступ одних компонентов программы к другим. Группировка свойств и методов в один класс</li>
    <li>Инкапсуляция – отделение и защита внутреннего интерфейса от внешнего</li>
    <li><u>Внутренний интерфейс</u> – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными»</li>
    <li><u>Внешний интерфейс</u> – это свойства и методы, доступные снаружи объекта, их называют «публичными»</li>
    <li>Мы обращаемся с объектами как с единой сущностью, а не как с набором отдельных полей и методов, тем самым скрываем и защищаем реализацию класса. Если клиентский код не знает ничего, кроме публичного интерфейса, он не может зависеть от деталей реализации</li>

    <li><bg-define>Наследование</bg-define> - описание нового класса на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом</li>
    <li>Наследование транзитивно: класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса (Object). Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию</li>
    
    <li><bg-define>Полиморфизм</bg-define> - возможность объектов с одинаковой спецификацией иметь различную реализацию. «Один интерфейс, множество реализаций». Переопеределение методов у дочерних классов. Возможность единообразно обрабатывать объекты с различной реализацией при условии наличия общего интерфейса</li>
    
    <li><bg-define>Абстракция</bg-define> позволяет работать с объектами не вдаваясь в особенности их реализации</li>
    <li>Инкапсуляция помогает реализовать абстракцию</li>
    <li>Абстракция это способ представления объекта в программе</li>    
</ol>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="composition">Композиция</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-composition">

<ul class="list-point margin-top">
    <li><bg-define>Композиция и Агрегация</bg-define> - расширение функционала класса за счет "внедрения" других классов</li>
    <li>Об агрегировании также часто говорят как об «отношении принадлежности» по принципу «у машины есть корпус, колёса и двигатель»</li>

    <li><bg-define>Агрегация (агрегирование по ссылке)</bg-define> - отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое - нет</li>

    <li><bg-define>Композиция (агрегирование по значению)</bg-define> - более строгий вариант агрегирования, когда включаемый объект может существовать только как часть класса. Если класс будет уничтожен, то и включённый объект тоже будет уничтожен. Объект не может выйти за рамки своего класса. Объект будет создаваться внутри класса при создании класса и будет уничтожаться перед уничтожением родительского класса</li>

    <li><bg-define>Функциональная композиция</bg-define> - передача результа вызова одной функции в качестве аргумента другой функции</li>
</ul>

<pre><code class="light">
<img src="img/js/composition.png"></code></pre>

<ul class="list-point">
    <li><em>Агрегация</em>: <bg-code>профессора - факультеты</bg-code>, профессора остаются жить после разрушения факультета</li>
    <li><em>Композиция</em>: <bg-code>университет - факультеты</bg-code>, факультеты без университета уничтожаются</li>
</ul>

<h4>Наследование и композиция</h4>
<div class="container-flex"><div class="container-half">
<ul class="list-point">
    <li><b>Наследование</b> - когда класс-наследник имеет все поля и методы родительского класса, и, как правило, добавляет какой-то новый функционал или/и поля</li>
    <li><b>Наследование предполагает</b> принадлежность к какой-то общности (похожесть). Наследуются атрибуты, т.е. возможности, другого класса, при этом объектов непосредственно родительского класса не создается</li>
    <li><b>Минус наследования</b> влияние родительского класса на дочерние</li>
</ul>
</div><div class="container-half">
<ul class="list-point">
    <li><b>Ассоциация (частные случаи: Композиция и Агрегация)</b> – когда один класс включает в себя другой класс в качестве одного из полей</li>
    <li><b>Композиция предполагает</b> формирование целого из частей. При композиции класс-агрегатор создает объекты других классов</li>
</ul>
</div></div>

<h4>Dependency Injection</h4>
<pre><code class="js">
function makeCoffee(coffee) {}
function produceCoffee() {
    return { iCoffee:true }
}
function barista(makeCoffee, produceCoffee) {
    let coffee = makeCoffee(produceCoffee());
}
barista(makeCoffee, produceCoffee);
</code></pre>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="currying">Каррирование</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-currying">

<ul class="list-point">
    <li><bg-define>Каррирование / Карринг (Currying)</bg-define> - в функциональном программирование - это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму <u>замыканий</u>, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат.
    <li>При каррировании число вложенных функций равно числу аргументов исходной функции. Каждая из этих функций ожидает собственный аргумент. Если функция аргументов не принимает, или принимает лишь один аргумент, то каррировать её нельзя</li>

    <li><bg-define>Частичное применение функций (Partial Function Application)</bg-define> - функцию преобразуют в другую функцию, обладающую меньшим числом аргументов. Некоторые аргументы такой функции оказываются зафиксированными (для них задаются значения по умолчанию</li>

    <li>Каррирование и преобразования функций реализуются в JavaScript благодаря замыканиям и тому, что функции в JS являются объектами первого класса (их можно передавать в качестве аргументов другим функциям, возвращать из них, присваивать переменным)</li>
</ul>

<!------------------------------------------------------>
<h3>Каррирование</h3>
<!------------------------------------------------------>
<h4>Пример 1</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
// исходная функция
function multiply(a, b, c) {
    return a * b * c;
}
multiply(1,2,3); // 6
<br><br><br><br><br><br><br><br>
</code></pre></div><div class="container-half"><pre><code class="js">
// каррирование
function multiply(a) {
    return (b) => {
        return (c) => {
            return a * b * c
        }
    }
}
log(multiply(1)(2)(3)) // 6

//const mul1 = multiply(1);
//const mul2 = mul1(2);
//const result = mul2(3);
//log(result); // 6
</code></pre></div></div>

<h4>Пример 2</h4>
<pre><code class="js">
function add(x){
    return function() {
        return x + y;
    }
}
inc = add(1);
console.log(inc(15));   // 16
console.log(add(8)(7)); // 15
</code></pre>

<!------------------------------------------------------>
<h3>Частичное применение функций</h3>
<!------------------------------------------------------>
<pre><code class="js">
function volume(l) {
    return (w, h) => {
        return l * w * h
    }
}
</code></pre>

<div class="container-flex"><div class="container-half"><pre><code class="js">
// вариант использования 1
const hV = volume(70);
hV(203,142);
hV(220,122);
hV(120,123);
</code></pre></div><div class="container-half"><pre><code class="js">
// вариант использования 2
volume(70)(90,30);
volume(70)(390,320);
volume(70)(940,340);
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Частичная функция через bind</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Вызов <u>bind</u> позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз</li>
    <li>Если в bind указаны аргументы - они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове</li>
</ul>

<pre><code class="html">
<a href="js.html#methods-this-bind" target="_blank">[Local] bind()</a>
</code></pre>

<pre><code class="js">
function mul(a, b) {
    return a * b;
};

// double умножает только на два
var double = mul.bind(null, 2); // контекст фиксируем null, он не используется

console.log( double(3) ); // = mul(2, 3) = 6
console.log( double(4) ); // = mul(2, 4) = 8
console.log( double(5) ); // = mul(2, 5) = 10
</code></pre>

<ul class="list-point">
    <li>При вызове double будет передавать свои аргументы исходной функции mul после тех, которые указаны в bind, то есть в данном случае после зафиксированного первого аргумента 2</li>
    <li>"double" является «частичной функцией» (partial function) от mul</li>
    <li>При помощи bind мы можем получить из функции её «частный вариант» как самостоятельную функцию</li>
</ul>

</div>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- Методологии разработки -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-dev">Методологии разработки</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-dev">

<ul class="list-point">
    <li><bg-define>Методология разработки</bg-define> - организация труда, включающая идеологические принципы, план, контроль над процессами, подход к сотрудникам</li>
</ul>

<ol class="list-num">
    <li><u>Waterfall</u> - традиционный подход</li>
    <li><u>RUP (Rational Unified Process)</u> - рациональный (итеративный подход). ПО выходит с уменьшенной функциональностью, чтобы занять нишу на рынке и противостоять конкурентам, после чего дорабатывается</li>
    <li><u>Agile</u> - общая методология гибкой разработки</li>
    <li><u>Crystal Clear</u> - подход с уравниванием разработчиков в коллективе. Каждая команда является набором людей с разным уровнем знаний, разными умениями и опытом</li>
    <li><u>Spiral</u> - спиральный метод. Раннее выявление и уменьшение проектных рисков</li>
    <li><u>DSDM (Dynamic Systems Development Model)</u> - динамическая модель. При планировании в самом начале невозможно понимать всех тонкостей разработки, поэтому весь процесс — исследовательская работа</li>
    <li><u>FDD (Feature Driven Development)</u> - методология, рассматривающая будущие изменения. Процесс для обеспечения масштабируемости и повторяемости, при этом поощряющий творчество и инновации</li>
    <li><u>JAD (Joint Application Development)</u> - ориентированный на пользователя подход. Максимальная занятость в разработке конечного пользователя</li>
    <li><u>RAD (Rapid Application Development)</u> - модель быстрой разработки</li>
    <li><u>Scrum</u> - концепция работы в условиях сорванных сроков и идеологического кризиса</li>
    <li><u>XP (Extreme Programming)</u> - экстремальная разработка в динамической среде</li>
    <li><u>LD (Lean Development)</u> - метод, предполагающий бережное отношение ко всем участникам процесса</li>
</ol>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-waterfall">Waterfall</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-waterfall">

<ul class="list-point">
    <li><bg-define>Waterfall Model (каскадная модель)</bg-define> - модель процесса разработки программного обеспечения, в которой процесс разработки выглядит как поток, последовательно проходящий фазы.</li>
    <li>Весь процесс является жестким и линейным, имеет четкие цели для каждого этапа, новая фаза начинается по завершению предыдущей, нет возврата назад</li>
</ul>

<h4>Шаги</h4>
<ol class="list-num">
    <li><u>Требования</u> - список требований к ПО. В первую очередь, анализируются требования и пожелания заказчика, затем это проецируется на возможности компании и состояние рынка. В результате получается некий документ, где описывается, что должно делать ПО, но не как и с помощью каких инструментов</li>
    <li><u>Проектирование</u> -  согласовывается логика работы ПО. Здесь всё ещё не принимаются конкретные решения по реализации, но уже описывается функционирование всех разделов приложения. На выходе разработчики уже представляют, сколько по времени и кадровому составу может занять проект. Создаются документы, подробно описывающие для программистов способ и план реализации указанных требований</li>
    <li><u>Конструирование</u> (также «реализация» либо «кодирование») - речь идёт о конкретных инструментах для реализации идей: согласовываются требования к дизайну, языки программирования, уровни данных, сервисы и т. д. Формируется внешний облик готового продукта</li>
    <li><u>Воплощение</u> - исполнительский этап, на который, как правило, приходится большая часть разработки. Если классическая модель допускает свободное взаимодействие с предыдущими этапами, то на практике допускается лишь внесение незначительных правок в «Конструирование»</li>
    <li><u>Тестирование и отладка</u> (также «верификация»)</li>
    <li><u>Инсталляция</u></li>
    <li><u>Поддержка</u></li>
</ol>

<h4>Преимущества</h4>
<ul class="list-point">
    <li><u>Устойчива к изменению кадрового состава</u> Благодаря подробному документированию смена работников практически не влияет на сроки исполнения проекта</li>
    <li><u>Дисциплина</u> Модель заставляет разработчиков, вовлечённых в проект быть дисциплинированными, оставаться в рамках намеченного плана. При необходимости в общей модели добавляется орган управления, ответственный за принятие решений, исполнители же обязаны работать в рамках системы</li>
    <li><u>Гибкость на ранних этапах</u> Изменения в первых трёх фазах могут быть сделаны немедленно и с минимальными усилиями, поскольку они не подкреплены кодом</li>
    <li><u>Ориентация на сроки и финансы</u> Благодаря тому, что каждый этап полностью очерчивает контур будущего ПО, все разработчики понимают свою роль, границы работы и сроки исполнения. Это позволяет оперировать реальными цифрами перед заказчиком</li>
</ul>

<h4>Недостатки</h4>
<ul class="list-point">
    <li><u>Неадаптивная структура ПО</u> На первых этапах модель водопада может быть гибкой, но если на фазе тестирования выявляются проблемы в общей структуре – это влечёт за собой последствия в виде сорванных сроков и даже отказов заказчика. Таким образом, возрастает роль руководителей и ответственных разработчиков, с уровнем компетентности которых в любой компании часто бывают проблемы</li>
    <li><u>Игнорирует конечного пользователя</u> Чем ниже продвигается процесс в водопаде, тем меньше в нём роль заказчика. Внесение каких-либо изменений в функциональность ПО запускает всю цепочку этапов заново, поэтому продукты полученные по каскадной модели далеки от ориентации на массового пользователя</li>
    <li><u>Позднее тестирование</u> Более гибкие методологии используют тестирование в качестве фундаментальной операции, происходящей непрерывно. Waterfall же допускает низкую квалификацию сотрудников на каждом этапе и плохое качество исполнения, ведь при запоздалом тестировании проблемы невозможно решить фундаментально</li>
</ul>

<h4>Итого</h4>
<ol class="list-num">
    <span>Каскадная методология – хорошее решение точки зрения сроков и отчётности, но очень слабое в плане качества. Поэтому сегодня её рекомендуется использовать только в трёх случаях:</span>
    <li>При ориентации ПО на заказчика, требующего прозрачность работ и исполнение в назначенные сроки</li>
    <li>При наличии в штате руководителей соответствующей квалификации</li>
    <li>При исполнении проекта, не имеющего конкуренции на рынке</li>
</ol>

</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-agile">Agile / Scrum / Kanban</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-method-agile">

<!------------------------------------------------------>
<h3>Agile</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Agile (agile software development)</bg-define> методология - семейство «гибких» подходов к разработке ПО, основынная на итеративном проходе по scope задач в условиях работы разных специалистов с целью выпуска работоспособного продукта</li>

    <li>Agile предполагает, что при реализации проекта не нужно опираться только на заранее созданные подробные планы. Важно ориентироваться на постоянно меняющиеся условия внешней и внутренней среды и учитывать обратную связь от заказчиков и пользователей. Это поощряет разработчиков и инженеров экспериментировать и искать новые решения, не ограничивая себя жесткими рамками и стандартами</li>

    <li>К отдельным agile-подходам относятся <u>scrum</u> и <u>kanban</u></li>

    <li><bg-define>Product Owner (PO)</bg-define> - Product Manager в терминологии Scrum</li>
    <li><bg-define>Product Manager</bg-define> - отвечает за продукт. Несет ответственность за рождение новых продуктов, их подготовленность к выходу на рынок, ценовые характеристики, его целевую аудиторию и прочие характеристики</li>
    <li><bg-define>Project Manager (PM)</bg-define> - отвечает за процесс. Координатор. Отвечает за соблюдение сроков и мониторинг всех зависимостей между командами</li>

    <li><bg-define>Program Manager</bg-define></li>
    <li><bg-define>Product Lead / Product Director / Group Product Manager</bg-define> - начальник над несколькими PM. Отвечает за несколько продуктов одной ветки и определяет цели на более высоком уровне</li>
</ul>

<h4>Agile-манифест</h4>
<ul class="list-point">
    <li>Люди и взаимодействие важнее процессов и инструментов</li>
    <li>Работающий продукт важнее исчерпывающей документации</li>
    <li>Сотрудничество с заказчиком важнее согласования условий контракта. Устные договоренности между сотрудниками, между заказчиком и исполнителем важнее всего, что отражено в планах, договорах и техническом задании</li>
    <li>Готовность к изменениям важнее следования первоначальному плану </li>
</ul>


<pre><code class="html">
<a href="http://agilemanifesto.org/iso/ru/principles.html" target="_blank">[agilemanifesto] Принципы</a>
</code></pre>

<!------------------------------------------------------>
<h3>Scrum</h3>
<!------------------------------------------------------>
<pre><code class="html">
<a href="https://www.youtube.com/watch?v=cDvZaXzQezs" target="_blank">[YouTube] Agile и Scrum на пальцах</a>
</code></pre>

<ul class="list-point">
    <li><bg-define>Scrum</bg-define> «подход структуры». Гибкая методология по разработке ПО. Команда из 5-9 разработчиков</li>
    <li>Scrum-подход делит рабочий процесс на равные <u>спринты</u> – обычно это периоды от недели до месяца, в зависимости от проекта и команды. Перед спринтом формулируются задачи на данный спринт, в конце – обсуждаются  результаты, а команда начинает новый спринт. Спринты очень удобно сравнивать между собой, что позволяет управлять эффективностью работы</li>
    <li><b>Принципы:</b><br> 
        - не стремитесь сразу получить сложный продукт<br>
        - минимально жизнеспособный продукт можно показать пользователям и определить какие доработки нужны а какие нет</li>
    <li><b>Плюсы:</b><br> 
    - детальное задание необязательно<br>
    - разработка под контролем<br> 
    - цена оказывается ниже ввиду рисков закладываемых подрядчиком в фиксированную стоимость</li>
</ul>

<h4>Команда</h4>
<ol class="list-num">
    <li>Универсальная команда специалистов</li>
    <li><bg-define>Product Owner</bg-define> - Product Manager в терминологии Scrum. Соединяет команду с заказчиком. Человек, который управляет созданием продукта и отвечает за то, что получится в результате</li>
    <li><bg-define>Scrum Master (бизнес-аналитик)</bg-define> - помогает Product Owner организовать бизнес-процесс: проводит общие собрания, решает бытовые проблемы, мотивирует команду и следит за соблюдением Scrum-подхода. Переводит задачи написанные обычным язвком в задачи понятные разработчикам по средствам <u>Backlog</u></li>
</ol>

<h4>Backlog</h4>
<ol class="list-num">
    <li><bg-define>Backlog</bg-define> - приоритезированный список задач, куда записываются пожелания заказчика. Создают Scrum Master и Product Owner</li>
    <ol class="list-num">
        <li><u>Эпик</u> - большая часть функционала которая может быть завершена в рамках разработки (н-р: разработка личного кабинета пользователя). Эпики делятся на Сторисы</li>
        <li><u>Стори/Сторисы</u> - более мелкая часть функционала которая еще не может случить для задач разработки (н-р: кабинет пользователя может состоять из функционала по авторизации, по рассылке уведомлений и т.д.). Сторис отвечает на вопрос "Я как пользователь хочу ... (н-р: иметь возможность делать посты)"</li>
        <li><u>Таски/Задачи</u> - идут к разработчикам</li>
    </ol>
</ol>

<h4>Собрания</h4>
<ol class="list-num">
    <li><bg-define>Planning Poker / Scrum Poker</bg-define> - разбиение Сторис на задачи и оценка сложности задач в Story Points</li>
    <ul class="list-point">
        <li><bg-define>Story Points</bg-define> - оценивание с точки зрения сложности. Определяются эталонные задачи (кто за сколько врмени выполнял задачу). Отталкиваясь от эталонный оцениваются все остальные Сторис</li>
        <li>У всех на собрании есть карты на которых выставолены числа, соответствующие кол-ву Story Points. Для более честной оценки все взакрытую при объявлении задачи выбирают свое количество Story Points и после показывают что поставили</li>
    </ul>

    <li>Сессия временной оценки задач. Назначаются ответственные за задачи. По итогу есть список задач который помещается в <u>список TODO</u> - задач на разработку. Задачи оцененные, приориетизированные, есть назначенные разработчики. После этого спринт считается запущенным</li>

    <li><bg-define>Daily Scrum Meeting/Stand-Up</bg-define> - 15 минут ежедневно проводятся встречи проектной команды, где контролируется ход работ. Каждый участник команды рассказывает про свой текущий статус: - Что делал вчера? - Что буду делать сегодня? - Какие проблемы есть?</li>
</ol>

<h4>Cпринт</h4>
<ul class="list-point">
    <li><u>Спринт</u> - участок времени за который разработчики выполняют фиксированый набор задач, оцененных на <u>Planning Poker</u> и на оценочной сессии. В конце спринта всегда должен быть работоспособный кусок продукта либо сам продукт, который можно показать заказчику</li>
    <li>Начало: после Planning Poker и Сессии оценки</li>
    <li>Длина спринтов одинаковая и обычно выбираются кратными неделям: 1,2,4 недели</li>
    <li>В рамках спринта задача меняется свои статусы. Изначально после оценки задчи попадают в статус TODO</li>
    <li>По итогу спринта - продукт который можно показать клиенту. Каждый разработчки презентует те задачи, которые он сделал. Заказчик видим конкретный результат, вносит коррективы</li>
</ul>

<h4>Доска</h4>
<ol class="list-num">
    <li><bg-code>STORY / BACKLOG</bg-code> </li>
    <li><bg-code>TODO</bg-code> # после оценки</li>
    <li><bg-code>REJECTED</bg-code> # от тестировщика в случае нахождения багов</li>
    <li><bg-code>IN PROGRESS</bg-code> разработчик берет в разработку</li>
    <li><bg-code>REVIEW / TESTING / TO VERIFY</bg-code> # разработчик закончил</li>
    <li><bg-code>DONE</bg-code> переводит тестировщик</li>
</ol>

<ul class="list-point">
    <li>Разработчик берет задачу из REJECTED, переносит в IN PROGRESS и старается в приоритетном прядке ее закрыть</li>
    <Когда все задачи, относящиеся к Сторис завершены, считается что Стирис закрыта></li>
</ul>

<h4>Ретроспектива</h4>
<ul class="list-point">
    <li>После review ретроспектива - собрание на которым команда отвечает на вопросы <br>
    - "Что было сделано хорошо в Спринте"<br>
    - "Что мы делали плохо в спринте"<br>
    - "Что нужно сделать чтобы в следующем спринте работать лучше"</li>
    <li>Каждый в команде по очереди высказывается и предлагает варианты улучения процесса</li>
    <li>К концу ретроспективы список элементов на улучшение, который к концу следующего спринта смотрится и проверяется что улучшили, а что нет</li>
    <li>Оценивается эффуктивность команды. Берутся стори которые были закрыты и суммируются их Story Points. Если команда закрыра 30 Story Points, значит в следующем спринте можно запланировать 30 Story Points</li>
</ul>

<!------------------------------------------------------>
<h3>Kanban</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><bg-define>Kanban</bg-define> - «подход баланса». Гибкий метод управления проектами, целью которого является повышение производительности труда в командах</li>
    <li>Главная идея Kanban - визуализация рабочего процесса. Она заключается в создании физической панели, на которой можно наглядно отмечать прогресс</li>

    <li>Задача – сбалансировать разных специалистов внутри команды и избежать ситуации, когда дизайнеры работают сутками, а разработчики жалуются на отсутствие новых задач</li>
    <li>Вся команда едина – в kanban нет ролей владельца продукта и scrum-мастера. Бизнес-процесс делится не на универсальные спринты, а на стадии выполнения конкретных задач: «Планируется», «Разрабатывается», «Тестируется», «Завершено» и др.</li>
    <li>Главный показатель эффективности в kanban – это среднее время прохождения задачи по доске. Задача прошла быстро – команда работала продуктивно и слаженно. Задача затянулась – надо думать, на каком этапе и почему возникли задержки и чью работу надо оптимизировать</li>
    <li>Для визуализации agile-подходов используют доски: физические и электронные. Они позволяют сделать рабочий процесс открытым и понятным для всех специалистов, что важно, когда у команды нет одного формального руководителя</li>

    <li>В основе концепции лежат «спринты»</li>

    <li><bg-define>Спринт</bg-define> - короткая итерация, строго ограниченная по времени (обычно 2−4 недели). В это время минимизируется длительность совещаний, но увеличивается их частота (они называются «схватками»). Благодаря этому контроль за выполнением становится более гибким, а разработчики быстрее реагируют на возникающие проблемы. Традиционное планирование отходит на второй план, его место занимает журнал спринтов</li>
</ul>


</div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="estimation">Эстимация</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-estimation">

<ul class="list-point">
    <li>Эстимация - оценки сроков и стоимости проекта</li>
</ul>

<h4>1. Экспертная оценка (Expert Judgement)</h4>
<ul class="list-point">
    <li>Формирование оценки с привлечением экспертов в данной требуемой области</li>
    <li>Эксперты выдвигают свои предположения по поводу оценки (сроков или стоимости). После этого можно усреднить все предложения, а можно постараться прийти к единому решению в ходе дискуссии</li>
</ul>

<h4>2. Метод оценки по 3 точкам (Three Point Estimation)</h4>
<ul class="list-point">
    <li>Сначала определяются <u>оптимистичная (O = Optimistic)</u>, <u>пессимистичная (P = Pessimistic)</u> и <u>реалистичная\средняя (M = Middle)</u> оценки</li>
    <li>Значения <u>P, M и O</u> определяются экспертно (в часах, днях, $). Для этого задаются вопросы типа: <br> «сколько времени займет проект, если все пойдет хорошо?», <br> «каким может быть самый негативный сценарий и сколько на него потребуется времени\усилий?» и т.д.</li>
    <li>Далее полученные значения P, M и O подставляются в формулу: <u>(O + 4 M + P) / 6</u></li>
    <li>Результат расчета дает усредненную оценку. Такая формула позволяет с одной стороны учесть возможные позитивные и негативные сценарии, а с другой – «сгладить» их влияние и получить более реальное значение оценки</li>
</ul>

<h4>3. Стоимость качества (Cost of Quality)</h4>
<ul class="list-point">
    <li>Сначала оценивается время / бюджет только на разработку функционала, без учета ошибок и проблем, как если бы у нас сразу получалось идеальное ПО без дефектов. А далее оценивается сколько дополнительного времени и бюджета потребуется на работу с ошибками и проблемами в реальности, чтобы приблизить ПО к тому самому «идеальному» состоянию</li>
    <li>При оценке затрат на обеспечение качества ПО можно проанализировать и учесть такие области:
    <ul class="list-point">
        <li>расходы на активности по предотвращению дефектов</li>
        <li>стоимость тестирования</li>
        <li>исправление внутренних ошибок</li>
        <li>исправление внешних проблем по интеграции</li>
        <li>затраты на установку и настройку ПО с учетом реальной среды и данных</li>
    </ul>
    </li>
</ul>

<h4>4. Оценка по аналогиям (Analogous Estimation)</h4>
<ul class="list-point">
    <li>Можно опираться на прошлый опыт решения подобных задач или проектов</li>
    <li>Чтобы найти знакомые или похожие на предыдущий опыт задачи можно сделать декомпозицию</li>
</ul>

<h4>5. Оценка по параметрам и моделирование (Parametric Model)</h4>
<ul class="list-point">
    <li>Один из самых точных и гибких методов оценки. Его суть в том, чтобы построить некую параметризированную модель-прогноз взяв за основу прошлый опыт, имеющиеся данные и метрики, статистику</li>
    <li>Фактически строится специальная математическая модель, которая позволяет отслеживать как меняется итоговая оценка в зависимости от исходных параметров</li>
</ul>

<h4>6. Оценка от частного к общему (Bottom-up Estimation)</h4>
<ul class="list-point">
    <li>Метод похож на экспертную оценку, только в данном случае прогноз делается не для всего проекта в целом, а отдельно для составляющих его задач. Как это выглядит: мы собираем экспертное мнение, например, у специалистов по анализу, разработке, тестированию, поддержке ПО. Суммируем их оценки вместе, добавляем к ним затраты времени на взаимодействие и формируем общий прогноз</li>
    <li>Другими словами, мы собираем оценку по частям, узнавая сколько необходимо времени каждому из участников процесса разработки ПО и сводим все воедино с учетом дополнительных рисков</li>
</ul>

</div>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- Принципы программирования -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="solid">SOLID</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-solid">
<ul class="list-point">
    <li><bg-define>SOLID</bg-define> (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency inversion) - пять основных принципов ООП</li>
    <li>При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени</li>
    <li><b>Цель принципов</b>: способствуют изменениям; легко понимаемы; повторно используемы</li>
</ul>

<h4>Принципы</h4>
<ul class="list-point">
    <li><bg-define>[S] SRP</bg-define> (The Single Responsibility Principle. Принцип единственной ответственности)</li>
    <li>Каждый класс выполняет лишь одну задачу/ответственность</li>

    <li class="margin-top"><bg-define>[O] OCP</bg-define> (The Open Closed Principle. Принцип открытости/закрытости)</li>
    <li>Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации</li>


    <li class="margin-top"><bg-define>[L] LSP</bg-define> (The Liskov Substitution Principle. Принцип подстановки Барбары Лисков)</li>
    <li>Если мы используем не базовый класс, а его наследника, то поведение программы не изменится. Поведение в методах-наследниках менять нельзя</li>
    <li>Наследующий класс должен дополнять, а не изменять базовый и не должен противоречить поведению, заданному базовым классом</li>
    <li>Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы</li>

    <li class="margin-top"><bg-define>[I] ISP</bg-define> (The Interface Segregation Principle. Принцип разделения интерфейса)</li>
    <li>Класс не должен содержать много методов. Нужно разделить методы на несколько классов</li>
    <li>Программные сущности не должны зависеть от методов, которые они не используют</li>
    <li>Слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют</li>
    <li>Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения</li>

    <li class="margin-top"><bg-define>[D] DIP</bg-define> (The Dependency Inversion Principle. Принцип инверсии зависимостей)</li>
    <li>Зависимость кода должна строиться от абстракции, а не от класса</li>
    <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций</li>
    <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций</li>
    <li>Зависимость на Абстракциях. Нет зависимости на что-то конкретное</li>
</ul>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="dry">DRY</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-dry">
<ul class="list-point">
    <li><bg-define>DRY</bg-define> (Don’t Repeat Yourself. Не повторяйся) - нацелен на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования</li>
    <li>Формулируется как: «Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы»</li>
    <li>Когда принцип DRY применяется успешно, изменение единственного элемента системы не требует внесения изменений в другие, логически не связанные элементы. Те элементы, которые логически связаны, изменяются предсказуемо и единообразно</li>
    <li>Нарушения принципа <u>DRY</u> называют <u>WET - «Write Everything Twice»</u> (Пиши всё по два раза) или <u>«We enjoy typing»</u> (Нам нравится печатать)</li>
</ul>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="kiss">KISS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-kiss">
<ul class="list-point">
    <li><bg-define>KISS</bg-define> («Keep it simple, stupid») - принцип утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются</li>
    <li>Принцип, запрещающий использование более сложных средств, чем необходимо</li>
</ul>

<h4>Принципы</h4>
<ul class="list-point">
    <li>Разбивайте задачу на множество более маленьких задач, каждая задача должна решаться одним или парой классов</li>
    <li>Сохраняйте ваши классы/методы маленькими. Каждый метод должен состоять не более чем из 30-40 строк. Каждый метод должен решать одну маленькую задачу, а не множество случаев</li>
</ul>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="yagni">YAGNI</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-yagni">
<ul class="list-point">
    <li><bg-define>YAGNI</bg-define> («You aren't gonna need it». «Вам это не понадобится») - процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, то есть отказ добавления функциональности, в которой нет непосредственной надобности</li>
</ul>

<h4>Последствия написание кода, который не нужно прямо сейчас</h4>
<ul class="list-point">
    <li>Тратится время на добавление, тестирование и улучшение необходимой функциональности</li>
    <li>Новые функции должны быть отлажены, документированы и сопровождаться</li>
    <li>Новая функциональность ограничивает то, что может быть сделано в будущем, - ненужные новые функции могут впоследствии помешать добавить новые нужные</li>
    <li>Пока новые функции действительно не нужны, трудно полностью предугадать, что они должны делать, и протестировать их. Если новые функции тщательно не протестированы, они могут неправильно работать, когда впоследствии понадобятся</li>
    <li>Это приводит к тому, что программное обеспечение становится более сложным</li>
    <li></li>
    <li></li>
</ul>

</div>



<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- OTHER -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-applications">Виды веб приложений</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><bg-define>SSR</bg-define> - Server-Side Rendering (рендеринг на стороне сервера)</li>
    <li><bg-define>SPA</bg-define> - Single-Page Application (одностраничное приложение)</li>
    <li><bg-define>PWA</bg-define> - Progressive Web App (прогрессивное веб-приложение)</li>
    <li>Стандартные HTML страницы</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="design">Эволюция веб-дизайна</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre>
<code class="js">
1990-2000  Нет дизайна
2000-2010  Скевоморфизм
2010-2013  Flat Design  
2014-2017  Material Design
2018-....  Fluent Design
</code>
</pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="framework">Фреймворки (особенности)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- структура приложения 
- паттерны проектирования
- строгая структура (модульность) приложения
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern">Шаблоны проектирования (ММС...)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
- MVC (модель вид контроллер)
- MVP (модель вид представитель)
- MVVM (модель вид модель представления)
</code></pre>

<pre><code class="plaintext">
<em>MVC</em>
<em>model</em>      - бизнес-логика (просчитывание данных, операций)
<em>view</em>       - видимая часть
<em>controller</em> - берет данные из view и передает в model (запускает model)
</code></pre>




</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
