<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>
	
	<div class="theme">Циклы и массивы</div>
	<a href="#cycle">Циклы</a>
	<a href="#cycle-array">Перебор массива</a>
	<a href="#array">Массивы</a>
	<a href="#array_obj">Массивы обьектов</a>

	<div class="theme">ES6</div>
	<a href="#map">Коллекции <bg-menu>Map</bg-menu> <bg-menu>WeakMap</bg-menu> (ES6)</a>
	<a href="#set">Коллекции <bg-menu>Set</bg-menu> <bg-menu>WeakSet</bg-menu> (ES6)</a>
	<a href="#spread">Оператор разворота</a>
	<a href="#destructive-array">Деструктивное присваивание array</a>
	<a href="#destructive-obj">Деструтивное присваивание object</a>
	<a href="#pattern">Шаблонные строки</a>
	<a href="#proxy">Proxy</a>
	<a href="#symbol">Symbol</a>
	<a href="#iterators">Iterators</a>
	
	<div class="theme">Асинхронный код</div>
	<a href="#collback">1. Collback Function</a>
	<a href="#promise">2. Promise (ES6)</a>
	<a href="#generators">3. Generators (ES6)</a>
	<a href="#async-func">4. Async Function (ES2017)</a>

	<div class="theme">AJAX</div>
	<a href="#ajax-request">Описание</a>
	<a href="#xmlhttprequest">1. XMLHttpRequest</a>
	<a href="#fetch">2. Fetch</a>
	<a href="#axios">3. Axios</a>
	<a href="#ajax-request-js">Request JS</a>
	<a href="#ajax-response-php">Response PHP</a>
	<a href="#client-server">Client-Server Architecture</a>
	<a href="#jsonp">JSONP</a>
	<a href="#cors">CORS</a>
	<a href="#websocket">WebSocket</a>
	<a href="#comet">Comet</a>

	<div class="theme">События</div>
	<a href="#actions-modal">Модель распространения событий</a>
	<a href="#actions">Назначение обработчиков событий</a>
	<a href="#actions-target">Делегирование событий</a>
	<a href="#actions-params">Передаваемый параметр (Event)</a>
	<a href="#actions-list">Список событий</a>
	<a href="#prevent">Отмена обычного поведения</a>
	<a href="#actions-samples">Примеры</a>

	<div class="theme">Basic I</div>
	<a href="#methods-this"><bg-menu>this</bg-menu> <bg-menu>call</bg-menu> <bg-menu>apply</bg-menu> <bg-menu>bind</bg-menu></a>
	<a href="#css"><bg-menu>classList</bg-menu> <bg-menu>style</bg-menu></a>
	<a href="#attribute"><bg-menu>attributes</bg-menu></a>
	<a href="#typeof"><bg-menu>typeof</bg-menu></a>
	<a href="#timeout"><bg-menu>setTimeout</bg-menu> <bg-menu>setInterval</bg-menu></a>
	<a href="#json"><bg-menu>JSON</bg-menu></a>
	<a href="#str">Строки</a>
	<a href="#number">Числа</a>
	<a href="#type">Типы данных</a>
	<a href="#select">Выборка элементов</a>
	<a href="#methods">Методы элементов страницы</a>
	<a href="#dom-element">DOM элементы</a>
	<a href="#form">Web Forms</a>
	
	<div class="theme">Модули</div>
	<a href="#module-system">Модульная система</a>
	<a href="#module-es6">Модули ES6</a>

	<div class="theme">Веб-компоненты</div>
	<a href="#web-components-theory">Теория</a>
	<a href="#web-components-virtual-dom">Virtual DOM</a>
	<a href="#web-components-shadow-dom">1. Shadow DOM</a>
	<a href="#web-components-template">2. HTML Templates</a>
	<a href="#web-components-custom-elements">3. Custom Elements</a>
	<a href="#web-components-imports">4. HTML Imports</a>

	<div class="theme">Client Storage</div>
	<a href="#data-storage"><bg-menu>localStorage</bg-menu> <bg-menu>sessionStorage</bg-menu></a>
	<a href="#data-db"><bg-menu>IndexedDB</bg-menu></a>
	<a href="#data-cookie"><bg-menu>cookie</bg-menu></a>

	<div class="theme">Advanced</div>
	<a href="#web-workers">Web Workers</a>
	<a href="#wrappers">Object Wrappers</a>
	<a href="#decorator">Декораторы</a>
	<a href="#architecture">Архитектура среды выполнения JS</a>
	<a href="#garbage-collection">Сборщик мусора</a>
	<a href="#regexr">Регулярные выражения</a>
	<a href="#let-const"><bg-menu>var</bg-menu> <bg-menu>let</bg-menu> <bg-menu>const</bg-menu></a>
	<a href="#eval"><bg-menu>eval</bg-menu></a>
	<a href="#notifications-api">Notifications API</a>
	<a href="#custom-properties-js">Custom Properties JS</a>

	<div class="theme">Window</div>
	<a href="#web-api">Web API</a>
	<a href="#document-open"><bg-menu>open</bg-menu> <bg-menu>location</bg-menu></a>
	<a href="#document-width"><bg-menu>innerWidth/Height</bg-menu> <bg-menu>clientWidth/Height</bg-menu></a>
	<a href="#document-media">Media queries</a>

	<div class="theme">Basic II</div>
	<a href="#math">Math</a>
	<a href="#operators">Операторы</a>
	<a href="#catch">Исключения</a>
	<a href="#date">Дата и время</a>
	<a href="#case">Условные операторы</a>
	<a href="#external-script">Асинхронные скрипты: defer/async</a>
	<a href="#comparison">Сравнение и логические значения</a>
	<a href="#console">Console</a>
	<a href="#method-chaining">Цепные вызовы методов</a>
	<a href="#chrome-dev-tools">Chrome DevTools</a>

	<div class="theme">Theory</div>
	<a href="#ecmascript">ECMAScript</a>
	<a href="#jsdoc">Синтаксис JSDoc</a>
	<a href="#strict-mode">Strict Mode</a>
	<a href="#dictionary">Словарь</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">


<h1>JavaScript</h1>

<pre><code class="js">
var element = document.getElementById('element');
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="spread">Оператор разворота (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
Позволяет разворачить элементы массива для передачи в качестве аргументов функций 
или в элементы другого массива
<h3>Массив</h3>
<pre><code class="js">
var staticLanguages = ['C', 'C++', 'Java'];
var dinamicLanguages = ['JavaScript', 'PHP', 'Ruby'];
var languages = [...staticLanguages, 'C#', ...dinamicLanguages, 'Python'];
// result: ['C', 'C++', 'Java', 'C#', 'JavaScript', 'PHP', 'Ruby']
</code></pre>

<h3>Функция</h3>
<pre><code class="js">
function add(x,y,z) {
	console.log(x + y + z);
}
var numbers = [1, 2, 3];
add(...numbers);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-modal">Модель распространения событий</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<img src="img/js/event.jpg" width="450px" class="center">
<ul class="list">
	<b>Стандартная модель событий (Распространение событий)</b>
	<li><bg-header>1. Event.CAPTURING_PHASE=1</bg-header> (перехват) - идет от родительского до целевого (html -> body -> button). Выполняется сразу после того, как происходит событие. Событие начинается на самом верхнем уровне, которым является либо объект <u>document</u>, либо объект <u>window</u> в зависимости от события. Отсюда оно опускается, проходя через тег <u>html</u> и через то, что находится в этом теге, до тех пор, пока не достигнет элемента, в пределах которого оно возникло</li>
	<li><bg-header>2. Event.AT_TARGET=2</bg-header> (целевой элемент захвата)</li>
	<li><bg-header>3. Event.BUBBLING_PAGE=3</bg-header> (всплытие). В её ходе повторяется тот же процесс, но наоборот. Всё начинается с элемента, который вызвал событие, оно «всплывает» до корневого элемента <u>html</u></li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions">Назначение обработчиков событий</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>1. Использование атрибута HTML</h3>
<!------------------------------------------------------>
<pre><code class="html">
&lt;button onclick="alert('action')"&gt;Action&lt;/button&gt;
&lt;button onclick="alert(&amp;quot;action&amp;quot;)"&gt;Использование двойных кавычек&lt;/button&gt;
&lt;button onclick="alert(this.innerHTML)"&gt;Вывести содержимое&lt;/button&gt;
&lt;button onclick="action()"&gt;Action&lt;/button&gt;
</code></pre>

<!------------------------------------------------------>
<h3>2. Использование свойства DOM-объекта</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Если обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство <u>onclick</u></li>
	<li>Обработчик хранится именно в <u>DOM-свойстве</u>, а атрибут – лишь один из способов его инициализации</li>
	<li>Так как <u>DOM-свойство</u> <u>onclick</u>, в итоге, одно, то назначить более одного обработчика так нельзя</li>
</ul>
<pre><code class="html">
&lt;button id="element"&gt;Action&lt;/button&gt;
element.onclick = function() {
	alert(1);
}
</code></pre>

<pre><code class="html">
&lt;button id="element"&gt;Action&lt;/button&gt;
element.onclick = action;
function action() {
	alert(1);
}
</code></pre>

<pre><code class="js">
// удаление обработчика
element.element = null;
</code></pre>

<!------------------------------------------------------>
<h3>3. addEventListener и removeEventListener</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Метод addEventListener позволяет добавлять несколько обработчиков на одно событие одного элемента</li>
	<li>Если функцию не сохранить где-либо, а просто передать в addEventListener, то потом получить её обратно, чтобы снять обработчик, будет невозможно</li>
	<li>Нет метода, который позволяет считать обработчики событий, назначенные через addEventListener</li>
</ul>

<pre><code class="js light">
<bg-methods>element.<em>addEventListener</em>(event, handler[, phase])
 element.<em>removeEventListener</em>(event, handler[, phase])</bg-methods> 
	<em>&#8226; event</em>   // имя события, например click
	<em>&#8226; handler</em> // ссылка на функцию, которую нужно поставить обработчиком
	<em>&#8226; phase</em>   // необязательный аргумент, «фаза», на которой обработчик должен сработать
</code></pre>

<pre><code class="html">
&lt;button id="element"&gt;Action&lt;/button&gt;
</code></pre>

<pre><code class="js">
function action() {
	alert(1);
}
var element = document.querySelector('#element');
element.<bg-code>addEventListener</bg-code>('click', action);
element.<bg-code>removeEventListener</bg-code>('click', action);
</code></pre>

<pre><code class="js">
// для удаления нужно передать именно ту функцию-обработчик которая была назначена
// так removeEventListener не сработает
// в removeEventListener передана не та же функция, а другая, с одинаковым кодом
element.addEventListener('click' ,   function() {alert('ok')});
element.removeEventListener('click', function() {alert('ok')});
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-target">Делегирование событий</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>Делегирование событий</bg-list> - техника, которая использует механизм всплытия событий. Добавляя прослушиватель к родительскому элементу, разработчик может наладить обработку событий для его потомков</li>
	<li>Внутри функции обратного вызова прослушивателя события целевой элемент события будет представлен параметром <u>target</u>, который можно использовать для принятия решения о дальнейших действиях. Например, атрибут этого параметра data может хранить идентификатор для доступа к свойствам объекта</li>
</ul>
<pre><code class="js">
parentEl.addEventListener('click', function(e) {
	if(e.target && e.target.nodeName == 'BUTTON') {
		// щелчок по кнопке
	} 
});
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-params">Передаваемый параметр (Event)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list">
	<li><bg-list>Event</bg-list> - объект созданный перед запуском события</li>
</ul>

<pre><code class="js">
var btn = document.getElementById('btn');

btn.addEventListener('click', getButton);

function getButton(e) {
	console.log(e.type);          // название события
	console.log(e.target);        // инициатор события
	console.log(e.currentTarget); // элемент на котором висит обработчик
	console.log(e.eventPhase);    // число, указывающее этап (Event.CAPTURING_PHASE=1, Event.AT_TARGET=2, Event.BUBBLING_PAGE=3)
	console.log(e.timeStamp);     // объект Date, указывающий, когда произошло событие
	console.log(e.bubbles);       // true если событие может всплывать по дереву элементов. события blur, focus, load, unload не всплывают
	console.log(e.cancelable);    // true если с этим событием связано действие по умолчанию и его можно отменить preventDefault

	e.preventDefault();           // отключение действия события по умолчанию
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-list">Список событий</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h4>События мыши</h4>
<ul class="list">
	<li><bg-list>click</bg-list> - одиночный клик левой кнопки мыши</li>
	<li><bg-list>contextmenu</bg-list> - одиночный клик правой кнопкой мыши</li>
	<li><bg-list>mouseover</bg-list> - наведение мыши</li>
	<li><bg-list>mousedown</bg-list> - нажатие кнопки мыши</li>
	<li><bg-list>mouseup</bg-list> - отпускание кнопки мыши</li>
	<li><bg-list>mousemove</bg-list> - передвижение мыши</li>

	<li><bg-list>mouseout</bg-list> - увод мыши</li>
	<li><bg-list>dblclick</bg-list> - двойной щелчек левой кнопки мыши</li>
</ul>

<h4>События на элементах управления</h4>
<ul class="list">
	<li><bg-list>submit</bg-list> - момент отправки формы обработчику (если кнопка типа "submit")</li>
	<li><bg-list>focus</bg-list> - момент получения фокуса объектом (работает и для ссылок)</li>

	<li><bg-list>blur</bg-list> - момент потери фокуса объектом (работает и для ссылок)</li>
	<li><bg-list>change</bg-list> - изменение объекта формы (поле, радиобаттон и т.д.)</li>
	<li><bg-list>reset</bg-list> - сброс формы (специальной кнопкой)</li>
</ul>

<h4>Клавиатурные события</h4>
<ul class="list">
	<li><bg-list>keydown</bg-list> - момент нажатия клавиши, до момента отпускания</li>
	<li><bg-list>keyup</bg-list> - момент отпускания клавиши</li>

	<li><bg-list>keypress</bg-list> - нажатие клавиши на клавиатуре</li>
</ul>

<h4>События документа</h4>
<ul class="list">
	<li><bg-list>DOMContentLoaded</bg-list> - возникает после окончательной загрузки и парсинга HTML-документа, не дожидаясь загрузки стилей, картинок и фреймов</li>

	<li><bg-list>load</bg-list> - возникает после полного окончания загрузки ресурса (всех картинок, стиле и прочего)</li>
	<li><bg-list>resize</bg-list> - изменение размеров окна браузера</li>
	<li><bg-list>scroll</bg-list> - прокрутка страницы</li>
	<li><bg-list>unload</bg-list> - уход со страницы</li>
</ul>

<h4>События CSS</h4>
<ul class="list">
	<li><bg-list>transitionend</bg-list> - когда CSS-анимация завершена</li>
</ul>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-samples">Обработчики событий (примеры)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
// полная загрузка страницы
window.onload = function() {
	//
}
</code></pre>

<pre><code class="bash red">
# использование значения keyCode событий - устаревшая практика
# и может не поддерживаться в новых браузерах
</code></pre>

<pre><code class="js">
// обработка нажатия кнопки и вывод ее кода
window.onkeydown = function(event) {
	console.log(event.keyCode);
}
</code></pre>

<pre><code class="js">
// отслеживание изменения hash
window.onhashchange = function() {
    var a = location.hash.slice(1);
}
</code></pre>

<pre><code class="js">
// click на элемент
element.onclick = function() {
	//
}
</code></pre>

<pre><code class="js">
// выбрать все input и повесить обработчик focus
var items = document.querySelectorAll('.item');

for(var i=0; i<=items.length-1; i++) {
	items[i].addEventListener('focus', function() {
		this.style.border = '2px solid blue';
	})
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="map">Коллекции Map и WeakMap (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-define>Map и WeakMap</bg-define> - позволяют хранить пары "ключ:значение"</li>
	<li>Отличие от объекта: ключ map может быть любого типа, а не только строки и символы как у объекта</li>
</ul>

<!------------------------------------------------------>
<h3>Коллекция Map</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Используется для трансформации массива</li>
	<li>Объект map, ассоциативный массив</li>
	<li>Нет литеральной формы, поэтому используется конструктор new</li>
	<li>Объект map в отличие от обычного объекта является перебираемым объектом, который можно пербирать в цикле for...of</li>
	<li>Можно использовать деструктуризацию, spread-операторы, Array.from и т.д. присущие итерируемому объекту</li>
	<li>Сохраняет первоначальный порядок элементов, в отличие от объекта</li>

	<b class="margin-top">Map удобнее объекта</b>
	<li>Если ключи являются динамическими, т.е. известны на этапе выполнения</li>
	<li>Если ключи могут быть разных типов</li>
	<li>Если пары "ключ:значение" часто добавляются/удаляются</li>
	<li>Если пары "ключ:значение" нужно перебирать</li>
</ul>

<!------------------------------------------------------>
<h3>Коллекция WeekMap</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<b>Отличия WeakMap от Map</b>
	<li>Ключом может быть только объект</li>
	<li>Нет метода clear(0</li>
	<li>Нет свойства size</li>
	<li>Не является итерируемым</li>
	<li>Если удаляется объект-ключ, то данные с этим ключом также удаляются из памяти</li>

	<b class="margin-top">Варианты использования WeakMap</b>
	<li>Кеширование вычисляемых значений. Если нужно значение на основе полей объекта, сохраняем его в WeekMap, а ключем делаем сам объект и когла оно повторно понадобится - берем из кеша. Если значение удаляется, память освободится автоматически</li>
	<li>Управление обоработчиками событий. Обработчики событий для объекта сохраняются в WeekMap, а ключем является сам объект. Если объект удаляется, то и обработчики для него удаляются автоматически</li>
	<li>Хранение приватных данных. Приватные данные для объекта сохраняются в WeekMap, а ключем является объект</li>
</ul>

<!------------------------------------------------------>
<h3>Массив</h3>
<!------------------------------------------------------>
<pre><code class="js">
var names = ['HTML', 'CSS', 'JavaScript'];
var nameLengths = names.map(function(name) {
	return name.length;
});
// получили массив с длинами
alert(nameLengths); // 4,3,10
</code></pre>

<!------------------------------------------------------>
<h3>Задание значений при объявлении</h3>
<!------------------------------------------------------>
<pre><code class="js">
const map = new Map([
	['Hi', 'Привет'],
	[42, 'Ответ на главнй вопрос'],
	[true, false],
	[{}, 'Объект'],
	[function() {}, 'Функция'],
	[null, 1],
	[undefined, 2],
	[NaN, 3]
]);
</code></pre>

<!------------------------------------------------------>
<h3>Методы</h3>
<!------------------------------------------------------>
<pre><code class="js">
const map = new Map();

map.<bg-code>set</bg-code>(42, 'Ответ на главный вопрос'); // установить значение
var a = map.<bg-code>get</bg-code>(42);                    // получить значение по ключу
var a = map.<bg-code>size</bg-code>;                       // получить кол-во элементов
var a = map.<bg-code>has</bg-code>(42);                    // проверка наличия значения по ключу

map.<bg-code>delete</bg-code>(42);                         // удалить значение по ключу
map.<bg-code>clear</bg-code>();                            // очистка map

var a = map.<bg-code>keys</bg-code>();                     // возвращает перебираемый объект с ключами
var a = map.<bg-code>values</bg-code>();                   // возвращает перебираемый объект с значениями
var a = map.<bg-code>entries</bg-code>();                  // возвращает массив массивов
</code></pre>

<h3>Перебор map</h3>
<pre><code class="js">
for(let [key, value] <bg-code>of</bg-code> map) {
	console.log(key, value);
}
</code></pre>

<pre><code class="js">
map.forEach((value, key, map) => console.log(value, key));
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>
<pre><code class="js">
const map = new Map();
map.set('HTML', 'HyperText Markup Language')
	.set('CSS', 'Cascading Style Sheets')
	.set('JS', 'JavaScript');
</code></pre>

<h4>keys()</h4>
<pre><code class="js">
// обратно получаем не массив, а объект MapIterator (объект для перебора)
console.log(map.keys()); // MapIterator {"HTML", "CSS", "JS"}

// получить объекты по порядку можно используя оператор распространения
console.log(...map.keys()); // HTML CSS JS

// можно получить массив обернув в []
console.log([...map.keys()]); //["HTML", "CSS", "JS"] 
</code></pre>

<h4>values()</h4>
<pre><code class="js">
console.log([...map.values()]); // ["HyperText Markup Language", "Cascading Style Sheets", "JavaScript"]
</code></pre>

<h4>entries()</h4>
<pre><code class="js">
console.log([...map.entries()]); // массив массивов
// можно использовать для клонирования map
const map2 = new Map(map.entries());
</code></pre>

<pre><code class="js">
// получить ключ:значение с помощью реструктруризации
const [first, second, third] = map;
console.log(first);  // ["HTML", "HyperText Markup Language"] 
console.log(second); // ["CSS", "Cascading Style Sheets"]
console.log(third);  // ["JS", "JavaScript"]

const [[key, value], second, third] = map;
console.log(key);   // HTML 
console.log(value); // HyperText Markup Language
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="destructive-array">Деструктивное присваивание массивов (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var languages = ['JavaScript', 'Python', 'Ruby'];
// ES5
var js = languages[0];
var py = languages[1];
var rb = languages[2];
</code></pre>

<h4>Деструтивное присваивание</h4>
<pre><code class="js">
var languages = ['JavaScript', 'Python', 'Ruby'];
var [js, py, rb] = languages;
</code></pre>

<h4>Игнорирование значения</h4>
<pre><code class="js">
var scores = [3, 4, 5];
var [low, , high] = scores; 
</code></pre>

<h4>Преобразование в массив оставшихся значений</h4>
<pre><code class="js">
var scores = [3, 4, 5];
var [low, ...rest] = scores;
</code></pre>

<h4>Значение по умолчанию</h4>
<pre><code class="js">
var scores = [3, 4];
var [low, mid, high=5] = scores;
</code></pre>

<h4>Значение из массива</h4>
<pre><code class="js">
var scores = [3, 4, [5, 6]];
var [low, mid, [high, higher]] = scores;
</code></pre>

<h4>Деструктивное присванивание как параметр функции</h4>
<pre><code class="js">
function cumputeScore([low, mid]) {
	console.log(low, mid);
}
cumputeScore([3, 4]);
</code></pre>

<h4>Деструктивное присвание для возврата нескольких значений из функции</h4>
<pre><code class="js">
function getScores() {
	return [3, 4, 5];
}
var [low, mid, high] = getScores();
</code></pre>

<h3>Пример #1. Быстрый обмен значений переменнных</h3>
<pre><code class="js">
var yes = 'Yes';
var no = 'No';
[yes, no] = [no, yes];
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="destructive-obj">Деструтивное присваивание объектов (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="js">
var person = {
	firstname: 'Tony',
	lastname: 'Stark'
};
// ES5
var firstname = person.firstname;
var lastname = person.lastname;
</code></pre>

<h4>Деструтивное присваивание объектов</h4>
<pre><code class="js">
// имена переменных должны совпадать с именами свойст объекта
var {firstname, lastname} = person;
</code></pre>

<h4>Изменение имен переменных</h4>
<pre><code class="js">
var {firstname:first, lastname:last} = person;
</code></pre>

<h4>Значение по умолчанию</h4>
<pre><code class="js">
var {firstname, lastname, age=25} = person;
</code></pre>

<h4>Динамическое определение имен свойст с помощью выражения в []</h4>
<pre><code class="js">
var {['first'+'name']:first, lastname} = person;
</code></pre>

<h3>Извлечение свойств вложенных объектов</h3>
<pre><code class="js">
var user = {
	firstname: 'Tony',
	lastname: 'Stark',
	social: {
		facebook: 'tonystark',
		twitter: 't-stark'
	}
};
var {firstname, lastname, social:{facebook}} = user;
</code></pre>


<h3>Использование в качестве параметра функции</h3>
<pre><code class="js">
var user = {
	firstname: 'Tony',
	lastname: 'Stark'
};
function post(url, {data:{firstname, lastname}, cache}) {
	console.log(firstname, lastname, cache);
}
var result = post('api/users', {data:user, cache:false});
</code></pre>

<h3>Возврат нескольких значений из функции</h3>
<pre><code class="js">
function getUser() {
	return {
		firstname: 'Tony',
		lastname: 'Stark'
	};
}
var {firstname, lastname} = getUser();
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="symbol">Symbol (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list">
	<li><bg-list>Символ</bg-list> - уникальные и неизменные значения, позволябщие разработчикам языка добавлять новые идентификаторы или свойства объектов, не резервируя строковые названия для этих свойств</li>
	<li>Нельзя использовать ключевое слово <bg-list>new</bg-list></li>
</ul>

<pre><code class="js">
// создание символа
var symbol1 = Symbol();
</code></pre>

<pre><code class="js">
// создание символа
var symbol2 = Symbol.for('name');
</code></pre>

<pre><code class="js">
// получить имя символа
var name = Symbol.keyFor(symbol2);
</code></pre>

<pre><code class="js">
// задание необязательного аргумента, в котором указывается имя для символа
// имя можно использовать описания символа (полезно для отладки)
var symbol3 = Symbol('name');
</code></pre>

<pre><code class="js">
// задание свойства объекта
var user = {
	username: 'r2d2',
	[Symbol.for('password')]: 'c3po'
};
var password = user[Symbol.for('password')];
console.log(password);
// просмотреть символы у объекта
console.log(Object.getOwnPropertySymbols(user));
</code></pre>

<pre><code class="js">
// встроенные символы
// хорошо известные символы
var obj = {
	iterator: 0,
	[Symbol.iterator]() {}
}
// Symbol.iterator используется конструкцией for...of
// благодаря которой можно перебирать (итерировать) объект
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ecmascript">ECMAScript</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
ECMAScript является стандартом, а JavaScript — это самая популярная реализация этого стандарта
<pre>
<code class="js">
<em>ES1</em> (1997)
<em>ES2</em> (1998)
<em>ES3</em> (1999)
<em>ES4</em> (не была принята)
<em>ES5</em> (2009)
<em>ES6</em> (ES2015)
<em>ES7</em> (ES2016)
<em>ES8</em> (ES2017)
</code>
</pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="select">Выборка элементов страницы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var a = document.getElementById('item');               // по id
var a = document.getElementsByClassName('item')[0];    // по названию класса (первый элемент)
var a = document.getElementsByName('item');            // по атрибуту name
var a = document.getElementsByTagName('img');          // по названию тега (все элементы)
var a = document.querySelector('.nav.bar');            // возвращает первый элемент внутри документа
var a = document.querySelectorAll('.nav');             // возвращает список элементов в пределах документа
</code></pre>

<p>Методы getElementsByTagName и т.д. вызывают не обычные массивы, а живые коллекции</p>

<h4>Форма</h4>
<pre><code class="js">
var a = document.forms[0];                             // первая форма на странице
var a = document.myform;                               // форма с name=myform (если name уникальный)
var a = document.forms[0].elements[0];                 // первый элемент в форме
var a = document.forms[0].element;                     // элемент в форме с name=element
var a = document.forms['nameForm']['nameField'];       // поле формы
</code></pre>

<h4>Изображение</h4>
<pre><code class="js">
var a = document.images.logo;                          // img с name=logo
var a = document.images['logo'];                       // img с name=logo
var a = document.logo;                                 // img с name=logo (если name уникальный)
</code></pre>

<h3>Выбор родственных элементов</h3>
<pre><code class="js">
var a = element.childNodes;                            // дети (включая текстовые узлы)
var a = element.children;                              // дети (не включая текстовые узлы)
var a = element.parentNode;                            // родитель 
var a = element.nextSibling;                           // следующий брат
var a = element.previousSibling;                       // предыдущий брат
var a = element.firstChild;                            // первый ребенок
var a = element.lastChild;                             // последний ребенок
</code></pre>

<pre><code class="js">
var a = document.childNodes;                           // дети с doctype и комментариями
var a = document.children;                             // дети
var a = document.children[0].children[1].children;     // выборка всех элементов из body
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="methods">Методы элементов страницы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
element.innerText   = 'new text';           // текст (не выводит невидимые элементы)
element.textContent = 'new text';         // текст
element.innerHTML   = '&lt;h2&gt;new text&lt;/h2&gt;';  // html
</code></pre>

<pre><code class="js">
element.id          = 'name';
element.className   = 'nameClass1 nameClass2';
</code></pre>

<pre><code class="js">
element.href        = 'https://www.google.com/';
element.src         = 'image.jpg';
element.offsetTop;  // отступ от верха документа
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern">Шаблонные строки (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var a = `
	первая строка
	вторая строка
`;
</code></pre>

<h3>Интерполяция</h3>
<pre><code class="js">
var a = 'text'; 
var b = `строка текста ${a} строка текста`;
</code></pre>

<h3>Тегирование</h3>
Изменение вида шаблонов при помощи функций

<pre><code class="js">
var name = 'Tony';
console.log(upperName`Hello ${name}`);

// literals - массив строковых литералов
// name - значение вычисленных выражений
function upperName(literals, value) {
	return literals[0] + value.toUpperCase();
}
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="dictionary">Словарь</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list">
	<li><bg-list>Statements (инструкции)</bg-list> - var statement</li>
	<li><bg-list>Expressions (выражения)</bg-list> - stetement = 2+7</li>
	<li><bg-list>Operators (операторы)</bg-list> - арифметические, сравнения, условные, логические, побитовые</li>
	<li><bg-list>Литерал</bg-list> - любое значение указанное явным образом в коде. В качестве литералов в js могут выступать числа, строки (текстовые значения), логические значения</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="type">Типы данных</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="html">
1. <em>Number</em>    - число 64-битный float (примитивный) 
2. <em>String</em>    - cтрока (примитивный)
3. <em>Boolean</em>   - булевый, логический (примитивный)
4. <em>null</em>      - специальное пустое или неизвестное значение (присваивается самостоятельно)
5. <em>undefined</em> - специальное неприсвоеное значение (возвращается из js)
6. <em>Object</em>    - объект 
7. <em>Symbol</em>    - символ (примитивный) ES6
</code></pre>

<p>Специальные числовые значения <bg-list>Infinity</bg-list> и <bg-list>NaN</bg-list></p>

<!------------------------------------------------------>
<h3>Преобразование типов</h3>
<!------------------------------------------------------>
<pre><code class="js">
String(77);
Number('77');
Boolean(77);
</code></pre>

<pre><code class="js">
77 + ''; // string
+'77';   // number
!!'77';  // boolean
</code></pre>

<pre><code class="js">
77.toString();
parseInt('77px');
parseFloat('77.2px')
</code></pre>

<!------------------------------------------------------>
<h3>Способы создания переменных</h3>
<!------------------------------------------------------>
<h4>1. Литеральная форма</h4>
<pre><code class="js">
var a = 'string';
</code></pre>

<h4>2. Конструктор</h4>
<pre><code class="js">
var a = new String('string');
var a = new Number(77);
var a = new Boolean(true);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="wrappers">Object Wrappers (Autoboxing)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
typeof 'string';             // "string"
typeof new String('string'); // "object"
</code></pre>

<ul class="list-point">
	<li>Автоупаковка - вызов свойства или метода для примитивных типов (string, number, boolean), при котором JavaScript преобразует его во временный объект-оболочку и получает доступ к его свойству или методу, не затрагивая сам оригинал</li>
	<li>Объект-обертка вокруг примитивного типа данных создается вызовом конструктора new</li>
	<li>Или при использовании методов для строк и чисел</li>
	<li>Иначе это является примитивным типом данных (string, number, boolean)</li>
</ul>

<pre><code class="js">
// позволяет достать строку из объекта
var str = new String('string');
console.log(str.valueOf()); 
</code></pre>

<ul class="list-point">
	<li>Если обратиться к свойству числа, строки или логического значения, то будет создан объект соответствующего типа, например new String для строки, new Number для чисел, new Boolean – для логических выражений</li>
	<li>Далее будет произведена операция со свойством или вызов метода по обычным правилам, с поиском в прототипе, а затем этот объект будет уничтожен</li>
	<li>Для значений null и undefined нет соответствующих классов, в них нельзя записать свойство (будет ошибка)</li>
</ul>

<pre><code class="js">
var user = 'Tony';          // создали строку (примитив)
var a = user.toUpperCase(); // TONY
// был создан временный объект new String
// вызван метод
// new String уничтожен, результат возвращён
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="typeof">typeof</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h4>typeof - возвращает тип аргумента</h4>
<pre><code class="js">
typeof 0            // "number"
typeof 'foo'        // "string"
typeof true         // "boolean"
typeof undefined    // "undefined"
typeof null         // "object" (*)
typeof {}           // "object"
typeof []           // "object"
typeof new Date     // "object"
typeof function(){} // "function" (*)
</code></pre>

<pre><code class="js">
// проверка поддержки свойств
typeof addEventListener !== 'undefined'
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="case">Условные операторы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Условный оператор case()</h3>
<!------------------------------------------------------>
Использование цифр в виде аргумента
<pre><code class="js">
switch(Number(id)) {
	case 1: alert(id); break;
	case 2: alert(id); break;
	case 3: alert(id); break;
	default: alert("default");
}
</code></pre>

Использование строк в виде аргумента
<pre><code class="js">
switch(name) {
	case 'name1': alert(name); break;
	case 'name2': alert(name); break;
	case 'name3': alert(name); break;
	default: alert("default");
}
</code></pre>

<!------------------------------------------------------>
<h3>Условный оператор if()</h3>
<!------------------------------------------------------>
<pre><code class="js">
if (year < 2011) {
	alert('Это слишком рано..');
} else if (year > 2011) {
	alert('Это поздновато..');
} else {
	alert('Да, точно в этом году!');
}
</code></pre>

<!------------------------------------------------------>
<h3>Тернарный оператор</h3>
<!------------------------------------------------------>

<ul class="list-point">
	<li>условие ? значение1 : значение2</li>
	<li>если условие верно – возвращается значение1, если неверно – значение2</li>
</ul>

<div class="container-flex"><div class="container-half"><pre><code class="js">
// if … else
if (age > 14) {
	access = true;
} else {
	access = false;
}
</code></pre></div><div class="container-half"><pre><code class="js">
// Тернарный оператор
access = (age > 14) ? true : false;
<br><br><br>
</code></pre></div></div>

<div class="container-flex"><div class="container-half"><pre><code class="js">
// if … else
if(apple == orange) {
   res = "Равно"; 
} else {
   res = "Не равно"; 
}
</code></pre></div><div class="container-half"><pre><code class="js">
// Тернарный оператор
res = (apple == orange) ? "Равно" : "Не равно";
<br><br>
</code></pre></div></div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="cycle-array">Перебор массива</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list">
	<li><bg-list>forEach</bg-list> - для перебора массива</li>
	<li><bg-list>filter</bg-list> - для фильтрации массива</li>
	<li><bg-list>map</bg-list> - для трансформации массива в массив</li>
	<li><bg-list>every/some</bg-list> - для проверки массива</li>
	<li><bg-list>reduce/reduceRight</bg-list> - для прохода по массиву с вычислением значения</li>
</ul>

<!------------------------------------------------------>
<h3>forEach</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Ничего не возвращает, используется только для перебора</li>
</ul>
<pre><code class="js">
var arr = ["Яблоко", "Апельсин", "Груша"];
arr.forEach(function(element, index, arr) {
	console.log( index + ": " + element + " (массив:" + arr + ")" );
});
// "0: Яблоко   (массив:Яблоко,Апельсин,Груша)"
// "1: Апельсин (массив:Яблоко,Апельсин,Груша)"
// "2: Груша    (массив:Яблоко,Апельсин,Груша)"
</code></pre>

<!------------------------------------------------------>
<h3>filter</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Используется для фильтрации массива через функцию</li>
	<li>Создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true</li>
</ul>

<pre><code class="js">
var arr = [1, -1, 2, -2, 3];
var positiveArr = arr.filter(function(number) {
	return number > 0;
});
alert(positiveArr); // 1,2,3
</code></pre>

<!------------------------------------------------------>
<h3>map</h3>
<!------------------------------------------------------>
<pre><code class="js">
<a href="#map">Ссылка</a>
</code></pre>

<!------------------------------------------------------>
<h3>every/some</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Используется для проверки массива</li>
	<li>Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr</li>
	<li>Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr</li>
</ul>

<pre><code class="js">
var arr = [1, -1, 2, -2, 3];
function isPositive(number) {
  return number > 0;
}
alert( arr.every(isPositive) ); // false, не все положительные
alert( arr.some(isPositive) );  // true, есть хоть одно положительное
</code></pre>

<!------------------------------------------------------>
<h3>reduce/reduceRight</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата</li>
	<li><b>arr.reduce</b> идёт по массиву слева-направо</li>
	<li><b>arr.reduceRight</b> идёт по массиву справа-налево</li>
</ul>

<pre><code class="js">
<em>arr.reduce(callback[, initialValue])</em>
</code></pre>

<ul class="list-point">
	<b>callback(previousValue, currentItem, index, arr)</b>
	<li><bg-list>previousValue</bg-list> - последний результат вызова функции, «промежуточный результат»</li>
	<li><bg-list>currentItem</bg-list> - текущий элемент массива, элементы перебираются по очереди слева-направо</li>
	<li><bg-list>index</bg-list> - номер текущего элемента</li>
	<li><bg-list>arr</bg-list> - обрабатываемый массив</li>
</ul>

<ul class="list-point">
	<b>initialValue - начальное значение</b>
	<li>Если есть <bg-list>initialValue</bg-list>, то на первом вызове значение <bg-list>previousValue</bg-list> будет равно <bg-list>initialValue</bg-list></li>
	<li>Если нет <bg-list>initialValue</bg-list>, то оно равно первому элементу массива, а перебор начинается со второго</li>
</ul>

<pre><code class="js">
// сумма элементов массива
var arr = [1, 2, 3, 4, 5]

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current
});

alert(result); // 15
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="cycle">Циклы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Цикл for</h3>
<!------------------------------------------------------>
<pre><code class="js">
for (var i = 1; i < 10; i++) {  
    console.log(i); 
}
</code></pre>

<h3>Цикл while</h3>
<pre><code class="js">
var i = 0;  
while (i < 10) {  
    console.log(i); 
    i++;  
}
</code></pre>

<!------------------------------------------------------>
<h3>Цикл do while</h3>
<!------------------------------------------------------>
<pre><code class="js">
var i = 0;  
do {  
    console.log(i); 
    i++;  
} while (i < 10);
</code></pre>

<pre><code class="js">
break    // выход из цикла
continue // прекращает выполнение текущей итерации цикла и переходит на следующую
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="array">Массивы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>Массив - это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length</li>
	<li>Так как это объект, то в функцию он передаётся по ссылке</li>
	<li>Нет причин использовать массив как обычный объект, хотя технически это и возможно</li>
</ul>

<!------------------------------------------------------>
<h3>Объявление</h3>
<!------------------------------------------------------>
<pre><code class="js">
var arr = [];                        // объявление пустого массива
var arr = ['Tony', 'Anne'];          // объявление массива из заполненных элементов
var arr = [,,'Tony'];                // пропуск элементов
var arr = new Array(5);              // объявление массива из пустых элементов с длиной 5 (конструктор)
var arr = new Array('Tony', 'Anne'); // объявление массива (конструктор)
</code></pre>

<!------------------------------------------------------>
<h3>Методы</h3>
<!------------------------------------------------------>
<bg-list>push</bg-list> <bg-list>pop</bg-list> <bg-list>unshift</bg-list> <bg-list>shift</bg-list>
<pre><code class="js">
arr.<bg-code>push</bg-code>('Jack', 'Tony');            // добавляет элементы в конец
arr.<bg-code>unshift</bg-code>('Jack', 'Tony');         // добавляет элементы в начало
arr.<bg-code>pop</bg-code>();                           // удаляет и возвращает последний элемент
arr.<bg-code>shift</bg-code>();                         // удаляет и возвращает первый элемент
</code></pre>

<bg-list>indexOf</bg-list> <bg-list>lastIndexOf</bg-list>
<pre><code class="js">
var a = colors.<bg-code>indexOf</bg-code>('white');     // возвращает первый индекс, по которому элемент может быть найден в массиве или -1, если индекса нет
var a = colors.<bg-code>lastIndexOf</bg-code>('white'); // возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет
</code></pre>

<bg-list>join</bg-list> <bg-list>split</bg-list>
<pre><code class="js">
var a = arr.<bg-code>join</bg-code>('.');               // преобразование массива в строку с заданным разделителем
var arr = str.<bg-code>split</bg-code>(';');            // преобразование строки с заданным разделителем в массив 
</code></pre>

<bg-list>slice</bg-list>
<pre><code class="js">
var arr2 = arr1.<bg-code>slice</bg-code>(1, 7);         // копировать с 1 до 7 не включая, если не указан второй аргумент, то до конца
var arr2 = arr1.<bg-code>slice</bg-code>(1);            // копировать с 1 до конца
var arr2 = arr.<bg-code>slice</bg-code>(-2);            // копировать c 2 элемента с конца и дальше
var arr2 = arr.<bg-code>slice</bg-code>();              // копировать весь массив
</code></pre>

<bg-list>splice</bg-list>
<pre><code class="js">                
arr.<bg-code>splice</bg-code>(3, 2);                     // удалить с 3 индекса 2 элемента
arr.<bg-code>splice</bg-code>(2, 0, 'Алина', 'Марина');  // добавление элементов
arr.<bg-code>splice</bg-code>(1, 2, 'Алексей", "Билл');  // замена элементов (заменить 2 удаленных элемента на Алексей, Билл)
arr.<bg-code>splice</bg-code>(-1, 1);                    // удалить с последнего индекса-1 1 элемент (отрицательная позиция отсчитывается с конца)
</code></pre>

<bg-list>length</bg-list> <bg-list>reverse</bg-list> <bg-list>concat</bg-list>
<pre><code class="js">
var a = arr.<bg-code>length</bg-code>;                  // длина массива (индекс последнего элемента)
arr.<bg-code>reverse</bg-code>();                       // меняет порядок элементов в массиве на обратный
var arr = arr1.<bg-code>concat</bg-code>(arr2, arr3);   // создаёт новый массив, в который копируются элементы из массивов
</code></pre>

<bg-list>sort</bg-list>
<pre><code class="js">
arr.<bg-code>sort</bg-code>();                          // сортировка по алфавиту, преобразуя элементы к строке
</code></pre>

<pre><code class="js">
// свой порядок сортировки (сортировка чисел)
var arr = [1, 12, 2];
arr.sort(function(a, b) {
  if (a > b) return 1;
  if (a < b) return -1;	
});
console.log(arr);  // 1, 2, 15
</code></pre>

<bg-list>Array.isArray()</bg-list>
<pre><code class="js">
// проверка на массив
var a = Array.<bg-code>isArray</bg-code>([1,2,3]); // true
var b = Array.<bg-code>isArray</bg-code>("not array"); // false
</code></pre>

<h3>Примеры</h3>
<pre><code class="js">
arr['someIndex'] = 'someValue';       // использование строки в виде индекса
arr.length = 10;                      // все элементы больше 10 индекса будут удалены
delete arr[4];                        // присваивание элементу по индексу 4 undefined
var a = Array.isArray(arr);           // проверка на массив
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="array_obj">Массивы обьектов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var a = new Array(
	{"name":"Андрей", "email":"andry@mail.ru"},
	{"name":"Анна",   "email":"anna@mail.ru"}
);

console.log(a[0].name);  // "Андрей"
console.log(a[1].email); // "anna@mail.ru"
</code></pre>

<h3>Примеры</h3>
<pre><code class="js">
// перебор массива
for (var i=0; i<=arr.length-1; i++) {
	console.log(arr[i]);
}
</code></pre>

<pre><code class="js">
// перебор массива и удаление выбранного элемента
var id = 12;
for (var i=0; i<=arr.length-1; i++) {
	if (id == arr[i]) {
		arr.splice(i, 1); 
		break;
	} 
}
</code></pre>

<pre><code class="js">
// добавление нового элемента в массив
if (arr != '') {
	arr[arr.length] = id;
} else {
	arr[0] = id;
}
</code></pre>

<pre><code class="js">
// удаление элемента массива
arr.splice(arr.indexOf(String(id)), 1);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="str">Строки</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Строки в JavaScript имеют внутреннюю кодировку Юникод</li>
</ul>
<pre><code class="js">
var a = str.<bg-code>length</bg-code>;       // длина строки 
77.<bg-code>toString()</bg-code>;            // преобразование в строку
var arr = str.<bg-code>split</bg-code>(';'); // преобразование строки с заданным разделителем в массив
var str = str.<bg-code>trim</bg-code>();     // обрезает пробелы с начала и конца строки
</code></pre>

<pre><code class="js">
var name = name.<bg-code>toUpperCase</bg-code>(); // верхний регистр
var name = name.<bg-code>toLowerCase</bg-code>(); // нижний регистр
</code></pre>

<h4>Поиск в строке совпадений с образцом</h4>
<pre><code class="js">
var pos = str.<bg-code>indexOf</bg-code>('name');     // с начала (-1 не найдено)
var pos = str.indexOf('name', 2);  // поиск начат с позиции 2
var pos = str.<bg-code>lastIndexOf</bg-code>('name'); // с конца (-1 не найдено)
</code></pre>

<h4>Взятие подстроки: substring, substr, slice</h4>

<bg-list>slice</bg-list>
<ul class="list-point">
	<li>Отрицательные значения отсчитываются от конца строки</li>
</ul>
<pre><code class="js">
var root = str.<bg-code>slice</bg-code>(1, 7);        // вырезать с 1 позиции до 7 позиции не включая
var root = 'testme'.slice(-2);     // 'me', от 2 позиции с конца
var root = 'testme'.slice(1, -1);  // "estm", от 1 позиции до первой с конца 
</code></pre>

<bg-list>substring</bg-list>
<ul class="list-point">
	<li>Отрицательные аргументы интерпретируются как равные нулю</li>
	<li>Слишком большие значения усекаются до длины строки</li>
	<li>Если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end</li>
</ul>
<pre><code class="js">
var root = str.<bg-code>substring</bg-code>(1, 7);       // вырезать с 1 позиции до 7 позиции не включая
var root = str.substring(1);          // вырезать с 1 позиции до конца строки
var root = 'testme'.substring(-2);    // 'testme', -2 становится 0
var root = 'testme'.substring(4, -1); // 'test', -1 становится 0 -> получили substring(4, 0), 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
</code></pre>

<bg-list>substr</bg-list>
<pre><code class="js">
var root = str.<bg-code>substr</bg-code>(1, 4);   // вырезать с 1 позиции 4 символа
var root = str.substr(1);      // вырезать с 1 позиции до конца строки
</code></pre>

<h4>charAt, charCodeAt</h4>
<pre><code class="js">
var root = <bg-code>charAt</bg-code>(2);     // возвращает символ строки по индексу 
var root = <bg-code>charCodeAt</bg-code>(2); // возвращает код символа строки по индексу (все русские буквы находятся в диапазоне от 1040 до 1103)
</code></pre>

<pre><code class="js">
alert( "".charAt(0) ); // пустая строка
alert( "" [0] );       // undefined
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>

<h4>Перебор строки</h4>
<pre><code class="js">
for (var i=0; i <= str.length-1; i++) {
	console.log(str[i]);
}
</code></pre>

<h4>Длина числа</h4>
<pre><code class="js">
var id = 100;
var a = id.toString().length;
</code></pre>

<h4>Сложение</h4>
<pre><code class="js">
"Blink" + 181 + 1;   // "Blink1811"
"Blink" + (181 + 1); // "Blink182"
</code></pre>

<h4>Экраснирвание кавычек</h4>
<pre><code class="js">
'\n'                     // перенос строки
alert('привет \n мир');  // вывод переноса строки
"call me \"ziggy\" now"; // экранирование кавычек
</code></pre>

<h4>Проверка на заполненное поле</h4>
<pre><code class="js">
var login = '';
var password = '';
isFormValid() {
	return login.length > 0 && password.length > 0;
}
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="number">Числа</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
num.toFixed(2);             // фиксирование кол-ва знаков после запятой
123456789.toLocaleString(); // вывод чисел в стандарте ECMA (result = 402 123 456 789)
</code></pre>

<pre><code class="js">
Number(num);     // преобразование любого объекта в число
parseInt(num);   // преобразование в целое число
parseFloat(num); // преобразование в целое/дробное число ('50.5px', вернет значение "50.5"
+'50.5';         // преобразование в целое/дробное число
</code></pre>

<h4>isNaN</h4>
<ul>
	<li>isNaN преобразует к числу пустую строку, строку из пробельных символов, значения false, true, null</li>
</ul>
<pre><code class="js">
isNaN(num); // если в переменной не число, вернет истину
</code></pre>

<h4>isFinite</h4>
<ul class="list-point">
	<li>isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity</li>
</ul>
<pre><code class="js">
alert( isFinite(1) );        // true
alert( isFinite(Infinity) ); // false
alert( isFinite(NaN) );      // false
</code></pre>

<h4>Infinity</h4>
<ul class="list-point">
	<li>Infinity больше любого числа</li>
	<li>Добавление к бесконечности не меняет её</li>
</ul>
<pre><code class="js">
alert( 1 / 0 );     // Infinity
alert( 12345 / 0 ); // Infinity
alert( -1 / 0 );    // -Infinity
var x = Infinity;   // Infinity можно присвоить и в явном виде
</code></pre>

<h4>NaN</h4>
<ul class="list-point">
	<li>NaN (Not-A-Number)</li>
	<li>Значение NaN используется для обозначения математической ошибки</li>
	<li>Значение NaN – единственное в своем роде, которое не равно ничему, включая себя</li>
</ul>
<pre><code class="js">
alert( 0 / 0 );   // NaN
alert( NaN + 1 ); // NaN
</code></pre>

<h4>Перебор в двоичную систему отсчета</h4>
<pre><code class="js">
parseInt("11000", 2);              // переводит строку с двоичной записью числа в число
n.toString(2);                     // получает для числа n запись в 2-ной системе в виде строки

var access = parseInt("11000", 2); // получаем число из строки
alert(access);                     // 24, число с таким 2-ным представлением

var access2 = access.toString(2); // обратно двоичную строку из числа
alert(access2);                   // 11000
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="operators">Операторы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h4>Остаток от деления</h4>
<pre><code class="js">
alert(5 % 2); // 1, остаток от деления 5 на 2
alert(8 % 3); // 2, остаток от деления 8 на 3
alert(6 % 3); // 0, остаток от деления 6 на 3
</code></pre>

<h4>Инкремент/декремент</h4>
<ul class="list-point">
	<li><bg-list>i++</bg-list> постфиксная форм</li>
	<li><bg-list>++i</bg-list> префиксная форма</li>
</ul>

<pre><code class="js">
var i = 1;
var a = ++i;
alert(a); // 2
</code></pre>

<pre><code class="js">
var i = 1;
var a = i++;
alert(a); // 1
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="math">Math</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
Math.round(num); // округляет число к ближайшему целому (5 округляется вверх)
Math.ceil(num);  // округляет число в большую сторону
Math.floor(num); // округляет число в меньшую сторону
</code></pre>

<pre><code class="js">
var rand = Math.random(); // генерация случайного числа от 0 (включительно) до 1 (не включая)
var rand = Math.round(Math.random() * 100); // от 0 до 100
</code></pre>

<pre><code class="js">
var a = Math.pow(4,2);        // степень 4 в 2
var a = Math.sqrt(400);       // квадратный корень числа
var a = Math.abs(-7);         // модуль
var a = Math.max(1, 2, 3, 4); // большее число из аргументов
var a = Math.min(1, 2, 3, 4); // меньшее число из аргументов
var a = Math.exp(2);          // возведение часла "e" в указанную степень
var a = Math.log(5);          // натуральный логарифм числа
</code></pre>

<pre><code class="js">
var a = Math.PI;              // число PI
var a = Math.E;               // чисто E
</code></pre>

<pre><code class="js">
var a = Math.sin(1);          // синус (радиан)
var a = Math.cos(1);          // косинус
var a = Math.tan(1);          // тангенс
var a = Math.atan(1);         // арктангенс
var a = Math.asin(1);         // арксинус
var a = Math.acos(1);         // арккосинус
</code></pre>

<h4>Пример Random(min, max)</h4>
<pre><code class="js">
function mtRand(min, max) {
	return Math.floor(Math.random() * (max - min + 1));
	//return Math.random() * (max - min) + min;
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="date">Дата и время</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="html">
<a href="http://momentjs.com/" target="_blank">Moment.js</a>
</code></pre>

<!------------------------------------------------------>
<h3>Создание</h3>
<!------------------------------------------------------>
<pre><code class="js">
new <bg-code>Date</bg-code>(year, month, date, hours, minutes, seconds, ms)
</code></pre>

<pre><code class="js">
var selectDate = new Date(2012,0,1,0,0,0); // объявление для заданной даты
var nowDate = new Date();                  // текущее дата и время на компьютере пользователя
</code></pre>

<!------------------------------------------------------>
<h3>Установка значений</h3>
<!------------------------------------------------------>
<pre><code class="js">
var selectDate = new Date(2012,0,1,0,0,0);
</code></pre>
<pre><code class="js">
selectDate.<bg-code>setMinutes</bg-code>(25);                 // установка минут
setSeconds.<bg-code>setSeconds</bg-code>(25);                 // установка секунд
...
</code></pre>

<!------------------------------------------------------>
<h3>Получение значений</h3>
<!------------------------------------------------------>
<pre><code class="js">
var nowDate = new Date();
</code></pre>
<pre><code class="js">
var yearFull = nowDate.<bg-code>getFullYear()</bg-code>;      // год (4 цифры)
var month    = nowDate.<bg-code>getMonth()</bg-code>;         // месяц (от 0 до 1)
var day      = nowDate.<bg-code>getDate()</bg-code>;          // число месяца (от 1 до 31)
var dayWeek  = nowDate.<bg-code>getDay()</bg-code>;           // день недели (от 0-воскресенье до 6-суббота)
var hour     = nowDate.<bg-code>getHours()</bg-code>;         // час
var minutes  = nowDate.<bg-code>getMinutes()</bg-code>;       // минуты
var seconds  = nowDate.<bg-code>getSeconds()</bg-code>;       // секунды
var mseconds = nowDate.<bg-code>getMilliseconds()</bg-code>;  // миллисекунды
</code></pre>

<!------------------------------------------------------>
<h3>Date.parse</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<b>Формат представления даты</b> <bg-code>YYYY-MM-DDTHH:mm:ss.sss</bg-code>
	<li><bg-code>YYYY-MM-DD</bg-code> - дата в формате год-месяц-день</li>
	<li>Обычный символ <bg-code>T</bg-code> используется как разделитель</li>
	<li><bg-code>HH:mm:ss.sss</bg-code> – время: часы-минуты-секунды-миллисекунды</li>
	<li>Часть <bg-code>'Z'</bg-code> обозначает временную зону – в формате <bg-code>+-hh:mm</bg-code>, либо символ <bg-code>Z</bg-code>, обозначающий UTC</li>
</ul>

<ul class="list-point">
	<b>Date.parse(str)</b>
	<li>Метод <bg-code>Date.parse(str)</bg-code> разбирает строку str в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, <bg-code>Date.parse</bg-code> возвращает NaN</li>
</ul>

<pre><code class="js">
var msUTC = Date.parse('2012-01-26T13:51:50.417Z'); // зона UTC
alert( msUTC ); // 1327571510417 (число миллисекунд)

var ms = Date.parse('2012-01-26T13:51:50.417-07:00'); // С таймзоной -07:00 GMT
alert( ms ); // 1327611110417 (число миллисекунд)
</code></pre>

<h4>Строковое и численное преобразование</h4>
<pre><code class="js">
alert( new Date() );  // toString: Дата в виде читаемой строки
alert( +new Date() ); // valueOf: кол-во миллисекунд, прошедших с 01.01.1970
</code></pre>

<!------------------------------------------------------>
<h3>toLocaleString</h3>
<!------------------------------------------------------>
<pre><code class="js">
var date = new Date(2014, 11, 31, 12, 30, 0);

var options = {
	era: 'long',
	year: 'numeric',
	month: 'long',
	day: 'numeric',
	weekday: 'long',
	timezone: 'UTC',
	hour: 'numeric',
	minute: 'numeric',
	second: 'numeric'
};

alert( date.<bg-code>toLocaleString</bg-code>("ru", options) );    // среда, 31 декабря 2014 г. н.э. 12:30:00
alert( date.<bg-code>toLocaleString</bg-code>("en-US", options) ); // Wednesday, December 31, 2014 Anno Domini 12:30:00 PM
</code></pre>

<pre><code class="js">
var a = nowDate.<bg-code>toLocaleTimeString()</bg-code>; // время с учетом локализации
var a = nowDate.<bg-code>toLocaleDateString()</bg-code>; // дата с учетом локализации
</code></pre>

<pre><code class="js">
// вывод зависит от браузера
var d = new Date();
var a = d.<bg-code>toString()</bg-code>;     // возвращает дату целиком 'Wed Jan 26 2011 16:40:50 GMT+0300'
var a = d.<bg-code>toDateString()</bg-code>; // возвращает только дату
var a = d.<bg-code>toTimeString()</bg-code>; // возвращает только время
</code></pre>


<!------------------------------------------------------>
<h3>GMT и UTC</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Все методы, указанные выше, возвращают результат для местной временной зоны</li>
	<li>Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay() и т.д.</li>
</ul>
<pre><code class="js">
var a = nowDate.getHours();          // время по гринвичу (GMT)
var a = nowDate.<bg-code>getUTCHours()</bg-code>;       // время в формате UTC
var a = nowDate.<bg-code>getTimezoneOffset()</bg-code>; // возвращает разницу между местным и UTC-временем, в минутах.
</code></pre>

<!------------------------------------------------------>
<h3>Другие методы</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = nowDate.<bg-code>toTimeString()</bg-code>; // вывод времени в виде строки
var a = nowDate.<bg-code>toDateString()</bg-code>; // вывод даты в виде строки
</code></pre>

<pre><code class="js">
var selectDate = new Date(2012,0,1,0,0,0);
var a = selectDate.<bg-code>getTime()</bg-code>;  // возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0
</code></pre>

<pre><code class="js">
var timeInMs = <bg-code>Date.now</bg-code>();     // возвращает количество миллисекунд, прошедших с 1 января 1970 года 00:00:00 по UTC.
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>
<h4>Вывод текщей даты</h4>
<pre><code class="js">
var weekday = ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'];
var month = ['Января', 'Февраля', 'Марта', 'Апреля', 'Мая', 'Июня', 'Июля', 'Августа', 'Сентября', 'Октября', 'Ноября', 'Декабря'];
var nowDate = new Date();
var nowDay   = weekday[nowDate.getDay()];
var nowDate  = nowDate.getDate();
var nowMonth = month[nowDate.getMonth()];
</code></pre>

<h4>Разность дат</h4>
<pre><code class="js">
var start = new Date; // засекли время

// что-то сделать
for (var i = 0; i < 100000; i++) {
  var doSomething = i * i * i;
}

var end = new Date; // конец измерения
console.log( "Цикл занял " + (end - start) + " ms" );
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="catch">Исключения</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h3>Создание исключений</h3>
<pre><code class="js">
var calculate = function(n) {
	if (n>10) {
		throw new Error('n должно быть больше 10');
	}
	return n;
}
calculate(20);
</code></pre>

<h3>Обработка исключений</h3>
<pre><code class="js">
try {
	// инструкции, которые могут бросить исключение
} catch (идентификатор) {
	// инструкции будут выполняться если в try произошло исключение
	// передается выражение (идентификатор), которое было в throw
} finally {
	// инструкции будут выполняться независимо от исключения
}
// catch или finally может отсутствовать
// если ошибка необработана, скрипт не будет выполняться
// если ошибка обработана в catch, скрипт продолжит выполнение
</code></pre>

<pre><code class="js">
var calculate = function(n) {
	if (n>10) {
		throw new Error('n должно быть больше 10');
	}
	return n;
}
try {
	calculate(20);
} catch(e) {
	console.log('Ошибка функции calculate() ' + e.message);
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="timeout">Таймеры</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>Минимальная задержка таймера от 0 до 4мс</li>
</ul>

<!------------------------------------------------------>
<h3>setTimeout</h3>
<!------------------------------------------------------>
<pre><code class="js light">
<bg-methods>setTimeout(func/code, delay, [arg1, arg2...])</bg-methods> // однократное выполнение кода через некоторое время
	<em>&#8226; func/code</em>   // функция или строка кода для исполнения
	<em>&#8226; delay</em>       // задержка в миллисекундах, 1000 миллисекунд равны 1 секунде
	<em>&#8226; arg1, arg2…</em> // aргументы, которые нужно передать функции
<bg-methods>clearTimeout</bg-methods>(timerId); // останавливает исполнение setTimeout (timerId - числовой идентификатор таймера)
</code></pre>

<pre><code class="js">
// если первый аргумент является строкой, то интерпретатор создаёт анонимную функцию из этой строки
var timer = <bg-code>setTimeout</bg-code>("console.log('go');", 1000);
// анонимная функция
var timer = <bg-code>setTimeout</bg-code>(function() { console.log('go'); }, 1000);
// функция
var timer = <bg-code>setTimeout</bg-code>(func, 1000);

function func() {
    console.log('go');
}

<bg-code>clearTimeout</bg-code>(timer);
</code></pre>

<h4>Передача аргументов</h4>
<pre><code class="js">
setTimeout(func, 1000, 'Привет', 'Tony'); // Привет Tony
function func(phrase, who) {
	console.log(phrase + ' ' + who);
}
</code></pre>

<h4>Рекурсивный setTimeout (альтернатива setInterval)</h4>
<pre><code class="js">
var timerId = setTimeout(function tick() {
	console.log( "тик" );
	timerId = setTimeout(tick, 2000);
}, 2000);
</code></pre>


<!------------------------------------------------------>
<h3>setInterval</h3>
<!------------------------------------------------------>
<pre><code class="js light">
<bg-methods>setInterval(func/code, delay, [arg1, arg2...])</bg-methods> // повторение выполнения кода через определенное время
	<em>&#8226; func/code</em>   // функция или строка кода для исполнения
	<em>&#8226; delay</em>       // задержка в миллисекундах, 1000 миллисекунд равны 1 секунде
	<em>&#8226; arg1, arg2…</em> // aргументы, которые нужно передать функции
<bg-methods>clearInterval(timerId)</bg-methods> // останавливает исполнение setInterval (timerId - числовой идентификатор таймера)
</code></pre>

<pre><code class="js">
var timer = <bg-code>setInterval</bg-code>("console.log('go');", 1000);
<bg-code>clearInterval</bg-code>(timer);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="prevent">Отмена обычного поведения элемента</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
preventDefault(); // отмена обычного поведения элемента
return false - аналогично preventDefault(), но дальнейший код не выполняется
</code></pre>

<pre><code class="js">
element.onclick = function(event) {
	event.preventDefault();
	// return false ;
};
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="console">Console</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
console.log('Сообщение');
console.info('Информация');
console.warn('Предупреждение');
console.error('Ошибка');
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="jsdoc">Синтаксис JSDoc</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
/**
* Возвращает x в степени n, только для натуральных n
*
* @param {number} x Число для возведения в степень.
* @param {number} n Показатель степени, натуральное число.
* @return {number} x в степени n.
*/
function pow(x, n) {
	...
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="external-script">Асинхронные скрипты: defer/async</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>Если браузер видит тег <bg-list>script</bg-list>, то он обязан сначала выполнить его, а потом показать оставшуюся часть страницы</li>
	<li>Специальные атрибуты <bg-list>async</bg-list> и <bg-list>defer</bg-list> используются для того, чтобы пока грузится внешний скрипт - браузер показал остальную (следующую за ним) часть страницы</li>
	<li>При одновременном указании async и defer в современных браузерах будет использован только async</li>
	<li>Атрибуты async/defer работают только в том случае, если назначены на внешние скрипты, т.е. имеющие src</li>
	
</ul>

<!------------------------------------------------------>
<h3>Атрибут async</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Не сохраняет относительную последовательность скриптов</li>
	<li>Не ждет пока весь HTML-документ будет обработан браузером</li>
	<li>Браузер не останавливает обработку страницы, а работает дальше. Когда скрипт будет загружен – он выполнится</li>
</ul>
<pre><code class="js">
// первым сработает тот скрипт, который раньше загрузится
&lt;script src="1.js" async&gt;&lt;/script&gt;
&lt;script src="2.js" async&gt;&lt;/script&gt;
</code></pre>

<!------------------------------------------------------>
<h3>Атрибут defer</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Сохраняет относительную последовательность скриптов</li>
	<li>Ждет пока весь HTML-документ будет обработан браузером</li>
</ul>

<pre><code class="js">
// первым сработает всегда 1.js, а скрипт 2.js, даже если загрузился раньше, будет его ждать
&lt;script src="1.js" defer&gt;&lt;/script&gt;
&lt;script src="2.js" defer&gt;&lt;/script&gt;
</code></pre>

<pre><code class="js">
// скрипт async.js выполнится, как только загрузится – возможно, до того, как весь документ готов
// defer.js подождёт готовности всего документа
&lt;script src="async.js" async&gt;&lt;/script&gt;
&lt;script src="defer.js" defer&gt;&lt;/script&gt;
text text text
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="comparison">Сравнение и логические значения</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h3>Сравнение строк</h3>
<ul class="list-point">
	<li>Cравниваются численные коды символов Unicode</li>
</ul>
<pre><code class="js">
alert('Б' > 'А');        // true
alert('а' > 'Я');        // true, строчные буквы больше прописных
alert('Банан' > 'Анна'); // true, если первая буква первой строки больше – значит первая строка больше, независимо от остальных символов
alert('Привет' > 'Прив'); // true, любая буква больше отсутствия буквы
</code></pre>

<h3>Сравнение разных типов</h3>
<ul class="list-point">
	<li>При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям</li>
</ul>
<pre><code class="js">
alert('2' > 1);    // true, сравнивается как 2 > 1
alert( '01' == 1); // true, сравнивается как 1 == 1
alert(false == 0); // true, false становится числом 0
alert(true == 1);  // true, так как true становится числом 1.
</code></pre>

<h3>Сравнение с null и undefined</h3>
<ul class="list-point">
	<li>Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё</li>
	<li>При преобразовании в число null становится 0, а undefined становится NaN</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="attribute">Атрибуты</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var a1 = element.attributes;         // массив атрибутов
var a2 = element.hasAttribute('id'); // проверить наличие атрибута
var a3 = element.getAttribute('id'); // получить значение атрибута
element.setAttribute('id', 'new');   // установить атрибут
element.removeAttribute('id');       // удалить атрибут
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="document-open">Open / Location</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Открытие окна</h3>
<pre><code class="js">
var newWin = window.open('', 'Новое окно', 'width=400, height=300');
newWin.document.write('Вывод информации в новом окне');
newWin.close(); // закрыть созданное окно
</code></pre>

<h4>Переход на страницу</h4>
<pre><code class="js">
window.open();
// 1 – какую страницу загружать 
// 2 – название окна
// 3 – опции окна
</code></pre>

<pre><code class="js">
window.location.href = 'page.html'; // переходим на страницу (на этой же странице)
window.open('page.html');           // переходим на страницу (в новой вкладке)
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="document-width">Width / Height</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Width / Height</h3>
<pre><code class="js">
var a1 = window.innerWidth;                     // ширина окна пользователя
var a2 = window.innerHeight;                    // высота окна пользователя

var a3 = document.body.clientWidth;             // ширина документа (если body margin:0, совпадает с innerWidth)
var a4 = document.body.clientHeight;            // высота документа (по контенту body)

var a5 = document.documentElement.clientWidth;  // ширина документа (совпадает с innerWidth)
var a6 = document.documentElement.clientHeight; // высота документа (совпадает с innerHeight)
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="document-media">Media queries</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Media queries</h3>
<pre><code class="js">
var screen = <bg-code>window.matchMedia</bg-code>('(max-width:500px)');
if (screen.<bg-code>matches</bg-code>) {
	console.log('<500px');
} else {
	console.log('>500px');
}
</code></pre>

<pre><code class="js">
var screen = window.matchMedia('(max-width:500px)');
screen.addListener(changes);
changes(screen);

function changes(screen) {
	if (screen.matches) {
		console.log('<500px');
	} else {
		console.log('>500px');
	}
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="dom-element">DOM элементы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>Document Object Model (DOM) </bg-list> - объектная модель представления документа. Независящий от платформы и языка программирования способ представления документа, позволяющий программам и скриптам получить доступ к содержимому HTML, XHTML и XML документов, а также изменять содержимое, структуру и оформление таких документов</li>
	<li><bg-list>DOM</bg-list> - представление документа в виде дерева тегов, доступное для изменения через JS</li>
	<li>Всё содержимое документа представлено в виде иерархии объектов</li>
	<li>Структура этой иерархии стандартизирована, чтобы обеспечить независимость от платформы</li>
</ul>

<ul class="list-point">
	<b>Узлы (nodes)</b>
	<li><bg-list>Тип "element"</bg-list> - каждый HTML тег создает узел (node) дерева</li>
	<li><bg-list>Тип "element" дочерние узлы</bg-list> - вложенные в него элементы</li>
	<li><bg-list>Тип "text"</bg-list> - для представления текста</li>
</ul>

<pre><code class="js">
var a = element.<bg-code>tagName</bg-code>;  // название тега (если текстовый узел будет undefined)
var a = element.<bg-code>nodeName</bg-code>; // название узла (узел элемента или тексовый узел)
var a = element.<bg-code>nodeType</bg-code>; // тип узла (узел элемента 1 или текстовый узел 3)
</code></pre>

<pre><code class="js">
<em>createElement();</em>    // создать узел элемента
<em>createTextNode();</em>   // создать текстовый узел 
<em>appendChild();</em>      // добавить элемент перед
<em>insertBefore();</em>     // добавить элемент после
<em>removeChild();</em>      // удалить элемент
</code></pre>

<h4>Создание</h4>
<pre><code class="js">
var element = document.<bg-code>createElement</bg-code>('div');
element.innerHTML = 'Go to google';
element.className = 'class-google';
</code></pre>

<h4>Добавление на страницу</h4>
<pre><code class="js">
var wrapper = document.querySelector('#wrapper');

wrapper.<bg-code>appendChild</bg-code>(element);                      // внутри элемента после контента
wrapper.<bg-code>insertBefore</bg-code>(element, wrapper.lastChild);  // внутри элемента перед контентом
wrapper.parentNode.<bg-code>insertBefore</bg-code>(element, wrapper); // после элемента
wrapper.parentNode.<bg-code>appendChild</bg-code>(element);           // до элемента
wrapper.parentNode.<bg-code>replaceChild</bg-code>(element, wrapper); // заменить элемент другим элементом

// insertBefore (1 - элемент который вставляем, 2 - элемент перед которым вставляем)
// insertBefore (1 - чем заменяем, 2 - что заменяем)
</code></pre>

<h4>Удаление</h4>
<pre><code class="js">
wrapper.parentNode.<bg-code>removeChild</bg-code>(element); // удаление нового элемента
wrapper.parentNode.<bg-code>removeChild</bg-code>(wrapper); // удаление элемента обертки
document.body.<bg-code>removeChild</bg-code>(element);      // удаление нового элемента (если родитель body)
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="css">CSS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
element.<bg-code>style</bg-code>.fontSize = '20px';              // css
</code></pre>

<pre><code class="js">
element.classList;                            // массив классов элемента
element.classList.<bg-code>add</bg-code>('active');              // добавление класса
element.classList.<bg-code>remove</bg-code>('active');           // удаление класса
element.classList.<bg-code>toggle</bg-code>('active');           // добавление / удаление класса
var a = element.classList.<bg-code>contains</bg-code>('active'); // проверяет наличие класса (true/false)
var a = element.classList.<bg-code>item</bg-code>(0);            // вернет название класса по индексу 
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-api">Web API</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<!------------------------------------------------------>
<h3>Определения</h3>
<!------------------------------------------------------>
<ul class="list">
	<li><bg-list>document</bg-list> - документ, который загружается в браузер</li>
	<li><bg-list>window</bg-list> - окно браузера</li>
</ul>
<ul class="list">
	<b>Window</b> - глобальный объект, состоит из
	<li><bg-list>1. DOM</bg-list> - объектная модель документа</li>
	<li><bg-list>2. BOM</bg-list> - объектная модель браузера</li>
	<li><bg-list>3. Глобальные переменные, объекты, функции</bg-list>  и т.д.</li>
</ul>

<!------------------------------------------------------>
<h3>1. window.document</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = window.document; // html документ
document.write("Текст"); // вывод на экран
</code></pre>

<!------------------------------------------------------>
<h3>2. Navigator - информация о браузере и ОС</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = navigator.userAgent;     // название браузера
var a = navigator.platform;      // ОС
var a = navigator.language;      // язык браузера
var a = navigator.oscpu;         // название операционной системы
var a = navigator.cookieEnabled; // включены ли куки
var a = navigator.onLine;        // подключен ли пользователь к Интернету
</code></pre>

<!------------------------------------------------------>
<h3>3. Screen - данные о экране пользователя</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = screen.width;       // ширина экрана
var a = screen.height;      // высота экрана
var a = screen.availWidth;  // доступная ширина (на сколько можно раскрыть браузер не в полноэкранном режиме)
var a = screen.availHeight; // доступная высота
var a = screen.colorDepth;  // глубина цвета
</code></pre>

<!------------------------------------------------------>
<h3>4. Location - информация о URL, возможность перезагрузить страницу</h3>
<!------------------------------------------------------>
<pre><code class="js">
location.reload();           // перезагрузка страницы
var a = location.href;       // адрес загруженной страницы
var a = location.toString(); // URL
location.href = 'page.html'; // переходим на страницу (на этой же странице)
</code></pre>

<pre><code class="js">
var a = window.location.pathname.split('/')[2];
var a = location.hash.slice(1);
</code></pre>

<h4>Ковертация URL</h4>
<pre><code class="js">
var encoded = encodeURI('http://google.com/на-русском');
var decoded = decodeURI(encoded);

console.log(encoded); // http://google.com/%D0%BD%D0%B0-%D1%80%D1%83%D1%81%D1%81%D0%BA%D0%BE%D0%BC
console.log(decoded); // http://google.com/на-русском
</code></pre>

<h4>Текущий адрес страницы без .html и символа "/" в начале</h4>
<pre><code class="js">
var currentUrl;        
// определяем строку пути относительно хоста страницы в формате "/page.html"       
currentUrl = location.pathname; 
// обрезаем символ "/" в начале и символы ".html" в конце
currentUrl = currentUrl.slice(1,currentUrl.length-5); 
</code></pre>

<h4>Поиск совпадений</h4>
<pre><code class="js">
// -1 - нет совпадений
var page = location.href.indexOf('/page/');
var page = location.pathname.indexOf('/page/');
</code></pre>

<!------------------------------------------------------>
<h3>5. History - вперед/назад по истории, позвляет без перезагрузки изменить страницу браузера</h3>
<!------------------------------------------------------>
<pre><code class="js">
window.history.back();         // эквивалент клика по кнопке назад
window.history.forward();      // эквивалент клика по кнопке вперед
window.history.go(-1);         // эквивалент history.back();
window.history.go(1);          // эквивалент history.forward();
var a = window.history.length; // количество страниц в стеке истории
</code></pre>

<pre><code class="js">
if (history && history.pushState) {
    // проверка поддержки history
}
</code></pre>

<!------------------------------------------------------>
<h3>6. Frames - содержит коллекцию всех дочерних объектов фреймов на странице</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = frames;
</code></pre>

<!------------------------------------------------------>
<h3>7. Вывод сообщения пользователю</h3>
<!------------------------------------------------------>
<pre><code class="js">
alert("Привет Мир");                      // модальное окно
var age = prompt('Сколько Вам лет?', ''); // модальное окно с вопросом и полем ввода
var answer = confirm('Вы согласны?');     // модальное окно да/нет (вернет bool значение)
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="form">Web Forms</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>input type="text"</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = element.<bg-code>value</bg-code>;
element.<bg-code>value</bg-code> = 'new value';
</code></pre>

<!------------------------------------------------------>
<h3>input type="checkbox"</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = element.<bg-code>checked</bg-code>; 
element.<bg-code>checked</bg-code> = true;
</code></pre>

<pre><code class="html">
&lt;input type="checkbox" onchange="func();"&gt; 
&lt;!-- onchange - изменение состояния --&gt;
</code></pre>

<!------------------------------------------------------>
<h3>input type="radio"</h3>
<!------------------------------------------------------>
<pre><code class="js">
var radio = document.querySelectorAll('input[type="radio"]');
for(var i=0; i<=radio.length-1; i++) {
	if(radio[i].<bg-code>checked</bg-code>) {
		var value = radio[i].getAttribute('value');
		console.log(value);
	}
}
</code></pre>

<pre><code class="js">
radio.<bg-code>disabled</bg-code> = true;         
</code></pre>	

<!------------------------------------------------------>
<h3>select</h3>
<!------------------------------------------------------>
<pre><code class="js">
var select = document.querySelector('select');
var a = select.<bg-code>value</bg-code>;
var a = select.<bg-code>options</bg-code>[select.selectedIndex].value;
var a = select.<bg-code>options</bg-code>[select.selectedIndex].text;
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="data-storage">Web Storage: Local Storage и Session Storage</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-data-storage">

<ul class="list-point">
	<b>Web Storage</b> - интернет-хранилище или DOM-хранилище<br>
	<b>Два основных типа веб-хранилища</b>
	<li>1. <bg-list>Локальное хранилище (localStorage)</bg-list> - аналогичен постоянным кукам. Доступно для всех скриптов из домена, который первоначально добавил данные и сохраняется после закрытия браузера. Не имеют определенного времени жизни</li>
	<li>2. <bg-list>Сессионное хранилище (sessionStorage)</bg-list> - аналогичен сессионным кукам. Сессия сохраняется по принципу одна страница-одно окно и ограничивается жизнью данного окна, то есть для каждого открытого окна создаётся новая сессия, которая прекращает своё существование при закрытии окна и не зависит от домена открывшего её. Сессия страницы остается активной все время пока окно браузера открыто и сохраняется между перезагрузками страниц. Открытие той же страницы в новом окне браузера или новой вкладке приводит к созданию новой сессии страницы, что отличается от поведения session cookies.</li>
</ul>

<ul class="list-point">
	<b>Особенности</b>
	<li>Не отправляются на сервер в отличие от Cookie</li>
</ul>

<!------------------------------------------------------>
<h3>Local Storage</h3>
<!------------------------------------------------------>
<p>Google Chrome -> F12 -> Application -> Local Storage</p>
<p>localStorage это свойство глобального объекта браузера (window)</p>
<pre><code class="js">
localStorage.<bg-code>setItem</bg-code>('id', '77');   // добавляет в localStorage новый ключ со значением (а если такой ключ уже существует, то перезаписывает новым значением)
var a = localStorage.<bg-code>getItem</bg-code>('id'); // получить значение
localStorage.<bg-code>removeItem</bg-code>('id');      // удаление ключа
localStorage.<bg-code>clear</bg-code>();               // очистка всего хранилища
</code></pre>

<pre><code class="js">
localStorage["Ключ"] = "Значение"; // установка значения
var a = localStorage["Ключ"];      // получение значения
delete localStorage["Ключ"];       // удаление значения
</code></pre>

<h4>Провека наличия ключа</h4>
<pre><code class="js">
if (localStorage.getItem('key') !== null) {...}
</code></pre>

<h4>Объекты и массивы</h4>
<pre><code class="js">
var obj = {
	item1: 1,
	item2: [123, "two", 3.0],
	item3: "hello"
};

localStorage.setItem("key", JSON.stringify(obj));        // сериализация объекта и запись в хранилище по ключу "key"
var returnObj = JSON.parse(localStorage.getItem("key")); // из json в объект
</code></pre>

<h4>Проверка QUOTA_EXCEEDED_ERR</h4>
<pre><code class="js">
// браузеры выделяют 5MB под localStorage
// при привышении исключение QUOTA_EXCEEDED_ERR
try {
	localStorage.setItem('ключ', 'значение');
} catch(e) {
	if (e == QUOTA_EXCEEDED_ERR) {
		console.log('Превышен лимит');
	}
}
</code></pre>

<!------------------------------------------------------>
<h3>Session Storage</h3>
<!------------------------------------------------------>
<pre><code class="js">
sessionStorage.<bg-code>setItem</bg-code>('key', 'value');   // сохранение данных в sessionStorage
var data = sessionStorage.<bg-code>getItem</bg-code>('key'); // получение данных из sessionStorage
sessionStorage.<bg-code>removeItem</bg-code>('key');         // удаление ключа
sessionStorage.<bg-code>clear</bg-code>();                   // очистка всего хранилища
</code></pre>

</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="data-db">IndexedDB</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-data-db">

<pre><code class="html">
<a href="https://developer.mozilla.org/ru/docs/IndexedDB/Using_IndexedDB" target="_blank">[MDN] Использование IndexedDB</a>
</code></pre>

<ul class="list-point">
	<li><bg-define>IndexedDB</bg-define> - это способ постоянного хранения данных внутри клиентского браузера. NOSQL хранилище на стороне клиента. Что позволяет создавать веб-приложения обращения к данным независимо от доступности сети, приложения могут работать как онлайн, так и офлайн</li>
</ul>

<alert-info>
1. Сначал вызывается dbCreate() для открытия/создания БД<br>
2. После dbInsert()
</alert-info>

<h4>Глобальная переменная</h4>
<pre><code class="js">
var db = null;
</code></pre>

<h4>Создание / открытие БД и обработчки событий</h4>
<pre><code class="js">
function dbCreate() {
	// Создание базы данных
	const request = <bg-code>window.indexedDB.open</bg-code>('dbName', 77); //create DB: name,version 

    // Обработчик create
	request.<bg-code-accent>onupgradeneeded</bg-code-accent> = function(event) {
	    db = event.target.result;     // => IDBDatabase {name: "dbTest", version: 1 ...}
	    //const name = db.name;         // => 'dbTest'
	    //const version = db.version;   // => '1'
	    const objectStore = <bg-code>db.createObjectStore</bg-code>('notes', { keyPath: 'title' });
	};
	request.<bg-code-accent>onsuccess</bg-code-accent> = function(event) {
	    db = event.target.result; 
	};
	request.<bg-code-accent>onerror</bg-code-accent> = function(event) {
	    console.error(event.target.error);
	    console.error(event.target.errorCode);
	};
}
</code></pre>

<h4>Добавление записи</h4>
<pre><code class="js">
function dbInsert() {
    const note = {
        title: 'My note',
        text: 'This is my note'
    }
    const tx = db.<bg-code>transaction</bg-code>('notes', 'readwrite');
    const notes = tx.<bg-code>objectStore</bg-code>('notes');
    notes.add(note);
}
</code></pre>

<h4>Выборка всех записей</h4>
<pre><code class="js">
function dbSelect() {
    const tx = db.<bg-code>transaction</bg-code>('notes', 'readonly');
    const notes = tx.<bg-code>objectStore</bg-code>('notes');
    const request = notes.<bg-code>openCursor</bg-code>();
    request.<bg-code-accent>onsuccess</bg-code-accent> = function(event) {
        const cursor = event.target.result;
        if (cursor) {
            console.log(cursor.key);        // => 'My note'
            console.log(cursor.value.text); // => 'This is my note'
            cursor.<bg-code>continue</bg-code>();
        }
    };
}
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="data-cookie">Cookie</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div id="ct-data-cookie">

<ul class="list-point">
	<b>Типы куки</b>
	<li><bg-define>Сессионные куки</bg-define> временные куки, существуют только во временной памяти, пока пользователь находится на странице веб-сайта. Браузеры обычно удаляют сессионные куки после того, как пользователь закрывает окно браузера. В отличие от других типов куки, сессионные куки не имеют истечения срока действия</li>
	<li><bg-define>Постоянные куки</bg-define> постоянные куки-файлы удаляются в определённую дату или через определённый промежуток времени. Это означает, что информация о куки будет передаваться на сервер каждый раз, когда пользователь посещает веб-сайт, которому эти куки принадлежат</li>
	<li><bg-define>Защищенные куки</bg-define> могут быть переданы только через шифрованное соединение (то есть HTTPS). Они не могут передаваться по незащищенным соединениям. Чтобы защитить куки, необходимо добавить флаг Secure в файл куки</li>
	<li><bg-define>HttpOnly-куки</bg-define> нельзя обращаться с помощью API на стороне клиента, таких как JS</li>
</ul>

<ul class="list-point">
	<b>Особенности</b>
	<li>Данные отправляются обратно на сервер для каждого HTTP-запроса</li>
	<li>Куки могут устанавливать дату их удаления, в этом случае они будут автоматически удалены браузером в указанный срок. Если дата удаления не указана, куки удаляются сразу, как только пользователь закроет браузер. Таким образом, указание даты истечения позволяет сохранить куки более чем на один сеанс и такие куки называются постоянными</li>
	<li>Работают только на веб-сервере</li>
</ul>

<pre><code class="js">
<bg-code>document.cookie</bg-code> = 'info=123';                                        // установить cookie (удаляются при закрытии браузера)
<bg-code>document.cookie</bg-code> = 'info=123; expires=Fri, 31 Dec 2018 23:59:59 GMT'; // установить cookie (удалятся 31.12.2018)
var a = <bg-code>document.cookie</bg-code>;                                             // прочитать cookie
</code></pre>

<h4>Атрибуты куки</h4>
<pre><code class="js">
document.cookie = 'info=123; expires=Fri, 31 Dec 2018 23:59:59 GMT; path=/; domain=.example.org';
</code></pre>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="methods-this">Context (this, call, apply, bind)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>this</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-define>Контекст выполнения (execution context)</bg-define> - служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор. У каждого вызова функции свой «контекст выполнения» и он всегда разный в зависимости от того как функция была вызвана</li>
	<li><bg-define>Контекст вызова функции</bg-define> - тот объект который ее вызывает</li>
	<li><bg-define>this</bg-define> - ссылка на текущий контекст вызова (на текущий объект с которым произошло событие). Определяется в момент вызова функции</li>
	<li>Любая функция может иметь в себе <u>this</u>. Если функция использует <u>this</u> - это подразумевает работу с объектом</li>
	<li><u>this</u> - это текущий объект при вызове «через точку» и новый объект при конструировании через <u>new</u></li>
	<li><u>Функции</u> не привязаны к своему контексту <u>this</u></li>
	<li>В глобальном контексте this указывает на глобальный объект, в функциональном контексте this указывает на контекст, откуда функция вызвана</li>
	<li>В функции, обрабатывающей событие <u>DOM</u>, <u>this</u> указывает на <u>DOM</u> элемент, который вызвал событие</li>
</ul>

<h4>Значение this устанавливается в зависимости от того, как вызвана функция</h4>
<p>1. При вызове функции как метода</p>
<pre><code class="js">
obj.func(...)    // this = obj
obj["func"](...)
</code></pre>

<p>2. При обычном вызове</p>
<pre><code class="js">
func(...) // this = window (ES3) /undefined (ES5)
</code></pre>

<p>3. В new</p>
<pre><code class="js">
new func() // this = {} (новый объект)
</code></pre>

<p>4. Явное указание</p>
<pre><code class="js">
func.apply(context, args) // this = context (явная передача)
func.call(context, arg1, arg2, ...)
</code></pre>

<!------------------------------------------------------>
<h3 id="methods-this-bind">bind(), call(), apply() - использование другого контекста</h3>
<!------------------------------------------------------>
<pre><code class="js light">
<table>
	<tr><td><bg-methods>call</bg-methods><bg-arguments>()</bg-arguments></td><td>  // явное указание контекст вызова</td></tr>
	<tr><td><bg-methods>apply</bg-methods><bg-arguments>()</bg-arguments></td><td>  // аналогичен call(), только аргументы передаются массивом вторым аргументом</td></tr>
	<tr><td><bg-methods>bind</bg-methods><bg-arguments>()</bg-arguments></td><td>  // не вызывает функцию, а связывает с объектом. не изменяет исходную функцию, а возвращает новую</td></tr>
</table></code></pre>

<ul class="list-point">
	<li><u>call/apply</u> вызывают функцию с заданным контекстом и аргументами</li>
	<li><u>bind</u> не вызывает функцию, а только возвращает «обёртку», которая передаст вызов в исходную функцию, с привязанным контекстом</li>
	<li><u>Function.prototype.bind</u> возвращает копию функции, заменяя при этом упоминающиеся в ней <u>this</u> на объект, указанный в аргументе. На функции, возвращенной методом bind, нельзя использовать bind еще раз</li>
</ul>

<pre><code class="js">
var greet = function(greet1, greet2) {
	return greet1 + greet2 + this.name;
}
var person = {
	name: 'Brad',
	greet: greet
}
var anotherPerson = {
	name: 'Tony',
	greet: greet
}
</code></pre>

<ul class="list-point">
	<li>Если в <u>bind</u> указаны аргументы - они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове</li>
</ul>

<pre><code class="html">
<a href="theory.html#currying" target="_blank">[Local] Каррирование</a>
</code></pre>




<pre><code class="js">
// this указывает на person
var a = anotherPerson.greet.<bg-code>call</bg-code>(person, 'Hello', 'World');    // => "Hello World Brad"
var a = anotherPerson.greet.<bg-code>apply</bg-code>(person, ['Hello', 'World']); // => "Hello World Brad"

var b = greet.<bg-code>bind</bg-code>(person); // без аргументов
var a = b('Hello', 'World'); // => "Hello World Brad"

var b = greet.<bg-code>bind</bg-code>(person, 'Hello', 'World'); // с аргументами
var a = b(); // => "Hello World Brad"
</code></pre>

<pre><code class="js">
// call/apply передают this «как есть»
function f() {
	alert( this ); // null
}
f.call(null);
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>
<h4>Потеря контекста</h4>
<pre><code class="js">
var user = {
	userName: 'Tony',
	userGreet() {
		console.log('Hi ' + this.userName);
	}
};
var newUser = user.userGreet; 
newUser(); // => "Hi undefined"
</code></pre>
<pre><code class="js">
newUser.call(user); // => "Hi Tony"
</code></pre>
<pre><code class="js">
var func = newUser.bind(user);
func(); // => "Hi Tony" 
</code></pre>

<h4>Привязать всё</h4>
<pre><code class="js">
for (var prop in user) {
	if (typeof user[prop] == 'function') {
		user[prop] = user[prop].bind(user);
	}
}
</code></pre>

<h4>Вызов функции</h4>
<pre><code class="js">
function showFullName() {
	alert( this.firstName + " " + this.lastName );
}
var user = {
	firstName: "Василий",
	lastName: "Петров"
};
showFullName.call(user) // => "Василий Петров" (функция вызовется с this=user)
</code></pre>

<h4>Максимальный элемент массива</h4>
<pre><code class="js">
var arr = [1, 2, 3, 77, 4];
var max = Math.max.apply(null, arr); // 77 (контекстом будет объект Math)
var max = Math.max.apply(Math, arr); // 77 (контекстом будет объект Math) - аналогично
// в данном случае в качестве контекста можно передавать что угодно, 
// поскольку в своей внутренней реализации метод Math.max не использует this
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-chaining">Method Chaining (Цепные вызовы методов)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var str1 = 'Hello';
var str2 = str1
    .replace('a', 'b')
    .concat(' add')
    .toUpperCase();
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="json">JSON</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li><bg-list>JSON</bg-list> - JavaScript Object Notation</li>
	<li><bg-list>Сериализация объектов</bg-list> - преобразование объектов в строки</li>
	<li><bg-list>В JSON можно хранить</bg-list> - объекты, массивы, строки, числа true, false, null. Другие значения при сериализации превращаются в null</li>
</ul>

<pre><code class="js light">
<bg-methods>JSON.parse(str, reviver)</bg-methods> // преобразует строку с данными в формате JSON в JavaScript-объект/массив/значение
	<em>&#8226; str</em>     // строка с данными в формате JSON
	<em>&#8226; reviver</em> // задание правила, функция function(key, value)
<bg-methods>JSON.stringify(value, replacer, space)</bg-methods> // преобразует («сериализует») значение в JSON-строку
	<em>&#8226; value</em>    // значение
	<em>&#8226; replacer</em> // массив свойств, которые подлежат сериализации
	<em>&#8226; space</em>    // форматирование. если число, то уровни вложенности в JSON оформляются указанным количеством пробелов, если строка, то вставляется эта строка
</code></pre>

<pre><code class="js">
var user = {
    name: 'Tony',
    id: 25
}
var userData = <bg-code>JSON.stringify</bg-code>(user); // объект в JSON ("{"name":"Tony","id":25}")
var userObj = <bg-code>JSON.parse</bg-code>(userData);  // JSON в строку
</code></pre>

<h4>Метод toJSON</h4>
<pre><code class="js">
// если в объекте есть метод toJSON при преобразовани stringify данные будут браться из него
// если такого метода нет - перечисляются его свойства, кроме функций
var user = {
    name: 'Tony',
    id: 25,
    toJSON() {
        return {
            name: this.name
        }
    }
}
var userData = JSON.stringify(user); // объект в JSON ("{"name":"Tony"}")
</code></pre>

<h4>JSON.parse(str, reviver). Умный разбор</h4>
<ul class="list-point">
	<li>Для интеллектуального восстановления из строки у JSON.parse(str, reviver) есть второй параметр reviver, который является функцией <e>function(key, value)</e></li>
	<li>Если она указана, то в процессе чтения объекта из строки JSON.parse передаёт ей по очереди все создаваемые пары ключ-значение и может возвратить либо преобразованное значение, либо undefined, если его нужно пропустить</li>
</ul>
<pre><code class="js">
var str = '{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}';
var event = JSON.parse(str, function(key, value) {
	if (key == 'date') return new Date(value);
	return value;
});
alert( event.date.getDate() );
</code></pre>

<h4>JSON.stringify. Исключение свойств</h4>
<pre><code class="js">
var user = {
	name: "Вася",
	age: 25,
	window: window
};
alert( JSON.stringify(user, ["name", "age"]) ); // {"name":"Вася","age":25}
</code></pre>

<h4>JSON.stringify. Исключение свойств (передача функции)</h4>
<ul class="list-point">
	<li>Вторым параметром можно передать функцию <u>function(key, value)</u>, которая возвращает сериализованное <u>value</u> либо <u>undefined</u>, если его не нужно включать в результат</li>
	<li>Функция replacer работает рекурсивно. Если объект содержит вложенные объекты, массивы и т.п., то все они пройдут через replacer</li>
</ul>
<pre><code class="js">
var user = {
	name: "Вася",
	age: 25,
	window: window
};
var str = JSON.stringify(user, function(key, value) {
	if (key == 'window') return undefined;
	return value;
});
alert( str ); // {"name":"Вася","age":25}
// функция пропустит свойство с названием window
// для остальных она возвращает значение, передавая его стандартному алгоритму
</code></pre>

<h4>JSON.stringify. Форматирование</h4>
<pre><code class="js">
var user = {
	name: "Вася",
	age: 25,
	roles: {
		isAdmin: false,
		isEditor: true
	}
};

var str = JSON.stringify(user, "", 4); // => отформатированный текст
</code></pre>




<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="strict-mode">Strict Mode</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<p>Может быть прописано в начале файла или в начале функции</p>
<pre><code class="js">
'use strict';
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="regexr">Регулярные выражения</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="html">
<a href="https://regexr.com/" target="_blank">https://regexr.com/</a>
</code></pre>

<!------------------------------------------------------>
<h3>Expression Flags</h3>
<!------------------------------------------------------>
<pre><code class="html">
<em>//g</em>          - global (все совпадения)
<em>//i</em>          - case insensitive (регистронезависимый поиск)
<em>//m</em>          - multiline
<em>//u</em>          - unicode
<em>//y</em>          - sticky
</code></pre>

<pre><code class="html">
<em>[]</em>           - класс символов
<em>/[a-zA-Z]/g</em>  - глобальный поиск
</code></pre>

<!------------------------------------------------------>
<h3>Expressions</h3>
<!------------------------------------------------------>
<pre><code class="html">
<em>a-zA-Z</em>               - строчные и заглавне буквы
<em>0-9</em>                  - символы от 0-9
<em>^0-9</em>                 - символы кроме чисел от 0-9 
<em>\d</em>                   - символы от 0-9
<em>\D</em>                   - символы кроме чисел от 0-9
<em>\w</em>                   - символы, являющиеся буквами или цифрами
<em>\W</em>                   - символы, не являющиеся буквами или цифрами
<em>\s</em>                   - пустые символы (пробелы, табуляция, перенос строк)
<em>\S</em>                   - все не пустые символы
<em>\bar\b</em>               - граница слова. только слово "bar"
<em>\bar\B</em>               - не должно быть границы слова. только символы "bar" в слове
<em>grey|gray</em>            - или
<em>.</em>                    - любой символ кроме переноса строк
<em>\.</em>                   - точка (экранированно /)
<em>a.{5}z</em>               - между буквами "a" и "z" 5 любых символов
<em>a.{2,5}z</em>             - между буквами "a" и "z" от 2-5 любых символов
<em>a.{2,}z</em>              - между буквами "a" и "z" от 2 и более любых символов
<em>a.+z</em>                 - между буквами "a" и "z" от 1 и более любых символов
<em>a.*z</em>                 - между буквами "a" и "z" от 0 и более любых символов
<em>^edit</em>                - начало строки (установить multiline)
<em>\.$</em>                  - конец строки (установить multiline)
<em>and(?= hi)</em>           - слова "and" после которых есть пробел и слово "hi"
<em>and(?! hi)</em>           - слова "and" после которых нет пробела и слова "hi"
<em>(\b\w+)@(\w+\.\w+\b)</em> - запоминающая группа. поиск email
</code></pre>

<!------------------------------------------------------>
<h3>Класс RegExp</h3>
<!------------------------------------------------------>
<pre><code class="js">
var pattern = new RegExp('\w+', 'g'); // конструктор
var pattern = /\w+/g;                 // литерал
</code></pre>

<h4>Свойства, доступные для чтение</h4>
<pre><code class="js">
pattern.global;
pattern.ignoreCase;
pattern.mutiline;
pattern.lastIndex; // индекс последнего результата
</code></pre>

<h4>test() - проверка соответствия строки регулярному выражению (true/false)</h4>
<pre><code class="js">
var text = "О дивный новый мир";
var pattern = /новый/;
var result = pattern.test(text); 
</code></pre>

<h4>exec() - аналогичен match()</h4>
<pre><code class="js">
// если не установлен флаг global, результат аналогичен методу match
// если установлен флаг global, получаем 1 первый match
var text = "О дивный новый мир";
var pattern = /новый/g;
var result = pattern.exec(text); 
</code></pre>

<!------------------------------------------------------>
<h3>Строки</h3>
<!------------------------------------------------------>

<h4>search() - возвращает позицию первого элемента</h4>
<pre><code class="js">
// игнорирует флаг global
var text = "О дивный новый мир";
var pattern = /мы/;
var result = text.search(pattern); // 9
</code></pre>

<h4>match() - возвращает само совпадение</h4>
<pre><code class="js">
// не игнорирует флаг global
var text = "О дивный новый мир";
var pattern = /новый/;
var result = text.match(pattern); // ["новый", index: 9, input: "О дивный новый мир", groups: undefined]
</code></pre>

<h4>split() - преобразование строки с заданным разделителем в массив </h4>
<pre><code class="js">
var pattern = /[\s,]+/;
var result = text.split(pattern); // разделитель пробел
</code></pre>

<h4>replace() - ищет совпадение и заменяет</h4>
<pre><code class="js">
var text = 'привет мир';
var pattern = /привет/;

text = text.replace(pattern, function(match) {
    return match.toUpperCase();
});
</code></pre>

<pre><code class="js">
str = str.replace(/'/g, '"');         // поменять одинарные кавычки на двойные
str = str.replace(/«/g, '"');         // поменять « 
str = str.replace(/»/g, '"');         // поменять »
str = str.replace(/–/g, '-');         // поменять "–"
str = str.replace(/\r|\n/g, '');      // убрать перенос строки
str = str.replace(/<\/?[^>]+>/g, ''); // удалить html теги из текста
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="collback">Collback Function</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list">
	<li><bg-list>callback function</bg-list> - функция обратного вызова button.onclick = function() {}</li>
</ul>

<pre><code class="js">
fade(this, 1000, function() {
	this.style.display = 'none';
})
function fade(element, time, callbackFunction) {
	// если callback не задан, создаем пустую функцию
	var callback = callbackFunction || function() {};
	// вызываем callback когда необходимо
	callback.call(element); // передать новый контекст this
}
</code></pre>

<pre><code class="js">
var greeting = function(callback) {
	var name = 'Tony';
	return callback(name);
}
var a = greeting(function(name) {
	return 'Hello ' + name;
});
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="iterators">Итераторы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>Итерируемый, перебираемый объект (Iterable)</bg-list> - объект содержание которого можно перебрать по одному элементу. Пример: массив, строка, коллекция dom-элементов</li>
	<li><bg-list>Итератор</bg-list> - паттерн проектирования, согласно которому источник элементов прячется от клиента. Клиенту достается специальный объект с помощью которого он может получить элементы по одному. Клиенту не нужно беспокоиться о том как итерировать объект, при этом внутри самого объекта автор может использовать любую структуру для хранения элементов и любой алгоритм для их перебор. Клиент не получает саму структуру и автору не нужно беспокоиться что клиент может ее изменить</li>
	<li><bg-list>Объект является итератором</bg-list>, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая свое текущее положение внутри этой последовательности</li>
	<li><bg-list>Конструкция for..of</bg-list> в начале своего выполнения автоматически вызывает Symbol.iterator(), получает итератор и далее вызывает метод next() до получения done: true. Такова внутренняя механика. Внешний код при переборе через for..of видит только значения</li>
	<li><bg-list>Интераторы</bg-list> используются для реализации генераторов</li>
</ul>

<ul class="list-point">
	<b>Плюсы</b>
	<li>Разные языковые конструкции работают с разными структурами данных по одному принципу в не зависимости от их внутренней реализации</li>
	<li>Можно написать собственную структуру данных, реализовать интерфейс iterable и работать с ней с помощью конструкций for...of, spread-операторов, Array.from и т.д.</li>
</ul>

<h4>Перебор через for...of</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
for(var item of arr) {
    console.log(item);
}
</code></pre>

<h4>Перебор через встроенный итератор</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
var iterator = arr[<bg-code>Symbol.iterator</bg-code>]();
console.log(iterator.<bg-code>next()</bg-code>); // {value: "js", done: false}
console.log(iterator.<bg-code>next()</bg-code>); // {value: "python", done: false}
console.log(iterator.<bg-code>next()</bg-code>); // {value: "ruby", done: false}
console.log(iterator.<bg-code>next()</bg-code>); // {value: undefined, done: true}
</code></pre>

<h4>Перебор через встроенный итератор в цикле</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
var iterator = arr[Symbol.iterator]();
var next = iterator.next();
// по похожему алгоритму работает for...of
while (!next.done) {
    console.log(next.value);
    next = iterator.next();
}
</code></pre>

<h4>Создание итератора</h4>
<pre><code class="js">
// итерируемый объект
// числа от 1 до 100
let idGenerator = {
    [Symbol.iterator]() {
        let id = 1;
        return {
            next() {
                let value = id++;
                let done = false;
                return {value, done};
            }
        };
    }
};
// используя цикл
// for(let id of idGenerator) {
//     console.log(id);
//     if (id > 100) {
//         break;
//     }
// }
// доступ к итератору
let num = idGenerator[Symbol.iterator]();
console.log(num.next().value);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="promise">Promise (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list">
	<li><bg-define>Promise</bg-define> - специальный объект, который хранит своё состояние, текущий результат (если есть) и коллбэки</li>
	<li><bg-define>Промисификация</bg-define> - обертка над асинхронным функционалом, возвращающая промис</li>
	<li><bg-define>Чейнинг (chaining)</bg-define> - цепочки промисов .then…then…then, в каждый следующий then переходит результат от предыдущего</li>
	<li class="margin-top"><b>Состояния Promise</b></li>
	<ul class="list-point">
		<li><u>pending</u> - ожидание (выполняется)</li>
		<li><u>fulfilled</u> - выполнено успешно</li>
		<li><u>rejected</u> - выполнено с ошибкой</li>
	</ul>
	<li class="margin-top"><b>На promise можно навешивать коллбэки двух типов</b></li>
	<ul class="list-point">
		<li><u>onFulfilled</u> – срабатывают, когда promise в состоянии «выполнен успешно»</li>
		<li><u>onRejected</u> – срабатывают, когда promise в состоянии «выполнен с ошибкой»</li>
	</ul>
</ul>

<ul class="list-point">
	<li>При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, которая должна вызвать resolve(result) при успешном выполнении и reject(error) – при ошибке</li>
	<li><bg-code>Promise</bg-code> после <bg-code>reject/resolve</bg-code> - неизменны. Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда</li>
	<li>Если говорить о взаимодействии с API, то <bg-code>catch</bg-code> используется для обработки http статусов <u>4xx 5xx</u>, <bg-code>then</bg-code> это статусы <u>2xx</u></li>
	<li>Отсутствии внешнего .catch не останавливает выполнение скрипта. Когда обработчик в промисах делает <bg-code>throw</bg-code> – в данном случае, при ошибке запроса, то такая ошибка не останавливает выполнение скрипта и не выводится в консоли. Она просто будет передана в ближайший следующий обработчик onRejected</li>
</ul>

<!------------------------------------------------------>
<h3>Методы</h3>
<!------------------------------------------------------>

<pre><code class="js light">
<table>

	<tr><td><bg-methods>new Promise</bg-methods><bg-arguments>(executor)</bg-arguments></td><td>  // конструктор промиса</td></tr>
	<tr><td><em>	&#8226; resolve(result)</em></td><td>  // результат передается аргументом в .then</td></tr>
	<tr><td><em>	&#8226; reject(error)</em></td><td>  // ошибка передается аргументом в .catch</td></tr>

	<tr><td><bg-methods>.then</bg-methods><bg-arguments>(onFulfilled)</bg-arguments></td><td>  // выполняется обработчик onFulfilled</td></tr>
	<tr><td><em>	&#8226; result</em></td><td>  // функция или код при успешном выполнении</td></tr>

	<tr><td><bg-methods>.catch</bg-methods><bg-arguments>(onRejected)</bg-arguments></td><td>  // выполняется обработчик onRejected</td></tr>
	<tr><td><em>	&#8226; error</em></td><td>  // функция или код при неуспешном выполнении</td></tr>

	<tr><td><bg-methods>Promise.all</bg-methods><bg-arguments>(iterable)</bg-arguments></td><td>  // возвращает промис, который ждёт, пока все переданные промисы завершатся</td></tr>
	<tr><td><em>	&#8226; iterable</em></td><td>  // [p1, p2, p3] промисы</td></tr>

	<tr><td><bg-methods>Promise.race</bg-methods><bg-arguments>(iterable)</bg-arguments></td><td>  // результатом будет только первый успешно выполнившийся промис из списка</td></tr>
	<tr><td><em>	&#8226; iterable</em></td><td>  // [p1, p2, p3] промисы</td></tr>

	<tr><td><bg-methods>Promise.resolve</bg-methods><bg-arguments>(value)</bg-arguments></td><td>  // создаёт успешно выполнившийся промис с результатом value</td></tr>
	<tr><td><em>	&#8226; value</em></td><td>  // результат</td></tr>

	<tr><td><bg-methods>Promise.reject</bg-methods><bg-arguments>(error)</bg-arguments></td><td>  // создаёт уже выполнившийся промис с ошибкой error</td></tr>
	<tr><td><em>	&#8226; value</em></td><td>  // ошибка</td></tr>

</table></code></pre>

<!------------------------------------------------------>
<h3>Создание Promise</h3>
<!------------------------------------------------------>
<pre><code class="js">
functin functionAsync() {
	var promise = new <bg-code>Promise</bg-code>(function(resolve, reject) {
		// любые асинхронные операции
		// resolve(результат) при успешном выполнении
		// reject(ошибка) при ошибке
		const isSuccess = (Math.random() * 100) <= 70;
	    if (isSuccess) {
	        <bg-code>resolve</bg-code>('ok');
	    } else {
	        <bg-code>reject</bg-code>(new Error('Api error')); // аналогично
	        throw new Error('Api error');   // аналогично
	    }
	});
	return promise;
}
</code></pre>

<pre><code class="js">
functionAsync()
	// resolve
    <bg-code>.then</bg-code>(result => {
        console.log(result);
    })
    // reject
    <bg-code>.catch</bg-code>(error => console.error(error)); // Error: Api error
    // .catch(error => console.error(error.message)); // Api error
</code></pre>

<!------------------------------------------------------>
<h3>Обработка Promise в асинхронных операциях</h3>
<!------------------------------------------------------>
<h4>Первый вариант (один then)</h4>
<pre><code class="js">
functionAsync()
	<bg-code>.then</bg-code>(functionResolve, functionReject);
	// functionResolve - функция, которая сработает если обещание выполняется
	// functionReject  - функция, которая сработает если обещание не будет выполнена
</code></pre>

<h4>Второй вариант (несколько then)</h4>
<pre><code class="js">
functionAsync()
	<bg-code>.then</bg-code>(functionResolve1)
	<bg-code>.then</bg-code>(functionResolve2)
	<bg-code>.catch</bg-code>(functionReject);
</code></pre>

<h4>Третий вариант (вызванная функция)</h4>
<pre><code class="js">
functionAsync()
	<bg-code>.then</bg-code>(functionResolve1()) // вызванная функция пропускается
</code></pre>



<!------------------------------------------------------>
<h3>«Чейнинг» (цепочки промисов)</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><u>«Чейнинг» (chaining)</u> - цепочки промисов. При чейнинге, то есть последовательных вызовах <u>.then…then…then</u>, в каждый следующий then переходит результат от предыдущего. Если очередной <u>then вернул промис</u>, то далее по цепочке будет передан не сам этот промис, а его результат. </li>
	<li>Если then возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать</li>
	<li>Общее правило: если внутри then стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис</li>
</ul>

<pre><code class="js">
function functionAsync1() {
	var promise = new Promise(function(resolve, reject) {
	    resolve('promise1');
	});
	return promise;
}
function functionAsync2() {
	var promise = new Promise(function(resolve, reject) {
	    resolve('promise2');
	});
	return promise;
}
functionAsync1()
    <bg-code>.then</bg-code>(res => console.log(res)) // promise1
    <bg-code>.then</bg-code>(functionAsync2)
    <bg-code>.then</bg-code>(res => console.log(res)) // promise2
</code></pre>

<!------------------------------------------------------>
<h3>Внутренние свойства new Promise(executor)</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<b>new Promise(executor)</b>
	<li><u>PromiseState</u>            - состояние (вначале «pending»)</li>
	<li><u>PromiseResult</u>           - результат (при создании значения нет)</li>
	<li><u>PromiseFulfillReactions</u> - список функций-обработчиков успешного выполнения</li>
	<li><u>PromiseRejectReactions</u>  - список функций-обработчиков ошибки</li>	
</ul>

<ul class="list-point">
	<li>1. Когда функция-<bg-code>executor</bg-code> вызывает reject или resolve, то <bg-code>PromiseState</bg-code> становится"resolved" или "rejected", а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь <bg-code>"PromiseJobs"</bg-code></li>
	<li>2. Все функции-обработчики из очереди <bg-code>"PromiseJobs"</bg-code> выполняются асинхронно, один за другим, по завершении текущего кода</li>
	<li>3. Исключение из этого правила – если resolve возвращает другой Promise. Тогда дальнейшее выполнение ожидает его результата (в очередь помещается специальная задача), и функции-обработчики выполняются уже с ним</li>
	<li>4. В конце срабатывает общий обработчик <bg-code>genericError</bg-code>, который перехватывает любые ошибки</li>
</ul>

<pre><code class="js">
// промис выполнится сразу же
var promise = new Promise((resolve, reject) => resolve(1));
promise.then( function f1(result) {
	alert(result); // 1
	return 'f1';
})
promise.then( function f2(result) {
	alert(result); // 1
	return 'f2';
})
// PromiseState            - "resolved"
// PromiseResult           - 1
// PromiseFulfillReactions - [f1, f2]
// PromiseRejectReactions  - [Thrower, Thrower] Thrower – стандартная внутренняя функция, которая автоматически используется, если второй обработчик (reject) не указан

// В примере не используется чейнинг, обработчики добавляются именно на один и тот же промис
// Все функции из списка обработчиков вызываются с результатом промиса, одна за другой
// Никакой передачи результатов между обработчиками в рамках одного промиса нет, а сам результат промиса (PromiseResult) после установки не меняется
</code></pre>

<!------------------------------------------------------>
<h3>Параллельное выполнение Promise.all и Promise.race</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-methods>Promise.all</bg-methods><bg-arguments>(iterable)</bg-arguments> - получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов</li>
	<li>Если какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются</li>
</ul>

<ul class="list-point">
	<li><bg-methods>Promise.race</bg-methods><bg-arguments>(iterable)</bg-arguments> - получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис</li>
	<li>Результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются</li>
</ul>

<h4>Пример #1</h4>
<pre><code class="js">
var promise1 = new Promise(function(resolve, reject) {
    resolve('promise1');
});
var promise2 = new Promise(function(resolve, reject) {
    resolve('promise2');
});

Promise.<bg-code>all</bg-code>([promise1, promise2])
    .then(value => console.log(value)); // [ 'promise1', 'promise2' ]
Promise.<bg-code>race</bg-code>([promise1, promise2])
    .then(value => console.log(value)); // promise1
</code></pre>

<h4>Пример #2</h4>
<pre><code class="js">
function go(num) {
	return new Promise(function(resolve, reject) {
		setTimeout(() => resolve(num), 1000);
	})
}

let p1 = go(1);
let p2 = go(2);
let p3 = go(3);

// выполняет все обещания даже если ошибка в первом
// но закончится всё равно ошибкой
Promise.all([p1, p2, p3])
	.then(value => console.log(value));

// получить результат от первого
Promise.race([p1, p2, p3])
	.then(value => console.log(value));
</code></pre>


<!------------------------------------------------------>
<h3>Promise.resolve(value) и Promise.reject(error)</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-methods>Promise.resolve</bg-methods><bg-arguments>(value)</bg-arguments> - создаёт успешно выполнившийся промис с результатом value</li>
	<li>Promise.resolve используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть</li>
</ul>

<pre><code class="js">
// аналогичен конструкции
new Promise((resolve) => resolve(value))
Promise.resolve(window.location) // начать с этого значения
	.then(httpGet) // вызвать для него httpGet
	.then(alert) // и вывести результат
</code></pre>

<ul class="list-point">
	<li><bg-methods>Promise.reject</bg-methods><bg-arguments>(error)</bg-arguments> - создаёт уже выполнившийся промис с ошибкой error</li>
	<li>Метод Promise.reject используется очень редко, т.к. ошибка возникает обычно не в начале цепочки, а в процессе её выполнения</li>
</ul>

<pre><code class="js">
Promise.reject(new Error("..."))
	.catch(alert) // Error: ...
</code></pre>




<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>
<h4>Пример #1</h4>
<pre><code class="js">
function applyForVisa(document) {
	console.log('Обработка заявления...');
	let promise = new Promise(function(resolve, reject) {
		setTimeout(function() {
			Math.random() > 0 ? resolve({}) : reject('В визе отказано');
		}, 2000);
	});
	return promise;
}
function getVisa(visa) {
	console.info('Виза получена');
	return new Promise(function(resolve, reject) {
		setTimeout(() => resolve(visa), 2000);
	});
}
function bookHotel(visa) {
	console.log(visa);
	console.log('Бронируем отель');
	return Promise.resolve(visa);
	// return Promise.reject('Нет мест');
}
function buyTickets(booking) {
	console.log('Покупаем билеты');
	console.log('Бронь', booking);
}
applyForVisa({})
	.then(getVisa)
	.then(bookHotel)
	.then(buyTickets)
	.catch(error => console.error(error))
	.then(() => console.log('Выведется в любом случае'));
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="generators">Generators (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Generators альтернатива Promise</li>
	<li>Generators - функции, которые могут останавливать свое выполнение, возвращать промежуточный результат и далее возобновлять выполнение позже в произвольный мемент времени</li>
</ul>

<h4>Объявление генератора</h4>
<pre><code class="js">
function* genetare()  {} 
function * genetare() {} 
function *genetare()  {} 

// анонимная функция
var generator = function*() {}

// метод у объекта
var obj = {
    *generator(start, end) {}
}

// метод у класса
class SomeClass {
    *generator(start, end) {}
}
</code></pre>

<ul class="list-point">
	<li>При вызове Генератора возвращается объект Итератор, позволяющий приостанавливать и возобновлять процесс выполнения функции</li>
	<li><bg-list>yield</bg-list> - позволяет поставить выполнение функции на паузу и возобновить в произвольный момент</li>
	<li><bg-list>yield</bg-list> - производит и отдает информацию - объек со свойствами value и done,
но при этом также отдаем контроль за функцией</li>
	<li><bg-list>yield 1</bg-list> - возвращает промежуточный результат (value: 1)</li>
</ul>

<h4>Использование с Fetch</h4>
<pre><code class="js">
function getApi() {
	let response = yield fetch('url');
	let data = yield response.json();
	return data;
}
</code></pre>

<h4>Пример #1. Передать значение</h4>
<pre><code class="js">
function* generate() {
    console.log('Start');
    yield 1;
    console.log('Finish');
}
var iterator = generate();
console.log(iterator.next()); // Object { value: undefined, done: false } Start
console.log(iterator.next()); // Object { value: undefined, done: true  } Finish
console.log(iterator.next()); // Object { value: undefined, done: true  }        
</pre></code>

<h4>Пример #2. Получить значение</h4>
<pre><code class="js">
function* generator() {
    var result = yield;
    console.log(result); // 1
}
var iterator = generator();
console.log(iterator.next());  // первый вызов запускает генератора, нельзя передать значение
console.log(iterator.next(1)); // передаваемое значение

iterator.return(); // остановить генератор
iterator.throw();  // остановить с ошибкой
</pre></code>

<h4>Пример #3. Генаратор</h4>
<pre><code class="js">
function* range(start, end) {
    let current = start;
    while (current <= end) {
        yield current++;
    }
}
for (let num of range(1, 10)) {
    console.log(num);
}
</pre></code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="async-func">Async Function (ES2017)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Async Function - асинхронная функция (Promise + Generator)</li>
	<li>Асинхронная функция возвращает обещение, для получения значения используется then</li>
	<li>Если в асинхронной функции специально вернуть обещение, оно не оборачивается в другое обещание</li>
</ul>

<pre><code class="js">
async function getUser(id) {
    return { id:1 };   
}
getUser(1).then(user => console.log(user));
</code></pre>

<ul class="list-point">
	<li>await дожидается выполнения обещания, вытаскивает значение и возвращает его</li>
	<li>код после await выполнится только после выполнения функции</li>
	<li>await можно использовать только внутри асинхронной функции</li>
	<li>await необязательно ставить перед вызовом асинхронной фунцкии. это может быть любая функция, возвращающая обещание</li>
</ul>
<pre><code class="js">
async function getUser(id) {
    return { id:1 };   
}
async function main() {
    let user = await getUser(1);
    console.log(user);
}
main();
</code></pre>

<pre><code class="js">
async function getUser(id) {
    let response = await fetch('url');
    let data = await response.json();
    return data;
}

async function main() {
    try {
        let user = await getUser(1);
        console.log(user);
    } catch(error) {
        console.log(error);
    }
}

main();
</code></pre>

<h4>Варианты объявления</h4>
<pre><code class="js">
const getUser = async function(id) {}
const getUser = async (id) => {}
const dataService = {
	getUser: async function(id) {}  // свойство
	async getUserProp(id) {}        // метод
}
</code></pre>

<pre><code class="js">
(async function() {
	//
})();

(async () => {
	//
})();
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="set">Коллекции Set и WeakSet (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-define>Set</bg-define> - множество, набор значений. Структура данных в которой хранятся уникальные значения</li>
	<li>Нет литеральной формы, создается с помощью конструктора</li>
	<li>Варианты использования: хранение css классов dom элементов</li>
	<li>Является итерируемой структурой данных, можно перебрать с помощью for..of</li>
	<li>Сохраняет порядок элементов в котором они были добавлены</li>

	<b class="margin-top">Отличия WeakSet от Set</b>
	<li>Могут храниться только объекты</li>
	<li>Нет свойство size</li>
	<li>Нет метода clear()</li>
	<li>Не является итерируемым</li>
	<li>Если на объект, который хранится в WeakSet, нет ни одной внешней ссылки, то сборщик мусора удалит этот объект</li>
</ul>

<!------------------------------------------------------>
<h3>Объявление</h3>
<!------------------------------------------------------>
<pre><code class="js">
const set = <bg-code>new Set()</bg-code>; // Set(0) {}
</code></pre>

<pre><code class="js">
// для указания начального значения в конструкторе указывается перебираемый объект
const set = new Set(['button', 'active', 'small']); // Set(3) {"button", "active", "small"}
</code></pre>

<pre><code class="js">
// буква "t" хранится 1 раз, т.к. в set только уникальные значения
const set = new Set('button'); // Set(5) {"b", "u", "t", "o", "n"}
</code></pre>

<pre><code class="js">
// set из 1 элемента
const set = new Set(['button']); // Set(1) {"button"}
</code></pre>

<pre><code class="js">
// клонирование set
const set1 = new Set(['button']); // Set(1) {"button"}
const set2 = new Set(set1);       // Set(1) {"button"}
</code></pre>

<!------------------------------------------------------>
<h3>Добавление нового элемента</h3>
<!------------------------------------------------------>
<pre><code class="js">
const set = new Set();
set.<bg-code>add</bg-code>('button');
set.<bg-code>add</bg-code>('active');
set.<bg-code>add</bg-code>('active');
// Set(2) {"button", "active"}

const set = new Set();
set
    .add('button')
    .add('active')
    .add('active');
</code></pre>

<!------------------------------------------------------>
<h3>Методы</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = set.<bg-code>size</bg-code>;          // кол-во элементо в set
var a = set.<bg-code>has</bg-code>('button'); // проверка наличия значения
set.<bg-code>delete</bg-code>('active');      // удаление элемента 
set.<bg-code>clear</bg-code>();               // очистка set
</code></pre>

<!------------------------------------------------------>
<h3>Set и Объекты</h3>
<!------------------------------------------------------>
<pre><code class="js">
const set = new Set();
set.add({className: 'button'}); 
var a = set.has({className: 'button'}); // false
// в метод add отправляется ссылка на один объект
// в метод has отправляется ссылка на другой объект

const set = new Set();
const buttonRef = {className: 'button'};
set.add(buttonRef); 
var a = set.has(buttonRef); // true
</code></pre>

<!------------------------------------------------------>
<h3>values, keys, entries</h3>
<!------------------------------------------------------>
<pre><code class="js">
// нет метода для получения доступа к конкретному элементу
// нет понятия как индекс, поэтому keys возвращает values
console.log(...set);           // button active
console.log([...set]);         // (2) ["button", "active"] // преобразование в массив
console.log(Array.from(set));  // (2) ["button", "active"] // преобразование в массив

console.log(set.values());     // SetIterator {"button", "active"}
console.log(...set.values());  // button active
console.log(...set.keys());    // button active
console.log(...set.entries()); // (2) ["button", "button"] (2) ["active", "active"]
</code></pre>

<h4>Деструктуризация</h4>
<pre><code class="js">
const [element1, element2] = set; // получить первый и второй элемент set
</code></pre>

<!------------------------------------------------------>
<h3>Перебор set</h3>
<!------------------------------------------------------>
<pre><code class="js">
for (let item of set) {
    console.log(item);
}
// button
// active
</code></pre>

<pre><code class="js">
set.forEach((item, item2, set) => console.log(item, item2, set));
// button button Set(2) {"button", "active"}
// active active Set(2) {"button", "active"}
</code></pre>

<!------------------------------------------------------>
<h3>Операции над множествами</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Нет встроенных методов</li>
</ul>

<pre><code class="js">
const a = new Set([1, 2, 3]);
const b = new Set([3, 4, 5]);
</code></pre>

<h4>Объединение</h4>
<div class="container-flex"><div class="container-half">
<img src="img/js/set1.png" height="100px" class="center">
<ul class="list-point">
	<li>Объединение множеств - множество, содержащее в себе все элементы исходных множеств</li>
</ul>
</div><div class="container-half"><pre><code class="js">
// Set(5) {1, 2, 3, 4, 5}
const union = new Set([...a, ...b]);
</code></pre></div></div>

<h4>Пересечение</h4>
<div class="container-flex"><div class="container-half">
<img src="img/js/set2.png" height="100px" class="center">
<ul class="list-point">
	<li>Пересечение множеств - множество, которому принадлежат элементы которые есть во всех исходных множествах</li>
</ul>
</div><div class="container-half"><pre><code class="js">
// Set(1) {3}
const interseption = new Set([...a].filter(
    x => b.has(x)
))
</code></pre></div></div>

<h4>Разность</h4>
<div class="container-flex"><div class="container-half">
<img src="img/js/set3.png" height="100px" class="center">
<ul class="list-point">
	<li>Разность множеств - множество в которое входят все элементы первого множества не входящие во второе множество</li>
</ul>
</div><div class="container-half"><pre><code class="js">
// Set(2) {1, 2}
const difference = new Set([...a].filter(
    x => !b.has(x)
))
</code></pre></div></div>



<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- AJAX -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ajax-request">Описание</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Определения</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-list>AJAX (Asynchronous Javascript And Xml)</bg-list> - технология обращения к серверу без перезагрузки страницы</li>
	<li><bg-list>JSON</bg-list> - для отправки и получения структурированных данных, объектов</li>
	<li><bg-list>COMET</bg-list> - общий термин, описывающий различные техники получения данных по инициативе сервера</li>
</ul>

<!------------------------------------------------------>
<h3>Технологии</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-list>1. XMLHttpRequest</bg-list> - (не используют в явном виде, создаются обертки)</li>
	<li><bg-list>2. Fetch</bg-list> - (на Promise, нативный, полифил для IE)</li>
	<li><bg-list>3. Axios</bg-list> - (на XMLHttpRequest)</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="xmlhttprequest">XMLHttpRequest</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>XMLHttpRequest («XHR») дает возможность из JavaScript делать HTTP-запросы к серверу без перезагрузки страницы</li>
	<li>Ответы на запросы XMLHttpRequest кешируются, как и обычные страницы</li>
</ul>

<!------------------------------------------------------>
<h3>Методы</h3>
<!------------------------------------------------------>
<pre><code class="js light">
<bg-methods>xhr.open</bg-methods><bg-arguments>(method, URL, async, user, password)</bg-arguments> // вызов open не открывает соединение. Он лишь настраивает запрос, а коммуникация инициируется методом send
	<em>&#8226; method</em>      // HTTP-метод. GET / POST / TRACE / DELETE / PUT и т.д.
	<em>&#8226; URL</em>         // адрес запроса. Можно использовать не только http/https, но и другие протоколы, например ftp:// и file://. При этом есть ограничения безопасности, называемые «Same Origin Policy»: запрос со страницы можно отправлять только на тот же протокол://домен:порт
	<em>&#8226; async</em>       // если установлено в false, то запрос производится синхронно, если true – асинхронно
	<em>&#8226; user</em>        // логин для HTTP-авторизации, если нужны
	<em>&#8226; password</em>    // пароль для HTTP-авторизации, если нужны
<bg-methods>xhr.send</bg-methods><bg-arguments>([body])</bg-arguments> // метод открывает соединение и отправляет запрос на сервер
	<em>&#8226; body</em>        // тело запроса
<bg-methods>xhr.abort</bg-methods><bg-arguments>()</bg-arguments>     // прерывает выполнение запроса
<bg-methods>setRequestHeader</bg-methods><bg-arguments>(name, value)</bg-arguments> // устанавливает заголовок name запроса со значением value. Отменить setRequestHeader невозможно
	<em>&#8226; name</em>  // 'Content-Type'
	<em>&#8226; value</em> // 'application/json'
<bg-methods>getResponseHeader</bg-methods><bg-arguments>(name)</bg-arguments> // возвращает значение заголовка ответа name, кроме Set-Cookie и Set-Cookie2
	<em>&#8226; name</em>  // 'Content-Type'
<bg-methods>getAllResponseHeaders</bg-methods><bg-arguments>()</bg-arguments> // возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2. Заголовки возвращаются в виде единой строки. Между заголовками стоит перевод строки в два символа "\r\n" (не зависит от ОС), значение заголовка отделено двоеточием с пробелом ": "
	// Cache-Control: max-age=31536000
	// Content-Length: 4260
	// Content-Type: image/png
	// Date: Sat, 08 Sep 2012 16:53:16 GMT
</code></pre>

<!------------------------------------------------------>
<h3>Свойства XMLHttpRequest</h3>
<!------------------------------------------------------>
<pre><code class="js light">
<em>&#8226; xhr.status</em>       // HTTP-код ответа: 200, 404, 403 и так далее. Может быть также равен 0, если сервер не ответил или при запросе на другой домен
<em>&#8226; xhr.statusText</em>   // Текстовое описание статуса от сервера: OK, Not Found, Forbidden и т.д.
<em>&#8226; xhr.responseText</em> // Текст ответа сервера. Для json JSON.parse(xhr.responseText)
<em>&#8226; xhr.responseXML</em>  // Если сервер вернул XML, снабдив его правильным заголовком Content-type: text/xml, то браузер создаст из него XML-документ. По нему можно будет делать запросы xhr.responseXml.querySelector("...") и другие
<em>&#8226; xhr.timeout</em>      // Максимальная продолжительность асинхронного запроса. При превышении этого времени запрос будет оборван и сгенерировано событие ontimeout
</code></pre>

<pre><code class="js">
xhr.timeout = 30000; // 30 секунд (в миллисекундах)
xhr.ontimeout = function() {
	alert( 'Извините, запрос превысил максимальное время' );
}
</code></pre>

<!------------------------------------------------------>
<h3>События</h3>
<!------------------------------------------------------>
<pre><code class="js light">
<em>&#8226; onreadystatechange</em> // можно посмотреть «текущее состояние запроса» в свойстве xhr.readyState
<em>&#8226; onloadstart</em>        // запрос начат
<em>&#8226; onprogress</em>         // браузер получил очередной пакет данных, можно прочитать текущие полученные данные в responseText
<em>&#8226; onabort</em>            // запрос был отменён вызовом xhr.abort()
<em>&#8226; onerror</em>            // произошла ошибка
<em>&#8226; onload</em>             // запрос был успешно (без ошибок) завершён
<em>&#8226; ontimeout</em>          // запрос был прекращён по таймауту
<em>&#8226; onloadend</em>          // запрос был завершён (успешно или неуспешно)
</code></pre>

<!------------------------------------------------------>
<h3>Свойство xhr.readyState для текущего состояния запроса</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Событие readystatechange происходит несколько раз в процессе отсылки и получения ответа. При этом можно посмотреть «текущее состояние запроса» в свойстве xhr.readyState</li>
	<li>Запрос проходит их в порядке 0 → 1 → 2 → 3 → … → 3 → 4, состояние 3 повторяется при каждом получении очередного пакета данных по сети</li>
</ul>

<pre><code class="js light">
const unsigned short UNSENT           = 0; // начальное состояние
const unsigned short OPENED           = 1; // вызван open
const unsigned short HEADERS_RECEIVED = 2; // получены заголовки
const unsigned short LOADING          = 3; // загружается тело (получен очередной пакет данных)
const unsigned short DONE             = 4; // запрос завершён
</code></pre>
<!------------------------------------------------------>
<h3>Асинхронный</h3>
<!------------------------------------------------------>
<pre><code class="js">
var xhr = new XMLHttpRequest();
xhr.open('GET', 'script.php', true);
xhr.send(); // отправляем запрос, результат придёт в обработчик onreadystatechange

// установка обработчика событий
xhr.onreadystatechange = function() {
    // if (xhr.readyState==4 && xhr.status==200) {
    // 	console.log(xhr.responseText);
    // }

    if (xhr.readyState != 4) return;

    if (xhr.status != 200) {
        // обработать ошибку
        console.log(xhr.status + ':' + xhr.statusText);
        return;
    } 
    
    // получить результат из this.responseText или this.responseXML
    console.log(xhr.responseText);
}
</code></pre>

<!------------------------------------------------------>
<h3>Синхронный</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Возможность делать запросы на другой домен и указывать таймаут, в синхронном режиме не работают</li>
</ul>
<pre><code class="js">
var xhr = new XMLHttpRequest();       // создаём новый объект XMLHttpRequest
xhr.open('GET', 'script.php', false); // конфигурируем его: GET-запрос на URL 'script.php'
xhr.send();                           // отсылаем запрос

// если код ответа сервера не 200, то это ошибка
if (xhr.status != 200) {
	// обработать ошибку (пример вывода: 404: Not Found)
    console.log(xhr.status + ':' + xhr.statusText);
} else {
	// вывести результат (responseText -- текст ответа)
    console.log(xhr.responseText);
} 
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="fetch">Fetch</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="html">
<a href="https://github.com/github/fetch" target="_blank">Полифил и описание методов</a>
<a href="https://developer.mozilla.org/ru/docs/Web/API/Fetch_API/Using_Fetch" target="_blank">MDN</a>
</code></pre>

<pre><code class="js light">
<bg-methods>fetch</bg-methods><bg-arguments>(url[, options])</bg-arguments>
	<em>&#8226; url</em>     // URL, на который сделать запрос
	<em>&#8226; options</em> // необязательный объект с настройками запроса
</code></pre>

<pre><code class="js light">
Свойства <bg-methods>options</bg-methods>
	<em>&#8226; method</em>      // метод запроса
	<em>&#8226; headers</em>     // headers
	<em>&#8226; body</em>        // тело запроса: FormData, Blob, строка и т.д.
	<em>&#8226; mode</em>        // одно из: «same-origin», «no-cors», «cors», указывает, в каком режиме кросс-доменности предполагается делать запрос
	<em>&#8226; credentials</em> // одно из: «omit», «same-origin», «include», указывает, пересылать ли куки и заголовки авторизации вместе с запросом
	<em>&#8226; cache</em>       // одно из «default», «no-store», «reload», «no-cache», «force-cache», «only-if-cached», указывает, как кешировать запрос
	<em>&#8226; redirect</em>    // можно поставить «follow» для обычного поведения при коде 30x (следовать редиректу) или «error» для интерпретации редиректа как ошибки 
</code></pre>

<h4>Объект response (ответ)</h4>
<pre><code class="js">
var a = response.headers.get('Content-Type');
var a = response.status; 

var a = response.arrayBuffer();
var a = response.blob();
var a = response.formData();
var a = response.json();
var a = response.text();
</code></pre>

<ul class="list-point">
	<li>При вызове <u>fetch</u> возвращает <u>промис</u>, который, когда получен ответ, выполняет <u>коллбэки</u> с объектом <u>Response</u> или с ошибкой, если запрос не удался</li>
	<li>В примере мы можем <u>в первом .then</u> проанализировать ответ и, если он нас устроит – вернуть промис с нужным форматом</li>
	<li><u>Следующий .then</u> уже будет содержать полный ответ сервера</li>
</ul>

<h4>Пример #1. Без передачи значений</h4>
<pre><code class="js">
fetch('script.php')
    .then(function(response) {
        return response.text();
    })
    .then(function(body) {
        document.body.innerHTML = body;
    })
    .catch(function(error) {
        console.log(error);
    });
</code></pre>

<h4>Пример #2. Передача одного значения</h4>
<pre><code class="js">
fetch('script.php', {
	method: 'POST',
	body: 'hello'
})
</code></pre>
<pre><code class="php">
// script.php
&lt;?php
    $content = file_get_contents("php://input");
    echo $content;
?&gt;
</code></pre>

<h4>Пример #3. Передача JSON</h4>
<pre><code class="js">
fetch('script.php', {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json'
	},
	body: JSON.stringify({
		name: 'Tony',
		login: 'Admin'
	})
})
</code></pre>
<pre><code class="php">
// script.php
&lt;?php
    $content = file_get_contents("php://input");
    $decoded = json_decode($content, true);
    echo $decoded[name];
?&gt;
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="axios">Axios</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="html">
<a href="https://github.com/axios/axios" target="_blank">GitHub Axios</a>
</code></pre>

<pre><code class="bash">
npm i axios --save
</code></pre>

<pre><code class="js">
const axios = require('axios');
</code></pre>

<!------------------------------------------------------>
<h3 id="axios">GET</h3>
<!------------------------------------------------------>
<pre><code class="js">
axios.get('url')
.then(response => {
	console.log(response.data);
})
.catch(error => console.log(error));
</code></pre>

<!------------------------------------------------------>
<h3 id="axios-post">POST</h3>
<!------------------------------------------------------>
<pre><code class="js">
axios.post('url', {
		firstName: 'Fred',
		lastName: 'Flintstone'
	})
	.then(function (response) {
		console.log(response);
	})
	.catch(function (error) {
		console.log(error);
	});
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ajax-request-js">Request JS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Обработка формы</h3>
<!------------------------------------------------------>
<pre><code class="html">
&lt;form class="form"&gt;
	&lt;input type="text" name="name" required=""&gt;
	&lt;input type="text" name="message" required=""&gt;
	&lt;input type="submit" value="Отправить"&gt;
&lt;/form&gt;
</code></pre>

<pre><code class="js">
var form = document.querySelector('.form');

form.addEventListener('submit', function(e) {
	e.preventDefault();
	var name = this['name'];
	var message = this['message'];
	console.log(name.value, message.value);
});
</code></pre>

<!------------------------------------------------------>
<h3>Отправка формы из HTML</h3>
<!------------------------------------------------------>
<pre><code class="html">
&lt;form action="script.php" method="get"&gt;
    &lt;input type="text" name="name" required=""&gt;
    &lt;textarea name="message"&gt;&lt;/textarea&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;
</code></pre>

<pre><code class="html">
http://test1.ru/script.php?name=myname&message=my+message
</code></pre>

<pre><code class="php">
&lt;?php
	$name    = $_GET[name]; 
	$message = $_GET[message]; 
?&gt;
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ajax-response-php">Response PHP</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Чтение данных в php</h3>
<!------------------------------------------------------>
<pre><code class="php">
&lt;?php
	$content = file_get_contents("php://input"); // чтение данных
	$decoded = json_decode($content, true);      // если передан json
	echo $decoded[name];                         // вывод значения "name"
?&gt;
</code></pre>

<!------------------------------------------------------>
<h3>Передача нескольких значений из php</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half"><pre><code class="php">
&lt;?php
    $arr = array("Tony", 25);
    $json = json_encode($arr);
    echo $json
?&gt;
</code></pre></div><div class="container-half"><pre><code class="js">
response.data; // ['Tony', 25]
<br><br><br>
</code></pre></div></div>

<div class="container-flex"><div class="container-half"><pre><code class="php">
&lt;?php
    $arr = array("name" => "Tony", "age" => 25);
    $json = json_encode($arr);
    echo $json
?&gt;
</code></pre></div><div class="container-half"><pre><code class="js">
response.data; // {name: "Tony", age: "25"}
<br><br><br>
</code></pre></div></div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="client-server">Client-Server Architecture</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->


<!------------------------------------------------------>
<h3 id="client-server-desc">Клиент-серверная архитектура</h3>
<!------------------------------------------------------>
<div id="ct-client-server-desc">
<ul class="list-point">
	<li><bg-define>Клиент-серверная архитектура</bg-define> </li>
	<ul class="list-point">
		<li><u>Клиент</u> - инициирует соединение и посылает запрос</li>
		<li><u>Сервер</u> - ожидает соединения для получения запроса, производит необходимые действия и возвращают обратно сообщение с результатом</li>
	</ul>
</ul>

<!------------------------------------------------------>
<h3>Определения</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-define>Веб-сервер</bg-define> - программа, предназначенная в первую очередь для работы с протоколом HTTP. Основные реализации: <u>Apache</u>, <u>Internet Information Services (IIS)</u>, <u>nginx</u>, <u>Google Web Server</u>, <u>lighttpd</u></li>

	<li><bg-define>URI (Uniform Resource Identifier)</bg-define> - единообразный идентификатор ресурса. Ресурс как правило, файл на сервере ('/styles.css'), или абстрактный объект ('/blogs/webdev/')</li>
	<li>Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т. д. в частности, для этого используется HTTP-заголовок (строки содержащие разделённую двоеточием пару имя-значение)</li>
	<li>Не предусмотрена внутренняя поддержка состояния</li>
	<li>Аналоги FTP и SMTP</li>
</ul>
</div>

<!------------------------------------------------------>
<h3 id="client-server-http">HTTP</h3>
<!------------------------------------------------------>
<div id="ct-client-server-http">

<ul class="list-point">
	<li><bg-define>HTTP (HyperText Transfer Protocol)</bg-define> («протокол передачи гипертекста») - протокол прикладного уровня передачи произвольных данных. Протокол описывает взаимодействие между двумя компьютерами (клиентом и сервером), построенное на базе сообщений, запрос (<u>Request</u>) и ответ (<u>Response</u>)</li>
	<li>Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI в запросе клиента</li>
	<li>HTTP не сохраняет своего состояния - протокол не осведомлён о предыдущих запросах и ответах</li>

	<li><bg-define>Структура протокола</bg-define></li>
	<li>Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке (тело сообщения может отсутствовать):</li>
	<ul class="list-point">
		<li><u>1. Стартовая строка (Starting line)</u> - определяет тип сообщения <bg-code>Строка запроса: Метод URI HTTP/Версия</bg-code> <bg-code>Строка ответа: HTTP/Версия КодСостояния Пояснение</bg-code></li>
		<li><u>2. Заголовки (Headers)</u> - характеризуют тело сообщения, параметры передачи и прочие сведения</li>
		<li><u>3. Тело сообщения (Message Body)</u> - непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой</li>
	</ul>

	<li><bg-define>Заголовки HTTP</bg-define> -  строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение</li>
	<ul class="list-point">
		<li><u>1. General Headers («Основные заголовки»)</u> - могут включаться в любое сообщение клиента и сервера</li>
		<li><u>2. Request Headers («Заголовки запроса»)</u> - используются только в запросах клиента</li>
		<li><u>3. Response Headers («Заголовки ответа»)</u> - только для ответов от сервера</li>
		<li><u>4. Entity Headers («Заголовки сущности»)</u> - сопровождают каждую сущность сообщения</li>
	</ul>

	<li><bg-define>HTTP-методы</bg-define> - последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом</li>
	<ul class="list-point">
		<li><u>GET</u> - запроса содержимого указанного ресурса</li>
		<li><u>POST</u> - передача пользовательских данных заданному ресурсу</li>
		<li><u>PUT</u> - загрузка содержимого запроса на указанный в запросе URI (обновление ресурса)</li>
		<li><u>DELETE</u> - удаляет указанный ресурс</li>
		<li><u>HEAD</u> - аналогичен GET, получение информации о ресурсе, не получая самого ресурса (проверка наличия ресурса)</li>
		<li><u>OPTIONS</u> - определение возможностей веб-сервера или параметров соединения для конкретного ресурса</li>
		<li><u>PATCH</u> - аналогичен PUT, но применяется только к фрагменту ресурса</li>
		<li><u>TRACE</u> - возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе</li>
		<li><u>CONNECT</u> - преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси</li>
	</ul>

	<li><bg-define>Коды состояния HTTP</bg-define> - код состояния является частью первой строки ответа сервера. Он представляет собой целое число из трёх цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет причину ответа</li>
	<ul class="list-point">
		<b>Классы кодов</b>
		<li><u>1xx</u> - Информационный (informational). Информирование о процессе передачи</li>
		<li><u>2xx</u> - Успех (Success). Информирование о случаях успешного принятия и обработки запроса клиента</li>
		<li><u>3xx</u> - Перенаправление (Redirection). Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос</li>
		<li><u>4xx</u> - Ошибка клиента (Client Error)</li>
		<li><u>5xx</u> - Ошибка сервера (Server Error)</li>
	</ul>
</ul>

</div>
<!------------------------------------------------------>
<h3 id="client-server-https">HTTPS</h3>
<!------------------------------------------------------>
<div id="ct-client-server-https">

<ul class="list-point">
	<li><bg-define>HTTPS (HyperText Transfer Protocol Secure)</bg-define> - расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов SSL или TLS</li>
	<li>Он обеспечивает защиту от атак, основанных на прослушивании сетевого соединения — от снифферских атак и атак типа man-in-the-middle, при условии, что будут использоваться шифрующие средства и сертификат сервера проверен и ему доверяют</li>
	<li>Чтобы подготовить веб-сервер для обработки https-соединений, администратор должен получить и установить в систему сертификат открытого ключа для этого веб-сервера. В TLS используется как асимметричная схема шифрования (для выработки общего секретного ключа), так и симметричная (для обмена данными, зашифрованными общим ключом). Сертификат открытого ключа подтверждает принадлежность данного открытого ключа владельцу сайта. Сертификат открытого ключа и сам открытый ключ посылаются клиенту при установлении соединения; закрытый ключ используется для расшифровки сообщений от клиента</li>
	
	<li><u class="margin-top">Идентификация сервера</u> В начале общения, сервер посылает клиенту свой сертификат, чтобы клиент идентифицировал его. В сертификате указывается URI сервера. Если имя сервера не совпадает с указанным в сертификате, то пользовательские программы, например браузеры, сообщают об этом пользователю. В основном, браузеры предоставляют пользователю выбор: продолжить незащищённое соединение или прервать его
	</li>

	<li><u class="margin-top">Идентификация клиента</u> Обычно, сервер не располагает достаточной информацией о клиенте, для его идентификации. Однако, для обеспечения повышенной защищённости соединения используется так называемая two-way authentication. При этом сервер, после подтверждения его сертификата клиентом, также запрашивает сертификат. Таким образом, схема подтверждения клиента аналогична идентификации сервера
	</li>

	<li><bg-define>SSL</bg-define> (Secure Sockets Layer - уровень защищённых cокетов) — криптографический протокол, который подразумевает более безопасную связь. Он использует асимметричную криптографию для аутентификации ключей обмена, симметричное шифрование для сохранения конфиденциальности, коды аутентификации сообщений для целостности сообщений. Протокол широко использовался для обмена мгновенными сообщениями и передачи голоса через IP (англ. Voice over IP — VoIP) в таких приложениях, как электронная почта, интернет-факс и др. SSL должен быть исключён из работы в пользу TLS</li>

	<li><bg-define>TLS</bg-define> -  (transport layer security - Протокол защиты транспортного уровня), как и его предшественник SSL - криптографические протоколы, обеспечивающие защищённую передачу данных между узлами в сети Интернет. TLS и SSL используют асимметричное шифрование для аутентификации, симметричное шифрование для конфиденциальности и коды аутентичности сообщений для сохранения целостности сообщений. Данный протокол широко используется в приложениях, работающих с сетью Интернет, таких как веб-браузеры, работа с электронной почтой, обмен мгновенными сообщениями и IP-телефония (VoIP)</li>
</ul>

</div>
<!------------------------------------------------------>
<h3 id="client-server-rest">REST API</h3>
<!------------------------------------------------------>
<div id="ct-client-server-rest">

<ul class="list-point">
	<li><bg-define>REST</bg-define> (REpresentational State Transfer - «передача состояния представления») - <u>архитектурный стиль</u> взаимодействия компонентов <u>распределённого</u> приложения в сети. Задает общие принципы организации взаимодействия приложения/сайта с сервером посредством протокола HTTP</li>
	<li>Каждый запрос (REST-запрос) клиента к серверу содержит в себе исчерпывающую информацию о желаемом ответе сервера (желаемом представительном состоянии), и сервер не обязан сохранять информацию о состоянии клиента («клиентской сессии»). Сервер не запоминает состояние пользователя между запросами - в каждом запросе передаётся информация, идентифицирующая пользователя (например, token, полученный через OAuth-авторизацию) и все параметры, необходимые для выполнения операции</li>
	<li>Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин <u>RESTful</u></li>
</ul>

<h4>4 основные операции взаимодействия с сервером</h4>
<pre><code class="bash">
<em>GET-запрос</em>    <bg-code>/rest/users</bg-code>     # получение информации о всех пользователях
<em>GET-запрос</em>    <bg-code>/rest/users/125</bg-code> # получение информации о пользователе с id=125
<em>POST-запрос</em>   <bg-code>/rest/users</bg-code>     # добавление нового пользователя
<em>PUT-запрос</em>    <bg-code>/rest/users/125</bg-code> # изменение (модификация) информации о пользователе с id=125
<em>DELETE-запрос</em> <bg-code>/rest/users/125</bg-code> # удаление пользователя с id=125
</code></pre>

<h4>Требования к архитектуре REST</h4>
<ul class="list-point">
	<li><u>1. Модель клиент-сервер</u> - позволяет отдельным частям развиваться независимо друг от друга</li>
	<li><u>2. Отсутствие состояния</u>. Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится (Stateless Protocol). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Состояние сессии при этом сохраняется на стороне клиента. Информация о состоянии сессии может быть передана сервером какому-либо другому сервису (например, в службу базы данных) для поддержания устойчивого состояния, например, на период установления аутентификации. Клиент инициирует отправку запросов, когда он готов (возникает необходимость) перейти в новое состояние. Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние приложения представлено связями, которые могут быть задействованы при следующем обращении клиента</li>
	<li><u>3. Кэширование</u> ответов сервера. Ответы сервера, в свою очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения получения клиентами устаревших или неверных данных в ответ на последующие запросы</li>
	<li><u>4. Единообразие интерфейса</u>. Унифицированные интерфейсы позволяют каждому из сервисов развиваться независимо. К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия</li>
	<ul class="list-point">
		<li><u>Идентификация ресурсов</u>. Все ресурсы идентифицируются в запросах, например, с использованием URI в интернет-системах. Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде HTML, XML или JSON, ни один из которых не является типом хранения внутри сервера</li>
		<li><u>Манипуляция ресурсами через представление</u>. Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса</li>
		<li><u>«Самоописываемые» сообщения</u>. Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать</li>
		<li><u>Гипермедиа как средство изменения состояния приложения (HATEOAS)</u>. Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу.</li>
	</ul>

	<li><u>5. Слои</u>. Клиент обычно не способен точно определить, взаимодействует он напрямую с сервером или же с промежуточным узлом, в связи с иерархической структурой сетей (подразумевая, что такая структура образует слои). Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования. Промежуточные узлы также могут подчиняться политике безопасности с целью обеспечения конфиденциальности информации</li>
	<li><u>6. Код по требованию</u> (необязательное ограничение). REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или сценариев</li>
</ul>

<h4>Преимущества</h4>
<ul class="list-point">
	<li>Надёжность (за счёт отсутствия необходимости сохранять информацию о состоянии клиента, которая может быть утеряна)</li>
	<li>Производительность (за счёт использования кэша)</li>
	<li>Масштабируемость</li>
	<li>Прозрачность системы взаимодействия (особенно необходимая для приложений обслуживания сети)</li>
	<li>Простота интерфейсов</li>
	<li>Портативность компонентов</li>
	<li>Лёгкость внесения изменений</li>
	<li>Способность эволюционировать, приспосабливаясь к новым требованиям (на примере Всемирной паутины)</li>
</ul>

<ul class="list-point">
	<li><bg-define>API</bg-define> (Application Programming Interface, программный интерфейс приложения) - описание способов (набор классов, процедур, функций, структур или констант), которыми одна компьютерная программа может взаимодействовать с другой программой</li>
	<li>API определяет функциональность, которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как именно эта функциональность реализована</li>
	<li>Программные компоненты взаимодействуют друг с другом посредством API. При этом обычно компоненты образуют иерархию — высокоуровневые компоненты используют API низкоуровневых компонентов, а те, в свою очередь, используют API ещё более низкоуровневых компонентов</li>
	<li>API библиотеки функций и классов включает в себя описание <u>сигнатур функций</u> и <u>семантики функций</u></li>
	<ul class="list-point">
		<li><u>Сигнатура функции</u> - часть общего объявления функции, позволяющая средствам трансляции идентифицировать функцию среди других</li>
		<li><u>Семантика функции</u> - описание того, что данная функция делает. Семантика функции включает в себя описание того, что является результатом вычисления функции, как и от чего этот результат зависит</li>
	</ul>
</ul>

</div>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="chrome-dev-tools">Chrome DevTools</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li><bg-list>F8</bg-list> - продолжить выполнение. Продолжает выполнения скрипта с текущего момента в обычном режиме. Если скрипт не встретит новых точек останова, то в отладчик управление больше не вернется</li>
	<li><bg-list>F10</bg-list> - сделать шаг, не заходя внутрь функции. Выполняет одну команду скрипта. Если в ней есть вызов функции – то отладчик обходит его стороной, т.е. не переходит на код внутри</li>
	<li><bg-list>F11</bg-list> - сделать шаг. Выполняет одну команду скрипта и переходит к следующей. Если есть вложенный вызов, то заходит внутрь функции</li>
	<li><bg-list>Shift+F11</bg-list> - выполнять до выхода из текущей функции. Выполняет команды до завершения текущей функции. Быстрый выход из вложенного вызова</li>
</ul>

Остановку можно инициировать и напрямую из кода скрипта, командой debugger
<pre><code class="js">
function pow(x, n) {
	...
	debugger; // отладчик остановится тут
	...
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="garbage-collection">Сборщик мусора</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>Сборщик мусора (Garbage collection, GC)</bg-list> - очистка памяти от недостижимых значений в браузере. GC встроенн в интерпретатор, он наблюдает за объектами и время от времени удаляет недостижимые</li>
	<li><bg-list>Примитивы</bg-list> - при присвоении они копируются целиком, ссылок на них не создаётся. Если в переменной была одна строка, а её заменили на другую, то предыдущая удаляется</li>
	<li><bg-list>Объекты</bg-list> требуют специального <u>«сборщика мусора»</u>, который наблюдает за ссылками, т.к. на один объект может быть много ссылок из разных переменных и, при перезаписи одной из них, объект может быть всё ещё доступен из другой</li>
	<li>
		<bg-list>Упрощение для работы с памятью</bg-list>: «значение остаётся в памяти, пока на него есть хотя бы одна ссылка»
		<ul class="list-point">
			<li>Верно - в том плане, что если ссылок на значение нет, то память из-под него очищается</li>
			<li>Неверно - в другую сторону: наличие ссылки не гарантирует, что значение останется в памяти</li>
		</ul>
	</li>
	<li><bg-list>Сборщик мусора</bg-list> идёт от корня по ссылкам и запоминает все найденные объекты. По окончанию - он смотрит, какие объекты в нём отсутствуют и удаляет их</li>
	<li><bg-list>Применение оптимизации интерпретаторами</bg-list> - деление объектов на два вида «старые» и «новые». Для каждого типа выделяется своя область памяти. Каждый объект создаётся в «новой» области и, если прожил достаточно долго, мигрирует в старую. «Новая» область обычно небольшая. Она очищается часто. «Старая» – редко</li>
	<li><bg-list>Замыкания</bg-list> <u>LexicalEnvironment</u> внешней функции существует в памяти до тех пор, пока существует хоть одна внутренняя функция, ссылающаяся на него через свойство <u>[[Scope]]</u></li>
	<li><bg-list>Оптимизация в V8</bg-list> JS-движки делают оптимизации <u>замыканий</u> по памяти. Они анализируют использование переменных и в случае, когда переменная из замыкания абсолютно точно не используется, удаляют её</li>
	<li><bg-list>clearTimeout / setInterval</bg-list> Сборщик мусора не чистит функции, назначенные в таймерах, пока таймеры актуальны</li>
</ul>

<h4>Очистка памяти</h4>
<pre><code class="js">
var user = {
	name: 'Tony'
}
user = null;
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="let-const">var let const</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>Глобальная переменная относится к глобальному объект window</li>
	<li>Переменная без var попадает в глобальную область видимости</li>
	<li>Переменная совершают поднятие hoisting, но значение будет undefined</li>
</ul>

<!------------------------------------------------------>
<h3>var</h3>
<!------------------------------------------------------>
<p><bg-list>1</bg-list> Функциональная область видимости</p>
<p><bg-list>2</bg-list> Переменная видна до объявления</p>
<ul class="list-point">
	<li><u>Инициализируются</u> значением <u>undefined</u> прямо когда создается связывание в начале <u>scope</u></li>
</ul>
<pre><code class="js">
alert(a); // undefined
var a = 77;
</code></pre>


<!------------------------------------------------------>
<h3>let и const</h3>
<!------------------------------------------------------>
<p><bg-list>1</bg-list> Блочная область видимости</p>
<p><bg-list>2</bg-list> Переменная видна только после объявления</p>
<ul class="list-point">
	<li><u>Остаются неинициализированными</u>. <u>Инициализируются</u> только в момент выполнения выражений let/const/class, все перед этим (выше) называется временная мертвая зона (<u>temporal dead zone</u>) - время между созданием переменной scope и инициализацией</li>
</ul>
<pre><code class="js">
alert(a); // ReferenceError: a is not defined
let a = 77;
</code></pre>

<p><bg-list>3</bg-list> Нельзя повторно объявлять</p>
<pre><code class="js">
let x;
let x; // SyntaxError: Identifier 'x' has already been declared
</code></pre>

<p><bg-list>4</bg-list> При использовании в цикле, для каждой итерации создаётся своя переменная</p>

<!------------------------------------------------------>
<h3>const</h3>
<!------------------------------------------------------>
<p><bg-list>1</bg-list> Могут быть присвоены только в части инициализатора определения</p>
<pre><code class="js">
const one = 1;
</code></pre>

<p><bg-list>2</bg-list> Изменение элементов объектов и массивов</p>
<pre><code class="js">
const user = {
	name: 'Tony'
};
user.name = 'Jack'; // допустимо
user = 5;           // ошибка
</code></pre>

<!------------------------------------------------------>
<h3>Пример на цикл и замыкание</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half"><pre><code class="js">
for(var i=0; i<5; i++) {
	setTimeout(() => {
		console.log(i);
	}, 10)
}
// 5, 5, 5, 5, 5
</code></pre></div><div class="container-half"><pre><code class="js">
// каждый раз создается новая переменная
for(let i=0; i<5; i++) {
	setTimeout(() => {
		console.log(i);
	}, 10)
}
// 0, 1, 2, 3, 4
</code></pre></div></div>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="architecture">Архитектура среды выполнения JS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="html">
<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop" target="_blank">MDN</a>
</code></pre>

<h4>Определения</h4>
<ul class="list-point">
	<li>JS - однопоточная среда выполнения (<u>runtime</u>). <u>Call Stack</u> один и он может делать одну вещь в единицу времени. Одна инструкция за раз</li>
	<li>Используется очередь функций обратного вызова</li>
	<li>Суть блокирования - когда какие то функции занимают <u>Call Stack</u></li>
	<li>Каждая веб-страница представляет из себя основной поток (<u>Main Thread</u>)</li>
	<li>Движок браузера выполняет JavaScript в одном потоке. Он не может поставить обработку события на паузу, переключиться на другое событие, а после возобновить выполнение первого. Все события обрабатываются последовательно и каждое до конца</li>
	<li>В каждом окне выполняется только один главный поток, который занимается выполнением JavaScript, отрисовкой и работой с DOM. Он выполняет команды последовательно, может делать только одно дело одновременно и блокируется при выводе модальных окон, таких как alert
	<li>В браузерах события добавляются в очередь в любое время, если событие произошло, а так же если у него есть обработчик. В случае, если обработчика нет – событие потеряно. Так, клик по элементу, имеющему обработчик события по событию click , добавит событие в очередь, а если обработчика нет – то и событие в очередь не попадет</li>
</li>
</ul>

<img src="img/js/event-loop1.png" height="500px" class="center">

<h4>Архитектура среды выполнения JS на примере движка <u>V8</u> (Chrome, Node.js)</h4>
<ul class="list-point">
	<li><bg-define>1. Heap (куча)</bg-define> - структура данных, с помощью которой реализована динамически распределяемая память приложения</li>
	<ul class="list-point">
		<li>Куча - ссылка на определённую неструктурированную область памяти</li>
		<li>Содержит объекты, на которые ссылаются переменные программы</li>
		<li>memory allocation</li>
	</ul>

	<li><bg-define>2. Call Stack</bg-define> - <u>стек вызовов</u> LIFO структура (последний вошедший выходит первым)</li> 
	<ul class="list-point">
		<li>В стек помещаются и удаляются аргументы, локальные переменные функций по мере выполнения программы. Синхронные функции помещаются в стек вызова сразу. Асинхронные откладываются в специальную таблицу - <u>Event Table</u>, где ожидают дальнейшей обработки, чтобы не блокировать процесс выполнения программы. Видно какая функция какую вызвала (<u>execution context</u>)</li>
		<li>Стек вызовов - это структура данных, которая, записывает сведения о месте в программе, где мы находимся. Если мы переходим в функцию, мы помещаем запись о ней в верхнюю часть стека. Когда мы из функции возвращаемся, мы вытаскиваем из стека самый верхний элемент и оказываемся там, откуда вызывали эту функцию. Каждая запись в стеке вызовов называется стековым кадром</li>
		<li>Если будет достигнут максимальный размер стека (16 000), возникнет переполнение стека</li>
	</ul>

	<li><bg-define>3. Web API</bg-define> - <u>расширения браузера</u></li>
	<ul class="list-point">
		<li>Event Table и Event Queue являются частью Web API, который реализуют браузеры для того, чтобы использовать такие возможности, как асинхронные запросы, таймеры, обрабатывать DOM события и другое асинхронное поведение. Это не является стандартным функционалом JavaScript и в различных средах данное API может быть реализовано по разному</li>
		<li>Web API - это потоки, к которым у нас нет прямого доступа, мы можем лишь выполнять обращения к ним. Они встроены в браузер, где и выполняются асинхронные действия</li>
	</ul>

	<li><bg-define>3.1 Event Table</bg-define> - <u>таблица</u> в которой находится информация о том, по какому событию необходимо поместить функцию в <u>Event Queue</u> (очередь событий)</li>

	<li><bg-define>3.2 Callback/Event/Task Queue</bg-define> - <u>очередь задач/событий</u> - FIFO структура (раньше выходят элементы, которые раньше были помещены). В ней находятся асинхронные функции, для которых наступило время запуска</li>

	<li><bg-define>3.3 Job Queue (ES6)</bg-define> - <u>очередь заданий (микротаски)</u> Эта конструкцию можно считать слоем, расположенном поверх очереди цикла событий. Очередь заданий — это очередь, которая присоединена к концу каждого тика в очереди цикла событий</li>

	<li><bg-define>4. Event Loop</bg-define> - <u>цикл/петля событий</u> - наблюдает за стеком вызовов и очередью коллбэков (callback queue). Если стек вызовов пуст, цикл берёт первое событие из очереди и помещает его в стек, что приводит к запуску этого события на выполнение. Подобная итерация называется тиком (tick) цикла событий. Каждое событие — это просто коллбэк</li>
	<ul class="list-point">
		<li>Позволяет запланировать выполнение асинхронного кода сразу после выполнения синхронного кода</li>
	</ul>

</ul>

<h4>Event Loop</h4>
<pre><code class="js">
// queue.waitForMessage ожидает события если очередь пуста
while(queue.waitForMessage()){ 
	queue.processNextMessage(); 
}
</code></pre>

<h4>Event Loop (tasks, microtasks)</h4>
<ul class="list-point">
	<li><bg-define>tasks (macrotask)</bg-define> (очередь задач)</li>
	<ul class="list-point">
		<li>Задачи исполняются по порядку и браузер может рендерить в промежутках между ними</li>
		<li><b>Примеры</b>: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, рендеринг пользовательского интерфейса</li>
	</ul>

	<li><bg-define>microtasks</bg-define> (очередь микрозадач / задания "jobs")</li>
	<ul class="list-point">
		Микрозадачи исполняются по порядку:
		<li>Каждый раз после таски</li>
		<li>Каждый раз когда пустеет стек</li>
		<li>Могут выполняться посередине таска, если очистился стек</li>
		<li>Рекурсивный вызов блокирует Event Loop</li>
		<li><b>Примеры</b>: process.nextTick, Promises, Object.observe, MutationObserver</li>
		<li><bg-code>Promise.then</bg-code> - микротаск <bg-code>then</bg-code>. <bg-code>Promise.then.then</bg-code> - 2 микротаска</li>
	</ul>

	<li>Сначала выполняется <u>microtasks</u>, затем <u>tasks</u></li>
</ul>

<pre><code class="js">
// Рекурсивный вызов микротаска повесит программу
function startMicrotask() {
	return Promise.resolve().then(startMicrotask);
}
</code></pre>

<div class="container-flex"><div class="container-half"><pre><code class="js">
console.log('Hi');
setTimeout(function cb1() { 
	console.log('cb1');
}, 5000);
console.log('Bye');
</code></pre></div><div class="container-half">
<img src="img/js/event-loop2.gif" height="300px" class="center">
</div></div>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="decorator">Декораторы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Декоратор - приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение</li>
	<li>Декоратор получает функцию и возвращает обертку, которая делает что-то своё «вокруг» вызова основной функции</li>
</ul>

<h4>Пример #1. Декоратор проверки доступа</h4>
<pre><code class="js">
function checkPermissionDecorator(f) {
	return function() {
		if (isAdmin()) {
			return f.apply(this, arguments);
		}
			alert( 'Недостаточно прав' );
	}
}
</code></pre>

<pre><code class="js">
function save() { ... }

save = checkPermissionDecorator(save);
// Теперь вызов функции save() проверяет права
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="eval">eval</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>eval(code)</bg-list> выполняет код, переданный ей в виде строки и возвращает последнее вычисленное выражение</li>
	<li>Код будет выполнен в <u>текущей области видимости</u></li>
</ul>

<h4>Выполнение кода</h4>
<pre><code class="js">
var a = 1;
(function() {
	var a = 2;
	eval('alert(a)'); // 2
})()
</code></pre>

<h4>Вызов eval возвращает последнее вычисленное выражение</h4>
<pre><code class="js">
var a = eval('1+1'); // 2
</code></pre>

<h4>При вызове eval имеет полный доступ к локальным переменным (<u>не рекомендуется</u>)</h4>
<pre><code class="js">
var x = 5;
eval("alert(x); x = 10"); // 5, доступ к старому значению
alert(x);                 // 10, значение изменено внутри eval
</code></pre>

<h4>В строгом режиме eval имеет свою область видимости</h4>
<pre><code class="js">
"use strict";
eval("var a = 5; function f() { }");
alert(a); // ошибка, переменная не определена
// функция f тоже не видна снаружи
// eval имеет свою область видимости, а к внешним переменным обращается через замыкание, аналогично тому, как работают обычные функции
</code></pre>

<h4>Запуск скрипта в глобальной области</h4>
<pre><code class="js">
var a = 1;
(function( {
	var a = 2;
	<bg-code>window.eval</bg-code>(' alert(a) '); // 1, выполнено глобально везде
})();
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="notifications-api">Notifications API</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Notifications API позволяют web-страницам контролировать отображение системных уведомлений для конечного пользователя — они находятся вне контекста окна браузера верхнего уровня, поэтому могут отображаться даже если пользователь сменил вкладку или перешел к другому приложению</li>
</ul>

<pre><code class="js">
var promise = Notification.requestPermission();
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-workers">Web Workers</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Спецификация Web Workers позволяет запускать дополнительные JavaScript-процессы (workers). Они могут обмениваться сообщениями с главным процессом, но у них свои переменные, и работают они также сами по себе</li>
	<li>Worker - это объект, созданный при помощи конструктора , который запускает JavaScript файл с кодом, который будет выполнен в потоке Worker’а</li>
	<li>Такие дополнительные процессы не имеют доступа к DOM, поэтому они полезны, преимущественно, при вычислениях, чтобы загрузить несколько ядер/процессоров одновременно</li>
	<li>Современные браузеры позволяют порождать подпроцессы Web Workers, они выполняются параллельно и могут отправлять/принимать сообщения, но не имеют доступа к DOM</li>
</ul>

<h4>1. Создание</h4>
<pre><code class="js">
var myWorker = new Worker("worker.js");
</code></pre>

<h4>2.Отправка данных в веб-воркер</h4>
У каждого веб воркера, как и у главного потока, имеется свой stack, heap и event loop. Послать сообщения в веб воркер (например, передать данные для расчетов) можно с помощью метода postMessage(). 
<pre><code class="js">
myWorker.postMessage(imageData);
</code></pre>

<h4>3. Событие типа message</h4>
Это создаст событие типа message в очередь событий web worker’а, которое будет обработано в следующей итерации event loop воркера.
<pre><code class="js">
onmessage = function(e) {
	console.log('Message received from main script');
	var workerResult = 'Result: ' + (e.data[0] * e.data[1]);
	console.log('Posting message back to main script');
	postMessage(workerResult);
}
</code></pre>

<h4>4. Отправка данных в главный поток</h4>
Аналогично, результаты вычислений и прочие данные воркер может отправить в главный поток с помощью метода postMessage(). И это опять же добавит событие типа message в очередь события главного потока.
<pre><code class="js">
myWorker.onmessage = function(e) {
	result.textContent = e.data;
	console.log('Message received from worker');
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="custom-properties-js">Custom Properties JS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var root = document.querySelector(':root');
var rootStyles = <bg-code>getComputedStyle</bg-code>(root);
var mainColor = rootStyles.<bg-code>getPropertyValue</bg-code>('--main-color');
console.log(mainColor); // '#ffeead'

root.style.<bg-code>setProperty</bg-code>('--main-color', '#88d8b0');
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="cors">CORS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-define>Cross-origin resource sharing</bg-define> (CORS «совместное использование ресурсов между разными источниками») - технология современных браузеров, которая позволяет предоставить веб-странице доступ к ресурсам другого домена</li>
</ul>

<!------------------------------------------------------>
<h3>Кросс-доменные запросы</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Запрос обязательно должен быть асинхронным</li>
</ul>

<ul class="list-point">
	<li>1. В кросс-доменный запрос браузер автоматически добавляет заголовок <u>Origin</u>, содержащий домен, с которого осуществлён запрос</li>
	<li>2. Если сервер разрешает кросс-доменный запрос с этого домена он должен добавить к ответу заголовок <u>Access-Control-Allow-Origin</u>, содержащий домен запроса или звёздочку <u>*</u>. Только при наличии такого заголовка в ответе – браузер сочтёт запрос успешным, а иначе JavaScript получит ошибку</li>
	<li>3. Чтобы JavaScript мог прочитать HTTP-заголовок ответа, сервер должен указать его имя в <u>Access-Control-Expose-Headers</u></li>
</ul>

<h4>Простой метод GET, POST, HEAD</h4>

<p>Запрос с домена http://test1.ru</p>
<pre><code class="js">
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://test2.ru/script.php', true);
xhr.onload = function() {
    console.log(this.responseText);
}
xhr.onerror = function() {
    console.log(this.status);
}
xhr.send();
</code></pre>

<p>Сервер http://test2.ru</p>
<pre><code class="js">
&lt;?php
    header('<bg-code>Access-Control-Allow-Origin</bg-code>: http://test1.ru'); // разрешить доступ домену http://test1.ru
    header('Access-Control-Allow-Origin: *');               // разрешить доступ любому домену
?&gt;
</code></pre>


<h4>Передавать куки и HTTP-авторизацию</h4>
<pre><code class="js">
xhr.withCredentials = true;
</code></pre>
<pre><code class="js">
&lt;?php
	header('Access-Control-Allow-Origin: домен');    // Использование звёздочки * запрещено
	header('<bg-code>Access-Control-Allow-Credentials</bg-code>: true');
?&gt;
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="jsonp">JSONP</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-define>JSONP</bg-define> (JSON with Padding) - дополнение к базовому формату JSON. Он предоставляет способ запросить данные с сервера, находящегося в другом домене - операцию, запрещённую в типичных веб-браузерах из-за политики ограничения домена</li>
	<li>JSONP - способ загрузки script на лету и обработки script, который вводится на страницу. Это означает введение нового объекта javascript с сервера в клиентское приложение /script</li>
	<li>Стандартное применение JSONP предоставляет междоменный доступ к существующему JSON API путём оборачивания содержимого JSON в вызов функции</li>
	<li>Разрешить браузерным страницам обойти политику ограничения домена путём вставки элемента script</li>
	<li><bg-define>JSONPP</bg-define> (Parameterized JSON with Padding — «параметризованный JSON с подкладкой») — развитие идеи JSONP</li>
	<li>Позволяет только получение данных GET методом. Отправка данных через POST недоступна</li>
</ul>

<!------------------------------------------------------>
<h3>Алгоритм работы</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>1. Инъекция элемента script</li>
	<li>2. Вызов скрипта с передачей парамером callback</li>
	<li>3. Сервер реализует выполнение callback с переданным им обязательным объектом. Функция обратного вызова - это только функция, которую вы уже настроили на клиенте, который script загружает вызовы в точке загрузки script для обработки данных, переданных ей</li>
</ul>

<!------------------------------------------------------>
<h3>Инъекция элемента script</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Скрипты, добавленные через JS ведут себя как async</li>
</ul>

<pre><code class="js">
function addScript(src){
	var script = document.createElement('script');
	script.src = src;
	script.type = 'text/javascript';
	script.async = false; // чтобы гарантировать порядок
	document.head.appendChild(script);
}

// загружаться скрипты начнут сразу в порядке 1 -> 2 -> 3
// выполнятся, как только загрузятся, если установлено script.async = false
addScript('1.js');  
addScript('2.js');  
addScript('3.js'); 
</code></pre>

<!------------------------------------------------------>
<h3>JSONP</h3>
<!------------------------------------------------------>
<pre><code class="js">
function addScript(src) {
    let script = document.createElement('script');
    script.src = src;
    document.head.appendChild(script);
}

addScript('https://www.google.com/?id=123&callback=clientFunction');

function clientFunction(arg) {
    //
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="websocket">WebSocket</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-define>Протокол WebSocket</bg-define> предназначен для решения снятия ограничений обмена данными между браузером и сервером. Кросс-доменный, универсальный, безопасный. Позволяет пересылать любые данные, на любой домен, безопасно и почти без лишнего сетевого трафика. Позволяет создать <u>постоянное соединение</u> для отображения в реальном времени (н-р: сервис биржи и т.д.)</li>
	<li>Сервер должен поддерживать протокол WebSocket</li>
	<li>Протокол WebSocket работает над TCP</li>
	<li>Создать подобный XMLHttpRequest-запрос (подделать WebSocket) невозможно: указанные выше заголовки запрещены к установке методом setRequestHeader</li>
	<li>Сервер может проанализировать эти заголовки и решить, разрешает ли он WebSocket с данного домена Origin</li>
</ul>

<h4>Открыть соединеиние</h4>
<pre><code class="js">
// создание объекта WebSocket с указанием протокола ws
var socket = new WebSocket("<bg-code>ws</bg-code>://javascript.ru/ws");  // протокол "ws" над "http"
var socket = new WebSocket("<bg-code>wss</bg-code>://javascript.ru/ws"); // протокол "wss" над "https"
</code></pre>

<h4>Коллбэки у socket</h4>
<p>Один получение данных и три при изменениях в состоянии соединения</p>
<pre><code class="js">
<bg-code>socket.onopen</bg-code> = function() {
	alert("Соединение установлено.");
};
<bg-code>socket.onclose</bg-code> = function(event) {
	if (event.wasClean) {
		alert('Соединение закрыто чисто');
	} else {
		alert('Обрыв соединения'); // например, "убит" процесс сервера
	}
	alert('Код: ' + event.code + ' причина: ' + event.reason);
};
<bg-code>socket.onmessage</bg-code> = function(event) {
	alert("Получены данные " + event.data);
};
<bg-code>socket.onerror</bg-code> = function(error) {
	alert("Ошибка " + error.message);
};
</code></pre>

<h4>Посылка данных</h4>
<pre><code class="js">
socket.send("Привет");              // строка
socket.send(form.elements[0].file); // файл из формы
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="comet">Comet</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-define>Comet</bg-define> - любая модель работы веб-приложения, при которой постоянное HTTP-соединение позволяет веб-серверу отправлять (push) данные браузеру без дополнительного запроса со стороны браузера</li>
	<li>AJAX – это «отправил запрос – получил результат», а COMET – это «непрерывный канал, по которому приходят данные»</li>
</ul>

<img src="img/js/comet.png" class="center" width="500px">

<ul class="list-point">
	<b>Взаимодействие с комет сервером построено следующим образом</b>
	<li>1. Браузер открывает страницу сайта</li>
	<li>2. После загрузки страницы JavaScript устанавливает постоянное соединение с comet сервером</li>
	<li>3. Пока открыта страница ваш сервер может отправить произвольное сообщение клиенту. Для этого он обращается с помощью Api к комет серверу и передаёт ему сообщение</li>
	<li>4. Комет сервер используя открытое соединение с браузером доставляет полученное сообщение в браузер</li>
	<li>5. JavaScript Api полученное от сервера сообщение предаёт в ваш callback</li>
</ul>



<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- Веб-компоненты -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-components-theory">Теория</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-header>Веб-компоненты</bg-header> - это семейство API, предназначенных для описания новых элементов DOM, подходящих для повторного использования. Функционал таких элементов отделён от остального кода, их можно применять в веб-приложениях собственной разработки</li>
	<li>HTML-элементу с нестандартным названием (например <mytag>) соответствует класс <u>HTMLUnknownElement</u>, и у него нет каких-либо особых методов</li>
</ul>

<pre><code class="html">
<a href="https://css-tricks.com/an-introduction-to-web-components/" target="_blank">[css-tricks.com] An Introduction to Web Components</a>
<a href="https://css-tricks.com/modular-future-web-components/" target="_blank">[css-tricks.com] A Guide to Web Components</a>
<a href="https://css-tricks.com/styling-a-web-component/" target="_blank">[css-tricks.com] Styling a Web Component</a>
<a href="https://www.polymer-project.org/" target="_blank">Polymer (полифилл на тему веб-компонент)</a>
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-components-custom-elements">Custom Elements</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<alert-error>document.registerElement => window.customElements.define (устаревшая конструкция)</alert-error>

<ul class="list-point">
	<li>Стандарт Custom Elements позволяет описывать для новых элементов свои свойства, методы, объявлять свой DOM, подобие конструктора и многое другое</li>
</ul>
<ul class="list-point">
	<li>Использовать новый элемент в HTML можно и до его объявления через <u>registerElement</u></li>
	<li>Для этого в браузере предусмотрен специальный режим «обновления» существующих элементов</li>
	<li>Если браузер видит элемент с неизвестным именем, в котором есть дефис - (такие элементы называются <u>«unresolved»</u>), то</li>
	<ul class="list-point">
		<li>Он ставит такому элементу специальный CSS-псевдокласс <u>:unresolved</u>, для того, чтобы через CSS можно было показать, что он ещё «не подгрузился»</li>
		<li>При вызове <u>registerElement</u> такие элементы автоматически обновятся до нужного класса</li>
	</ul>
</ul>

<pre><code class="js light">
<table>
	<tr><td><bg-methods>document.registerElement</bg-methods><bg-arguments>(имя, {prototype:прототип})</bg-arguments></td><td>  //</td></tr>
	<tr><td><em>	&#8226; имя</em></td><td>  // имя нового тега, например "mega-select". Оно обязано содержать дефис "-". Спецификация требует дефис, чтобы избежать в будущем конфликтов со стандартными элементами HTML. Нельзя создать элемент timer или myTimer – будет ошибка</td></tr>
	<tr><td><em>	&#8226; прототип</em></td><td>  // объект-прототип для нового элемента, он должен наследовать от HTMLElement, чтобы у элемента были стандартные свойства и методы</td></tr>
</table></code></pre>

<!------------------------------------------------------>
<h3>Регистрация элемента</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var element = <bg-code>Object.create(HTMLElement.prototype)</bg-code>;
element.action = function(content) {
    this.innerHTML = content;
};
<bg-code>document.registerElement</bg-code>("my-element", {
    prototype: element
});
document.querySelector('my-element').action('zzz');
<br><br>
</code></pre></div><div class="container-half"><pre><code class="js">
<bg-code>document.registerElement</bg-code>("my-element", {
    prototype: {
        __proto__: <bg-code>HTMLElement.prototype</bg-code>,
        action: function(content) { 
        	this.innerHTML = content; 
        },
        value: 77
    }
});
document.querySelector('my-element').action('zzz');
var a = document.querySelector('my-element').value;
</code></pre></div></div>

<pre><code class="html">
&lt;my-element&gt;Hello&lt;/my-element&gt;
</code></pre>

<!------------------------------------------------------>
<h3>Расширение встроенных элементов</h3>
<!------------------------------------------------------>
<pre><code class="js">
var element = <bg-code>Object.create(HTMLButtonElement.prototype)</bg-code>;
element.action = function(content) {
    this.innerHTML = content;
};
<bg-code>document.registerElement</bg-code>("my-element", {
    prototype: element,
    <bg-code>extends: 'button'</bg-code>
});
document.querySelector('button').action('zzz');
</code></pre>
<pre><code class="css">
&lt;button <bg-code>is="my-element"</bg-code>&gt;&lt;/button&gt;
</code></pre>

<!------------------------------------------------------>
<h3>Жизненный цикл</h3>
<!------------------------------------------------------>
<pre><code class="bash">
<em>createdCallback</em>                                     # элемент создан
<em>attachedCallback</em>                                    # элемент добавлен в документ
<em>detachedCallback</em>                                    # элемент удалён из документа
<em>attributeChangedCallback(name, prevValue, newValue)</em> # атрибут добавлен, изменён или удалён
</code></pre>

<pre><code class="js">
element.createdCallback = function() {
    //
}
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>

<!--__________________________________________________-->
<h4>#1 - Элемент таймер</h4>
<pre><code class="js">
// прототип с методами для нового элемента
var MyTimerProto = <bg-code>Object.create(HTMLElement.prototype)</bg-code>;
MyTimerProto.tick = function() { // свой метод tick
    this.innerHTML++;
};

// регистрируем новый элемент в браузере
<bg-code>document.registerElement</bg-code>("my-timer", {
    prototype: MyTimerProto
});

// вызовем метод tick() на элементе
setInterval(function() {
    timer.tick();
}, 1000);
</code></pre>
<pre><code class="html">
&lt;my-timer id="timer"&gt;0&lt;/my-timer&gt;
</code></pre>

<!--__________________________________________________-->
<h4>#2 - Элемент hello-world с таймером</h4>
<pre><code class="js">
// регистрация произойдёт через 2 сек
setTimeout(function() {
    <bg-code>document.registerElement</bg-code>("hello-world", {
        prototype: {
            __proto__: HTMLElement.prototype,
            sayHi: function() { alert('Привет!'); }
        }
    });
    hello.sayHi();
}, 2000);
</code></pre>
<pre><code class="css">
/* стиль для :unresolved элемента (до регистрации) */
hello-world<bg-code>:unresolved</bg-code> {
    color: blue;
}
hello-world {
    transition: color 3s;
}
</code></pre>
<pre><code class="html">
&lt;hello-world id="hello"&gt;Hello, world!&lt;/hello-world&gt;
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-components-shadow-dom">Shadow DOM</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<alert-error>Element.createShadowRoot => Element.attachShadowe (устаревшая конструкция)</alert-error>

<ul class="list-point">
	<li><bg-header>Shadow DOM</bg-header> - это средство для создания отдельного DOM-дерева внутри элемента, которое не видно снаружи без применения специальных методов. Shadow DOM - это внутренний DOM элемента, который существует отдельно от внешнего документа. В нём могут быть свои ID, свои стили и так далее. Причём снаружи его, без применения специальных техник, не видно, поэтому не возникает конфликтов</li>
	<li>Shadow DOM - спецификация, описывающая метод объединения нескольких DOM-деревьев в одну иерархию и как эти деревья взаимодействуют друг с другом в пределах документа, что позволяет лучше скомпоновать DOM</li>
	<li>Shadow DOM можно создать внутри любого элемента</li>
	<li>С момента создания Shadow DOM обычное содержимое (дети) элемента не отображается, а показывается только Shadow DOM</li>
	
	<b class="margin-top">&lt;content&gt;</b>
	<li>Тег <u>&lt;content&gt;</u> влияет только на отображение, он не перемещает узлы физически. Внутри <u>&lt;content&gt;</u> показывается не элемент целиком, а только его содержимое</li>
	<li>Внутри Shadow DOM можно использовать &lt;content&gt; много раз с разными значениями select, указывая таким образом, где конкретно какие части исходного содержимого разместить. Но при этом дублирование узлов невозможно. Если узел показан в одном &lt;content&gt;, то в следующем он будет пропущен</li>
	<li>Например, если сначала идёт &lt;content select="h3.title"&gt;, а затем &lt;content select="h3"&gt;, то в первом &lt;content&gt; будут показаны заголовки &lt;h3&gt; с классом title, а во втором – все остальные, кроме уже показанных</li>
	<li>Если в теге &lt;content&gt;&lt;/content&gt; есть содержимое, оно будет показано только в том случае, если узлов для вставки нет</li>
</ul>

<pre><code class="js light">
<table>
	<tr><td><b>JavaScript</b></td></tr>
	<tr><td><bg-methods>createShadowRoot</bg-methods><bg-arguments>()</bg-arguments></td><td>  // создание Shadow DOM</td></tr>
	<tr><td><bg-methods>shadowRoot</bg-methods><bg-arguments>()</bg-arguments></td><td>  // корень</td></tr>
	
	<tr><td><b>HTML</b></td></tr>
	<tr><td><bg-methods>&lt;content&gt;&lt;/content&gt;</bg-methods></td><td>  // замена содержимого</td></tr>

	<tr><td><b>CSS</b></td></tr>
	<tr><td><bg-methods>::shadow</bg-methods></td><td>  // выбирает корень Shadow DOM</td></tr>
	<tr><td><bg-methods>>>></bg-methods></td><td>  // полностью игнорирует границы между DOM'ами</td></tr>
</table></code></pre>

<!------------------------------------------------------>
<h3>Создание createShadowRoot</h3>
<!------------------------------------------------------>
<pre><code class="js">
var root = document.querySelector('#element').<bg-code>createShadowRoot()</bg-code>;
</code></pre>
<pre><code class="html">
&lt;div id="element"&gt;Hi&lt;/div&gt;
</code></pre

<!------------------------------------------------------>
<h3>Замена содержимого &lt;content&gt;&lt;/content&gt;</h3>
<!------------------------------------------------------>
<pre><code class="js">
// =&gt; Shadow - заменяет содержимое в "element"
root.innerHTML = '&lt;p&gt;Shadow&lt;/p&gt;'; 

// =&gt; Hi All Shadow - выводит всё содержимое из "element"
root.innerHTML = '&lt;h1&gt;<bg-code>&lt;content&gt;&lt;/content&gt;</bg-code>&lt;/h1&gt; &lt;p&gt;Shadow&lt;/p&gt;';

// =&gt; Hi Shadow - вывести только &lt;h3&gt; из "element"
root.innerHTML = '&lt;h1&gt;<bg-code>&lt;content select="h3"&gt;&lt;/content&gt;</bg-code>&lt;/h1&gt; &lt;p&gt;Shadow1&lt;/p&gt;';
</code></pre>
<pre><code class="html">
&lt;div id="element"&gt;
	&lt;h3&gt;Hi&lt;/h3&gt;
	&lt;p&gt;All&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<!------------------------------------------------------>
<h3>Корень shadowRoot</h3>
<!------------------------------------------------------>
<pre><code class="js">
var rootElement = document.querySelector('#element').<bg-code>shadowRoot</bg-code>;
rootElement.querySelector('p').innerHTML = 'New Shadow';
</code></pre>

<!------------------------------------------------------>
<h3>Стилизация</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>По умолчанию стили внутри Shadow DOM относятся только к его содержимому</li>
</ul>

<ul class="list-point">
	<li><bg-methods>::shadow</bg-methods></td><td> - выбирает корень Shadow DOM</li>
	<li>Выбранный элемент сам по себе не создаёт CSS box, но служит отправной точкой для дальнейшей выборки уже внутри дерева Shadow DOM. Например, <bg-code>#elem::shadow > div</bg-code> найдёт внутри Shadow DOM #elem элементы div первого уровня</li>
	<li><bg-methods>>>></bg-methods></td><td> - особого вида CSS-селектор для всех элементов Shadow DOM, который полностью игнорирует границы между DOM'ами, включая вложенные подэлементы, у которых тоже может быть свой Shadow DOM</li>
	<li>Например, <bg-code>#elem >>> span</bg-code> найдёт все span внутри Shadow DOM #elem, но кроме того, если в #elem есть подэлементы, у которых свой Shadow DOM, то оно продолжит поиск в них</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-components-virtual-dom">Virtual DOM</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM</li>
	<li>При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено</li>
	<li>Virtual DOM не является стандартом и в конечном итоге мы по-прежнему взаимодействуем с DOM, но делаем это как можно реже и более эффективно</li>
</ul>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-components-template">Шаблоны &lt;template&gt;</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
<li>Элемент &lt;template&gt; предназначен для хранения «образца» разметки, невидимого и предназначенного для вставки куда-либо. Содержимое читается находящимся вообще «вне документа»</li>
</ul>

<h4>Пример 1</h4>
<pre><code class="js">
element.appendChild(template.<bg-code>content.cloneNode(true)</bg-code>); // => Hi Template
</code></pre>
<pre><code class="html">
&lt;div id="element"&gt;Hi&lt;/div&gt;
&lt;template id="template"&gt;Template&lt;/template&gt;
</code></pre>

<h4>Пример 2</h4>
<pre><code class="html">
&lt;div class="main"&gt;
	&lt;div class="main-header"&gt;Main Header&lt;/div&gt;
&lt;/div&gt;
&lt;template id="template"&gt;
	&lt;div class="template-header"&gt;Template Header&lt;/div&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="js">
const template = document.getElementById('template');
const instance = document.<bg-code>importNode</bg-code>(<bg-code>template.content</bg-code>, true);

const main = document.querySelector('.main');
const header = main.querySelector('.main-header');
if (header !== null) {
	instance.querySelector('.template-header').innerHTML = header.innerHTML;
}

main.innerHTML = '';
main.appendChild(instance);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-components-imports">HTML Imports</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<alert-error>HTML Imports => ES modules (устаревшая конструкция)</alert-error>

<ul class="list-point">
	<li>Спецификация HTML Imports описывает, как вставить один документ в другой при помощи HTML-тега &lt;link rel="import"&gt;</li>
	<li>HTML, загруженный через &lt;link rel="import"&gt; имеет отдельный DOM документа, но скрипты в нём выполняются в общем контексте страницы</li>
	<li>Файл, загруженный через &lt;link rel="import"&gt;, обрабатывается, выполняются скрипты, строится DOM документа, но не показывается, а записывается в свойство link.import</li>
</ul>

<alert-info>Запускать на сервере</alert-info>

<pre><code class="js light">
<table>
	<tr><td><bg-methods>link.import</bg-methods></td><td>  // доступ снаружи</td></tr>
	<tr><td><bg-methods>document.currentScript.ownerDocument</bg-methods></td><td>  // доступ из внутреннего скрипта</td></tr>
</table></code></pre>

index.html
<pre><code class="html">
&lt;h1&gt;Main Document&lt;/h1&gt;

&lt;script&gt;
	function show() {
		var element = page.<bg-code>import</bg-code>.querySelector('h1');
		document.body.appendChild(element);
	};
&lt;/script&gt;

&lt;link <bg-code>rel="import"</bg-code> href="page.html" id="page" onload="show()"&gt;
</code></pre>

page.html
<pre><code class="html">
&lt;h1&gt;Imported Document&lt;/h1&gt;

&lt;script&gt;
	// доступ к импортированному документу
    var importedDocument = document.<bg-code>currentScript.ownerDocument</bg-code>; 
    importedDocument.querySelector('h1').innerHTML = 'Changed Text';
&lt;/script&gt;
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="module-system">Модульная система</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<b>Стандарты</b>
	<li><bg-define>1. Паттерн "Модуль"</bg-define> (2003 год) - немедленно вызываемая функция, образующая приватную область видимости</li>

	<li><bg-define>2. CommonJS (CJS)</bg-define> (2009 год) <bg-code>module.exports -> require</bg-code> Реализация: <a href="https://nodejs.org/api/modules.html" target="_blank">Модульная система Node.js</a></li>
	<li>Предназначен для синхронной загрузки. Преимущественно используется на стороне сервера</li>

	<li><bg-define>3. Asynchronous Module Definition (AMD)</bg-define> (2009 год) <bg-code>define -> require</bg-code> Реализация: <a href="https://requirejs.org/" target="_blank">RequireJS</a></li>
	<li>Предназначен для асинхронной загрузки. Преимущественно используется на стороне клиента.</li>
	
	<li><bg-define>4. Universal Module Definition (UMD)</bg-define> (2011 год). Объединение AMD и CommonJS. Суть подхода: проверить существование функции define и если она есть определить модуль в формате AMD, а если нет, в формате CommonJS</li>

	<li><bg-define>5. Модули ES6</bg-define> (2015 год) <bg-code>export -> import</bg-code></li>

</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="module-es6">Модули ES6</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="html">
<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import" target="_blank">import</a>
<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export" target="_blank">export</a>
</code></pre>

<ul class="list-point">
	<b>Особенности</b>
	<li>Не блокируют парсинг html</li>
	<li>Выполняются отложенно</li>
	<li>Имею свою область видимости</li>
	<li>Код модуля всегда выполняется в строгом режиме</li>
</ul>

<!------------------------------------------------------>
<h3>import</h3>
<!------------------------------------------------------>
<pre><code class="js">
import { libFunction } from './modules/lib';           // импорт одного значения
import { libFunction, libConst } from './modules/lib'; // импорт нескольких значений
import { libConst as name } from './modules/lib';      // переименовать значения
import './modules/lib' as obj;                         // импорт модуля как объекта, значениями свойств которого будут экспортированные значения (obj.libConst)
import * as obj from './modules/lib';                  // импорт модуля как объекта
import './modules/lib'                                 // импорт всех данных (в "./modules/lib" нет "export")
</code></pre>

<!------------------------------------------------------>
<h3>export</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Для экспорта обязательно нужно имя</li>
</ul>

<pre><code class="js">
export const libConst = 77;
export function libFunction() {
    console.log(libFunction);
}
</code></pre>

<pre><code class="js">
let one = 1;
let two = 2;
export {one, two}
</code></pre>

<pre><code class="js">
export {one as once, two as twice}; // переименование
</code></pre>

<!------------------------------------------------------>
<h3>export default (экспорт по умолчанию)</h3>
<!------------------------------------------------------>

<h4>Именованный класс</h4>
<pre><code class="js">
export default class User {
	constructor(name) {
		this.name = name;
	}
};
</code></pre>
<pre><code class="js">
import User from './modules/lib';
let user = new User('Jane'); // => User {name: "Jane"}
</code></pre>


<h4>Анонимный класс</h4>
<pre><code class="js">
export default class { 
	constructor(name) {
		this.name = name;
	}
};
</code></pre>

<pre><code class="js">
import User from './modules/lib';
let user = new User('Jane'); // => _default {name: "Jane"}
</code></pre>

<!------------------------------------------------------>
<h3>Использование в браузере</h3>
<!------------------------------------------------------>

<pre><code class="html">
<a href="https://codesandbox.io/s/oj2rwm9v35" target="_blank">CodeSandbox</a>
</code></pre>

<pre><code class="html red">
&lt;!-- Использование в браузере --&gt;
&lt;script type="module"&gt;&lt;/script&gt;

&lt;!-- Подключение модуля из внешнего файла --&gt;
&lt;script type="module" import="main.js"&gt;&lt;/script&gt;
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="proxy">Proxy</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-define>Прокси (proxy)</bg-define> - особый объект, смысл которого – перехватывать обращения к другому объекту/функции и, при необходимости, модифицировать их</li>
	<li>Прокси позволяет модифицировать поведение объекта как угодно, перехватывать любые обращения к его свойствам и методам, включая вызовы для функций</li>
	<li>Почти любая операция может быть перехвачена и обработана прокси до или даже вместо доступа к объекту target, например: чтение и запись свойств, получение списка свойств, вызов функции (если target – функция)</li>
	<li>Если ловушки нет – операция идёт над target</li>
</ul>

<pre><code class="js light">
<table>
	<tr><td>let proxy = <bg-methods>new Proxy</bg-methods><bg-arguments>(target, handler)</bg-arguments></td><td></td></tr>
	<tr><td><em>	&#8226; target</em></td><td>  // объект, обращения к которому надо перехватывать</td></tr>
	<tr><td><em>	&#8226; handler</em></td><td>  // объект с «ловушками»: функциями-перехватчиками для операций к target</td></tr>
</table></code></pre>

<!------------------------------------------------------>
<h3>get/set</h3>
<!------------------------------------------------------>
<pre><code class="js light">
<table>
	<tr><td><bg-methods>get</bg-methods><bg-arguments>(target, property, receiver)</bg-arguments></td><td> // срабатывает при чтении свойства из прокси</td></tr>
	<tr><td><em>	&#8226; target</em></td><td>  // целевой объект, тот же который был передан первым аргументом в new Proxy</td></tr>
	<tr><td><em>	&#8226; property</em></td><td>  // имя свойства</td></tr>
	<tr><td><em>	&#8226; receiver</em></td><td>  // объект, к которому было применено присваивание. Обычно сам прокси, либо прототипно наследующий от него</td></tr>
</table></code></pre>

<pre><code class="js light">
<table>
	<tr><td><bg-methods>set</bg-methods><bg-arguments>(target, property, value, receiver)</bg-arguments></td><td> // срабатывает при чтении свойства из прокси</td></tr>
	<tr><td><em>	&#8226; target</em></td><td>  // целевой объект, тот же который был передан первым аргументом в new Proxy</td></tr>
	<tr><td><em>	&#8226; property</em></td><td>  // имя свойства</td></tr>
	<tr><td><em>	&#8226; value</em></td><td>  // значение свойства</td></tr>
	<tr><td><em>	&#8226; receiver</em></td><td>  // объект, к которому было применено присваивание, обычно сам прокси, либо прототипно наследующий от него</td></tr>
</table></code></pre>

<ul class="list-point">
	<li>Метод set должен вернуть true, если присвоение успешно обработано и false в случае ошибки (приведёт к генерации TypeError)</li>
</ul>

<pre><code class="js">
let user = {};

let proxy = new Proxy(user, {
	get(target, prop) {
		console.log(`Чтение ${prop}`);
		return target[prop];
	},
	set(target, prop, value) {
		console.log(`Запись ${prop} ${value}`);
		target[prop] = value;
		return true;
	}
});

proxy.firstName = 'Tony';    // запись
proxy.firstName;             // чтение
console.log(user.firstName); // => 'Tony'
</code></pre>

<!------------------------------------------------------>
<h3>has</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Ловушка has срабатывает в операторе in и некоторых других случаях, когда проверяется наличие свойства</li>
</ul>
<pre><code class="js">
// dictionary будет всегда возвращать true для любой in-проверки:
let dictionary = {
	'Hello': 'Привет'
};

dictionary = new Proxy(dictionary, {
	has(target, phrase) {
		return true;
	}
});

alert("BlaBlaBla" in dictionary); // true
</code></pre>

<!------------------------------------------------------>
<h3>deleteProperty</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Ловушка deleteProperty по синтаксису аналогична get/has. Срабатывает при операции delete, должна вернуть true, если удаление было успешным</li>
</ul>
<pre><code class="js">
// delete не повлияет на исходный объект, так как все операции перехватываются и «аннигилируются» прокси

let dictionary = {
	'Hello': 'Привет'
};

let proxy = new Proxy(dictionary, {
	deleteProperty(target, phrase) {
		return true; // ничего не делаем, но возвращает true
	}
});

// не удалит свойство
delete proxy['Hello'];

alert("Hello" in dictionary); // true

// будет то же самое, что и выше
// так как нет ловушки has, операция in сработает на исходном объекте
alert("Hello" in proxy); // true
</code></pre>

<!------------------------------------------------------>
<h3>apply</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Если аргумент target прокси – функция, то становится доступна ловушка apply для её вызова</li>	
</ul>

<pre><code class="js light">
<table>
	<tr><td><bg-methods>apply</bg-methods><bg-arguments>(target, thisArgument, argumentsList)</bg-arguments></td><td>  //</td></tr>
	<tr><td><em>	&#8226; target</em></td><td>  // исходный объект</td></tr>
	<tr><td><em>	&#8226; thisArgument</em></td><td>  // контекст this вызова</td></tr>
	<tr><td><em>	&#8226; argumentsList</em></td><td>  // аргументы вызова в виде массива</td></tr>
</table></code></pre>

<pre><code class="js">
// может обработать вызов сама и/или передать его функции
function sum(a, b) {
	return a + b;
}

let proxy = new Proxy(sum, {
	// передаст вызов в target, предварительно сообщив о нём
	apply: function(target, thisArg, argumentsList) {
		alert(`Буду вычислять сумму: ${argumentsList}`);
		return target.apply(thisArg, argumentsList);
	}
});

// Выведет сначала сообщение из прокси,
// а затем уже сумму
alert( proxy(1, 2) );
</code></pre>


<!------------------------------------------------------>
<h3>construct</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Ловушка construct(target, argumentsList) перехватывает вызовы при помощи new. Она получает исходный объект target и список аргументов argumentsList</li>	
</ul>

<pre><code class="js">
// передаёт операцию создания исходному классу или функции-конструктору, выводя сообщение об этом

function User(name, surname) {
	this.name = name;
	this.surname = surname;
}

let UserProxy = new Proxy(User, {
	// передаст вызов new User, предварительно сообщив о нём
	construct: function(target, argumentsList) {
		alert(`Запуск new с аргументами: ${argumentsList}`);
		return new target(...argumentsList);
	}
});

let user = new UserProxy('Tony', 'Smith');

alert( user.name ); // Tony
</code></pre>

<!------------------------------------------------------>
<h3>Полный список возможных функций-перехватчиков, которые может задавать handler</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf" target="_blank">getPrototypeOf</a> - перехватывает обращение к методу <bg-code>getPrototypeOf</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/setPrototypeOf" target="_blank">setPrototypeOf</a> - перехватывает обращение к методу <bg-code>setPrototypeOf</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible" target="_blank">isExtensible</a> - перехватывает обращение к методу <bg-code>isExtensible</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/preventExtensions" target="_blank">preventExtensions</a> - перехватывает обращение к методу <bg-code>preventExtensions</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor" target="_blank">getOwnPropertyDescriptor</a> - перехватывает обращение к методу <bg-code>getOwnPropertyDescriptor</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/defineProperty" target="_blank">defineProperty</a> - перехватывает обращение к методу <bg-code>defineProperty</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has" target="_blank">has</a> - перехватывает проверку существования свойства, которая используется в операторе <bg-code>in</bg-code> и в некоторых других методах встроенных объектов</li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get" target="_blank">get</a> - перехватывает чтение свойства</li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set" target="_blank">set</a> - перехватывает запись свойства</li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/deleteProperty" target="_blank">deleteProperty</a> - перехватывает удаление свойства оператором <bg-code>delete</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/enumerate" target="_blank">enumerate</a> - срабатывает при вызове <bg-code>for..in</bg-code> или <bg-code>for..of</bg-code>, возвращает итератор для свойств объекта</li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/ownKeys" target="_blank">ownKeys</a> - перехватывает обращения к методу <bg-code>getOwnPropertyNames</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply" target="_blank">apply</a> - перехватывает вызовы <bg-code>target()</bg-code></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct" target="_blank">construct</a> - перехватывает вызовы new <bg-code>target()</bg-code></li>
</ul>

<ul class="list-point">
	<li>Каждый перехватчик запускается с <bg-code>handler</bg-code> в качестве <bg-code>this</bg-code>. Это означает, что <bg-code>handler</bg-code> кроме ловушек может содержать и другие полезные свойства и методы</li>
	<li>Каждый перехватчик получает в аргументах <bg-code>target</bg-code> и дополнительные параметры в зависимости от типа</li>
	<li>Если перехватчик в <bg-code>handler</bg-code> не указан, то операция совершается, как если бы была вызвана прямо на <bg-code>target</bg-code></li>
</ul>



</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
