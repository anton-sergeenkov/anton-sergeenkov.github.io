<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="icon" type="image/png" href="img/favicon.png">
	<link rel="stylesheet" type="text/css" href="css/main.css">
</head>
<body>
<div id="container">
<div id="menu-left">
	<div id="menu-left-starter">
		<div id="menu-left-show"></div>
		<a href="#menu-top">Starter</a>
	</div>
	
	<div class="theme">События</div>
	<a href="#actions">Назначение обработчиков событий</a>
	<a href="#actions-target">Делегирование событий</a>
	<a href="#actions-params">Передаваемый параметр (Event)</a>
	<a href="#actions-list">Список событий</a>
	<a href="#actions-samples">Примеры</a>

	<div class="theme">Циклы и массивы</div>
	<a href="#cycle">Циклы</a>
	<a href="#cycle-array">Перебор массива</a>
	<a href="#map"><bg-menu>map</bg-menu> (ES6)</a>
	<a href="#array">Массивы</a>
	<a href="#array_obj">Массивы обьектов</a>

	<div class="theme">ES6</div>
	<a href="#set"><bg-menu>Set</bg-menu></a>
	<a href="#spread">Оператор разворота</a>
	<a href="#pattern">Шаблонные строки</a>
	<a href="#destructive-array">Деструктивное присваивание array</a>
	<a href="#destructive-obj">Деструтивное присваивание object</a>
	<a href="#symbol">Symbol</a>
	<a href="#iterators">Iterators</a>

	<div class="theme">Асинхронный код</div>
	<a href="#collback">1. Collback Function</a>
	<a href="#promise">2. Promise (ES6)</a>
	<a href="#generators">3. Generators (ES6)</a>
	<a href="#async-func">4. Async Function (ES2017)</a>

	<div class="theme">AJAX</div>
	<a href="#ajax-request">Технологии</a>
	<a href="#xmlhttprequest">1. XMLHttpRequest</a>
	<a href="#fetch">2. Fetch</a>
	<a href="#axios">3. Axios</a>
	<a href="#ajax-variants">Варианты запросов</a>
	<a href="#ajax-http-methods">HTTP-методы</a>

	<div class="theme">Client Data</div>
	<a href="#data-storage"><bg-menu>localStorage</bg-menu> <bg-menu>sessionStorage</bg-menu></a>
	<a href="#data-db"><bg-menu>IndexedDB</bg-menu></a>
	<a href="#data-cookie"><bg-menu>cookie</bg-menu></a>
	
	<div class="theme">Advanced</div>
	<a href="#patterns">Паттерны проектирования</a>
	<a href="#garbage-collection">Сборщик мусора</a>

	<div class="theme">Basic I</div>
	<a href="#type">Типы данных</a>
	<a href="#select">Выборка элементов</a>
	<a href="#methods">Методы элементов страницы</a>
	<a href="#css"><bg-menu>classList</bg-menu> <bg-menu>style</bg-menu></a>
	<a href="#attribute"><bg-menu>attributes</bg-menu></a>
	<a href="#form">Web Forms</a>
	<a href="#methods-this"><bg-menu>this</bg-menu> <bg-menu>bind</bg-menu> <bg-menu>call</bg-menu> <bg-menu>apply</bg-menu></a>
	<a href="#dom-element">DOM</a>
	<a href="#str">Строки</a>
	<a href="#number">Числа</a>
	<a href="#math">Math</a>
	<a href="#operators">Операторы</a>
	<a href="#catch">Исключения</a>
	<a href="#json">JSON</a>
	<a href="#regexr">Регулярные выражения</a>

	<div class="theme">Window</div>
	<a href="#web-api">Web API</a>
	<a href="#document-open">Open / Location</a>
	<a href="#document-width">Width / Height</a>
	<a href="#document-media">Media queries</a>

	<div class="theme">Basic II</div>
	<a href="#date">Дата и время</a>
	<a href="#case">Условные операторы</a>
	<a href="#timeout">Таймеры</a>
	<a href="#prevent">Отмена обычного поведения</a>
	<a href="#external-script">Асинхронные скрипты: defer/async</a>
	<a href="#comparison">Сравнение и логические значения</a>
	<a href="#console">Console</a>
	<a href="#method-chaining">Цепные вызовы методов</a>
	<a href="#chrome-dev-tools">Chrome DevTools</a>

	<div class="theme">Theory</div>
	<a href="#ecmascript">ECMAScript</a>
	<a href="#jsdoc">Синтаксис JSDoc</a>
	<a href="#strict-mode">Strict Mode</a>
	<a href="#dictionary">Словарь</a>
</div>
<div id="content-wrapper">
<div id="menu-top"></div>
<div id="content">



<h1>JavaScript</h1>

<pre><code class="js">
var element = document.getElementById('element');
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="spread">Оператор разворота (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
Позволяет разворачить элементы массива для передачи в качестве аргументов функций 
или в элементы другого массива
<h3>Массив</h3>
<pre><code class="js">
var staticLanguages = ['C', 'C++', 'Java'];
var dinamicLanguages = ['JavaScript', 'PHP', 'Ruby'];
var languages = [...staticLanguages, 'C#', ...dinamicLanguages, 'Python'];
// result: ['C', 'C++', 'Java', 'C#', 'JavaScript', 'PHP', 'Ruby']
</code></pre>

<h3>Функция</h3>
<pre><code class="js">
function add(x,y,z) {
	console.log(x + y + z);
}
var numbers = [1, 2, 3];
add(...numbers);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions">Назначение обработчиков событий</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<img src="img/js/event.jpg" width="450px" class="center">
<ul class="list">
	<b>Стандартная модель событий (Распространение событий)</b>
	<li><bg-list>Event.CAPTURING_PHASE=1</bg-list> (перехват) - идет от родительского до целевого (html -> body -> button). Выполняется сразу после того, как происходит событие. Событие начинается на самом верхнем уровне, которым является либо объект <u>document</u>, либо объект <u>window</u> в зависимости от события. Отсюда оно опускается, проходя через тег <u>html</u> и через то, что находится в этом теге, до тех пор, пока не достигнет элемента, в пределах которого оно возникло</li>
	<li><bg-list>Event.AT_TARGET=2</bg-list> (целевой элемент захвата)</li>
	<li><bg-list>Event.BUBBLING_PAGE=3</bg-list> (всплытие). В её ходе повторяется тот же процесс, но наоборот. Всё начинается с элемента, который вызвал событие, оно «всплывает» до корневого элемента <u>html</u></li>
</ul>

<h3>1. Использование атрибута HTML</h3>

<pre><code class="html">
&lt;button onclick="alert('action')"&gt;Action&lt;/button&gt;
&lt;button onclick="alert(this.innerHTML)"&gt;Вывести содержимое&lt;/button&gt;
&lt;button onclick="action()"&gt;Action&lt;/button&gt;
</code></pre>

<h3>2. Использование свойства DOM-объекта</h3>
<pre><code class="html">
&lt;button id="element"&gt;Action&lt;/button&gt;
element.onclick = function() {
	alert(1);
}
</code></pre>

<pre><code class="html">
&lt;button id="element"&gt;Action&lt;/button&gt;
element.onclick = action;
function action() {
	alert(1);
}
</code></pre>

<h3>3. addEventListener и removeEventListener</h3>
<pre class="js"><code>
element.<em>addEventListener</em>(event, handler[, phase]);
element.<em>removeEventListener</em>(event, handler[, phase]);
<em>event</em>   - имя события, например click
<em>handler</em> - ссылка на функцию, которую нужно поставить обработчиком
<em>phase</em>   - необязательный аргумент, «фаза», на которой обработчик должен сработать
</code></pre>

<pre><code class="html">
&lt;button id="element"&gt;Action&lt;/button&gt;
</code></pre>

<pre><code class="js">
function action() {
	alert(1);
}
var element = document.querySelector('#element');
element.addEventListener('click', action);
element.removeEventListener('click', action);
</code></pre>

<p>Метод addEventListener позволяет добавлять несколько обработчиков на одно событие одного элемента</p>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-target">Делегирование событий</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>Делегирование событий</bg-list> - техника, которая использует механизм всплытия событий. Добавляя прослушиватель к родительскому элементу, разработчик может наладить обработку событий для его потомков</li>
	<li>Внутри функции обратного вызова прослушивателя события целевой элемент события будет представлен параметром <u>target</u>, который можно использовать для принятия решения о дальнейших действиях. Например, атрибут этого параметра data может хранить идентификатор для доступа к свойствам объекта</li>
</ul>
<pre><code class="js">
parentEl.addEventListener('click', function(e) {
	if(e.target && e.target.nodeName == 'BUTTON') {
		// щелчок по кнопке
	} 
});
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-params">Передаваемый параметр (Event)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list">
	<li><bg-list>Event</bg-list> - объект созданный перед запуском события</li>
</ul>

<pre><code class="js">
var btn = document.getElementById('btn');

btn.addEventListener('click', getButton);

function getButton(e) {
	console.log(e.type);          // название события
	console.log(e.target);        // инициатор события
	console.log(e.currentTarget); // элемент на котором висит обработчик
	console.log(e.eventPhase);    // число, указывающее этап (Event.CAPTURING_PHASE=1, Event.AT_TARGET=2, Event.BUBBLING_PAGE=3)
	console.log(e.timeStamp);     // объект Date, указывающий, когда произошло событие
	console.log(e.bubbles);       // true если событие может всплывать по дереву элементов. события blur, focus, load, unload не всплывают
	console.log(e.cancelable);    // true если с этим событием связано действие по умолчанию и его можно отменить preventDefault

	e.preventDefault();           // отключение действия события по умолчанию
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-list">Список событий</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>События мыши</h3>
<ul class="list">
	<li><bg-list>click</bg-list> - одиночный клик левой кнопки мыши</li>
	<li><bg-list>contextmenu</bg-list> - одиночный клик правой кнопкой мыши</li>
	<li><bg-list>mouseover</bg-list> - наведение мыши</li>
	<li><bg-list>mousedown</bg-list> - нажатие кнопки мыши</li>
	<li><bg-list>mouseup</bg-list> - отпускание кнопки мыши</li>
	<li><bg-list>mousemove</bg-list> - передвижение мыши</li>

	<li><bg-list>mouseout</bg-list> - увод мыши</li>
	<li><bg-list>dblclick</bg-list> - двойной щелчек левой кнопки мыши</li>
</ul>

<h3>События на элементах управления</h3>
<ul class="list">
	<li><bg-list>submit</bg-list> - момент отправки формы обработчику (если кнопка типа "submit")</li>
	<li><bg-list>focus</bg-list> - момент получения фокуса объектом (работает и для ссылок)</li>

	<li><bg-list>blur</bg-list> - момент потери фокуса объектом (работает и для ссылок)</li>
	<li><bg-list>change</bg-list> - изменение объекта формы (поле, радиобаттон и т.д.)</li>
	<li><bg-list>reset</bg-list> - сброс формы (специальной кнопкой)</li>
</ul>

<h3>Клавиатурные события</h3>
<ul class="list">
	<li><bg-list>keydown</bg-list> - момент нажатия клавиши, до момента отпускания</li>
	<li><bg-list>keyup</bg-list> - момент отпускания клавиши</li>

	<li><bg-list>keypress</bg-list> - нажатие клавиши на клавиатуре</li>
</ul>

<h3>События документа</h3>
<ul class="list">
	<li><bg-list>DOMContentLoaded</bg-list> - возникает после окончательной загрузки и парсинга HTML-документа, не дожидаясь загрузки стилей, картинок и фреймов</li>

	<li><bg-list>load</bg-list> - возникает после полного окончания загрузки ресурса (всех картинок, стиле и прочего)</li>
	<li><bg-list>resize</bg-list> - изменение размеров окна браузера</li>
	<li><bg-list>scroll</bg-list> - прокрутка страницы</li>
	<li><bg-list>unload</bg-list> - уход со страницы</li>
</ul>

<h3>События CSS</h3>
<ul class="list">
	<li><bg-list>transitionend</bg-list> - когда CSS-анимация завершена</li>
</ul>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="actions-samples">Обработчики событий (примеры)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
// полная загрузка страницы
window.onload = function() {
	//
}
</code></pre>

<pre><code class="bash red">
# использование значения keyCode событий - устаревшая практика
# и может не поддерживаться в новых браузерах
</code></pre>

<pre><code class="js">
// обработка нажатия кнопки и вывод ее кода
window.onkeydown = function(event) {
	console.log(event.keyCode);
}
</code></pre>

<pre><code class="js">
// отслеживание изменения hash
window.onhashchange = function() {
    var a = location.hash.slice(1);
}
</code></pre>

<pre><code class="js">
// click на элемент
element.onclick = function() {
	//
}
</code></pre>

<pre><code class="js">
// выбрать все input и повесить обработчик focus
var items = document.querySelectorAll('.item');

for(var i=0; i<=items.length-1; i++) {
	items[i].addEventListener('focus', function() {
		this.style.border = '2px solid blue';
	})
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="map">Map (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Используется для трансформации массива</li>
	<li>Объект map, ассоциативный массив</li>
	<li>Ключом может быть различные типы данных, не только строки и символы как у объекта</li>
	<li>Можно перебрать в цикле for...of</li>
	<li>Нет литеральной формы, поэтому используется конструктор new</li>
	<li>Объект map в отличие от обычного объекта является перебираемым объектом, который можно пербирать в цикле for...of</li>
</ul>

<pre><code class="js">
var names = ['HTML', 'CSS', 'JavaScript'];
var nameLengths = names.map(function(name) {
	return name.length;
});
// получили массив с длинами
alert(nameLengths); // 4,3,10
</code></pre>

<h3>Задание значений при объявлении</h3>
<pre><code class="js">
const map = new Map([
	['Hi', 'Привет'],
	[42, 'Ответ на главнй вопрос'],
	[true, false],
	[{}, 'Объект'],
	[function() {}, 'Функция']
]);
</code></pre>

<h3>Основные методы</h3>
<pre><code class="js">
const map = new Map();

map.<bg-code>set</bg-code>(42, 'Ответ на главный вопрос'); // установить значение
var a = map.<bg-code>get</bg-code>(42);                    // получить значение
var a = map.<bg-code>size</bg-code>;                       // получить кол-во элементов
var a = map.<bg-code>has</bg-code>(42);                    // проверка наличия значения

map.<bg-code>delete</bg-code>(42);                         // удалить значение
map.<bg-code>clear</bg-code>();                            // удалить все значения

var a = map.<bg-code>keys</bg-code>();                     // возвращает перебираемый объект с ключами
var a = map.<bg-code>values</bg-code>();                   // возвращает перебираемый объект с значениями
var a = map.<bg-code>entries</bg-code>();                  // возвращает массив массивов
</code></pre>

<h3>Перебор map</h3>
<pre><code class="js">
for(let [key, value] of map) {
	console.log(key, value);
}
</code></pre>

<pre><code class="js">
map.forEach((value, key, map) => console.log(value, key));
</code></pre>

<h3>Примеры</h3>
<pre><code class="js">
const map = new Map();
map.set('HTML', 'HyperText Markup Language')
	.set('CSS', 'Cascading Style Sheets')
	.set('JS', 'JavaScript');
</code></pre>

<h4>keys()</h4>
<pre><code class="js">
// обратно получаем не массив, а объект MapIterator (объект для перебора)
console.log(map.keys()); // MapIterator {"HTML", "CSS", "JS"}

// получить объекты по порядку можно используя оператор распространения
console.log(...map.keys()); // HTML CSS JS

// можно получить массив обернув в []
console.log([...map.keys()]); //["HTML", "CSS", "JS"] 
</code></pre>

<h4>values()</h4>
<pre><code class="js">
console.log([...map.values()]); // ["HyperText Markup Language", "Cascading Style Sheets", "JavaScript"]
</code></pre>

<h4>entries()</h4>
<pre><code class="js">
console.log([...map.entries()]); // массив массивов
// можно использовать для клонирования map
const map2 = new Map(map.entries());
</code></pre>

<pre><code class="js">
// получить ключ:значение с помощью реструктруризации
const [first, second, third] = map;
console.log(first);  // ["HTML", "HyperText Markup Language"] 
console.log(second); // ["CSS", "Cascading Style Sheets"]
console.log(third);  // ["JS", "JavaScript"]

const [[key, value], second, third] = map;
console.log(key);   // HTML 
console.log(value); // HyperText Markup Language
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="destructive-array">Деструктивное присваивание массивов (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var languages = ['JavaScript', 'Python', 'Ruby'];
// ES5
var js = languages[0];
var py = languages[1];
var rb = languages[2];
</code></pre>

<h4>Деструтивное присваивание</h4>
<pre><code class="js">
var languages = ['JavaScript', 'Python', 'Ruby'];
var [js, py, rb] = languages;
</code></pre>

<h4>Игнорирование значения</h4>
<pre><code class="js">
var scores = [3, 4, 5];
var [low, , high] = scores; 
</code></pre>

<h4>Преобразование в массив оставшихся значений</h4>
<pre><code class="js">
var scores = [3, 4, 5];
var [low, ...rest] = scores;
</code></pre>

<h4>Значение по умолчанию</h4>
<pre><code class="js">
var scores = [3, 4];
var [low, mid, high=5] = scores;
</code></pre>

<h4>Значение из массива</h4>
<pre><code class="js">
var scores = [3, 4, [5, 6]];
var [low, mid, [high, higher]] = scores;
</code></pre>

<h4>Деструктивное присванивание как параметр функции</h4>
<pre><code class="js">
function cumputeScore([low, mid]) {
	console.log(low, mid);
}
cumputeScore([3, 4]);
</code></pre>

<h4>Деструктивное присвание для возврата нескольких значений из функции</h4>
<pre><code class="js">
function getScores() {
	return [3, 4, 5];
}
var [low, mid, high] = getScores();
</code></pre>

<h3>Пример #1. Быстрый обмен значений переменнных</h3>
<pre><code class="js">
var yes = 'Yes';
var no = 'No';
[yes, no] = [no, yes];
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="destructive-obj">Деструтивное присваивание объектов (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="js">
var person = {
	firstname: 'Tony',
	lastname: 'Stark'
};
// ES5
var firstname = person.firstname;
var lastname = person.lastname;
</code></pre>

<h4>Деструтивное присваивание объектов</h4>
<pre><code class="js">
// имена переменных должны совпадать с именами свойст объекта
var {firstname, lastname} = person;
</code></pre>

<h4>Изменение имен переменных</h4>
<pre><code class="js">
var {firstname:first, lastname:last} = person;
</code></pre>

<h4>Значение по умолчанию</h4>
<pre><code class="js">
var {firstname, lastname, age=25} = person;
</code></pre>

<h4>Динамическое определение имен свойст с помощью выражения в []</h4>
<pre><code class="js">
var {['first'+'name']:first, lastname} = person;
</code></pre>

<h3>Извлечение свойств вложенных объектов</h3>
<pre><code class="js">
var user = {
	firstname: 'Tony',
	lastname: 'Stark',
	social: {
		facebook: 'tonystark',
		twitter: 't-stark'
	}
};
var {firstname, lastname, social:{facebook}} = user;
</code></pre>


<h3>Использование в качестве параметра функции</h3>
<pre><code class="js">
var user = {
	firstname: 'Tony',
	lastname: 'Stark'
};
function post(url, {data:{firstname, lastname}, cache}) {
	console.log(firstname, lastname, cache);
}
var result = post('api/users', {data:user, cache:false});
</code></pre>

<h3>Возврат нескольких значений из функции</h3>
<pre><code class="js">
function getUser() {
	return {
		firstname: 'Tony',
		lastname: 'Stark'
	};
}
var {firstname, lastname} = getUser();
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="symbol">Symbol (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list">
	<li><bg-list>Символ</bg-list> - уникальные и неизменные значения, позволябщие разработчикам языка добавлять новые идентификаторы или свойства объектов, не резервируя строковые названия для этих свойств</li>
	<li>Нельзя использовать ключевое слово <bg-list>new</bg-list></li>
</ul>

<pre><code class="js">
// создание символа
var symbol1 = Symbol();
</code></pre>

<pre><code class="js">
// создание символа
var symbol2 = Symbol.for('name');
</code></pre>

<pre><code class="js">
// получить имя символа
var name = Symbol.keyFor(symbol2);
</code></pre>

<pre><code class="js">
// задание необязательного аргумента, в котором указывается имя для символа
// имя можно использовать описания символа (полезно для отладки)
var symbol3 = Symbol('name');
</code></pre>

<pre><code class="js">
// задание свойства объекта
var user = {
	username: 'r2d2',
	[Symbol.for('password')]: 'c3po'
};
var password = user[Symbol.for('password')];
console.log(password);
// просмотреть символы у объекта
console.log(Object.getOwnPropertySymbols(user));
</code></pre>

<pre><code class="js">
// встроенные символы
// хорошо известные символы
var obj = {
	iterator: 0,
	[Symbol.iterator]() {}
}
// Symbol.iterator используется конструкцией for...of
// благодаря которой можно перебирать (итерировать) объект
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ecmascript">ECMAScript</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
ECMAScript является стандартом, а JavaScript — это самая популярная реализация этого стандарта
<pre>
<code class="js">
<b>ES1</b> (1997)
<b>ES2</b> (1998)
<b>ES3</b> (1999)
<b>ES4</b> (не была принята)
<b>ES5</b> (2009)
<b>ES6</b> (ES2015)
<b>ES7</b> (ES2016)
<b>ES8</b> (ES2017)
</code>
</pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="select">Выборка элементов страницы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var a = document.getElementById('item');               // по id
var a = document.getElementsByClassName('item')[0];    // по названию класса (первый элемент)
var a = document.getElementsByName('item');            // по атрибуту name
var a = document.getElementsByTagName('img');          // по названию тега (все элементы)
var a = document.querySelector('.nav.bar');            // возвращает первый элемент внутри документа
var a = document.querySelectorAll('.nav');             // возвращает список элементов в пределах документа
</code></pre>

<p>Методы getElementsByTagName и т.д. вызывают не обычные массивы, а живые коллекции</p>

<h4>Форма</h4>
<pre><code class="js">
var a = document.forms[0];                             // первая форма на странице
var a = document.myform;                               // форма с name=myform (если name уникальный)
var a = document.forms[0].elements[0];                 // первый элемент в форме
var a = document.forms[0].element;                     // элемент в форме с name=element
var a = document.forms['nameForm']['nameField'];       // поле формы
</code></pre>

<h4>Изображение</h4>
<pre><code class="js">
var a = document.images.logo;                          // img с name=logo
var a = document.images['logo'];                       // img с name=logo
var a = document.logo;                                 // img с name=logo (если name уникальный)
</code></pre>

<h3>Выбор родственных элементов</h3>
<pre><code class="js">
var a = element.childNodes;                            // дети (включая текстовые узлы)
var a = element.children;                              // дети (не включая текстовые узлы)
var a = element.parentNode;                            // родитель 
var a = element.nextSibling;                           // следующий брат
var a = element.previousSibling;                       // предыдущий брат
var a = element.firstChild;                            // первый ребенок
var a = element.lastChild;                             // последний ребенок
</code></pre>

<pre><code class="js">
var a = document.childNodes;                           // дети с doctype и комментариями
var a = document.children;                             // дети
var a = document.children[0].children[1].children;     // выборка всех элементов из body
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="methods">Методы элементов страницы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
element.innerText   = 'new text';           // текст (не выводит невидимые элементы)
element.textContent = 'new text';         // текст
element.innerHTML   = '&lt;h2&gt;new text&lt;/h2&gt;';  // html
</code></pre>

<pre><code class="js">
element.id          = 'name';
element.className   = 'nameClass1 nameClass2';
</code></pre>

<pre><code class="js">
element.href        = 'https://www.google.com/';
element.src         = 'image.jpg';
element.offsetTop;  // отступ от верха документа
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="pattern">Шаблонные строки (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var a = `
	первая строка
	вторая строка
`;
</code></pre>

<h3>Интерполяция</h3>
<pre><code class="js">
var a = 'text'; 
var b = `строка текста ${a} строка текста`;
</code></pre>

<h3>Тегирование</h3>
Изменение вида шаблонов при помощи функций

<pre><code class="js">
var name = 'Tony';
console.log(upperName`Hello ${name}`);

// literals - массив строковых литералов
// name - значение вычисленных выражений
function upperName(literals, value) {
	return literals[0] + value.toUpperCase();
}
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="dictionary">Словарь</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list">
	<li><bg-list>Statements (инструкции)</bg-list> - var statement</li>
	<li><bg-list>Expressions (выражения)</bg-list> - stetement = 2+7</li>
	<li><bg-list>Operators (операторы)</bg-list> - арифметические, сравнения, условные, логические, побитовые</li>
	<li><bg-list>Литерал</bg-list> - любое значение указанное явным образом в коде. В качестве литералов в js могут выступать числа, строки (текстовые значения), логические значения</li>
	<li><bg-list>let, const</bg-list> - блочная область видимости</li>
	<li><bg-list>var</bg-list> - функциональная область видимости</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="type">Типы данных</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="html">
1. <em>Number</em>    - число (примитивный) 
2. <em>String</em>    - cтрока (примитивный)
3. <em>Boolean</em>   - булевый, логический (примитивный)
4. <em>null</em>      - специальное пустое или неизвестное значение (присваивается самостоятельно)
5. <em>undefined</em> - специальное неприсвоеное значение (возвращается из js)
6. <em>Object</em>    - объект 
7. <em>Symbol</em>    - символ (примитивный) ES6
</code></pre>

<p>Специальные числовые значения <bg-list>Infinity</bg-list> и <bg-list>NaN</bg-list></p>

<!------------------------------------------------------>
<h3>typeof - возвращает тип аргумента</h3>
<!------------------------------------------------------>
<pre><code class="js">
typeof undefined    // "undefined"
typeof 0            // "number"
typeof true         // "boolean"
typeof 'foo'        // "string"
typeof {}           // "object"
typeof null         // "object" (*)
typeof function(){} // "function" (*)
</code></pre>

<pre><code class="js">
// проверка поддержки свойств
typeof addEventListener !== 'undefined'
</code></pre>

<!------------------------------------------------------>
<h3>Преобразование типов</h3>
<!------------------------------------------------------>
<pre><code class="js">
String(77);
Number('77');
Boolean(77);
</code></pre>

<pre><code class="js">
77 + ''; // string
+'77';   // number
!!'77';  // boolean
</code></pre>

<pre><code class="js">
77.toString();
parseInt('77px');
parseFloat('77.2px')
</code></pre>

<!------------------------------------------------------>
<h3>Способы создания переменных</h3>
<!------------------------------------------------------>
<h4>1. Литеральная форма</h4>
<pre><code class="js">
var a = 'string';
</code></pre>

<h4>2. Конструктор</h4>
<pre><code class="js">
var a = new String('string');
var a = new Number(77);
var a = new Boolean(true);
</code></pre>

<!------------------------------------------------------>
<h3>Object Wrappers</h3>
<!------------------------------------------------------>
<pre><code class="js">
typeof 'string';             // "string"
typeof new String('string'); // "object"
</code></pre>

<ul class="list-point">
	<li>Объект-обертка вокруг примитивного типа данных создается вызовом конструктора new</li>
	<li>Или при использовании методов для строк и чисел</li>
	<li>Иначе это является примитивным типом данных (string, number, boolean)</li>
</ul>

<pre><code class="js">
// позволяет достать строку из объекта
var str = new String('string');
console.log(str.valueOf()); 
</code></pre>

<ul class="list-point">
	<li>Глобальная переменная относится к глобальному объект window</li>
	<li>Переменная без var попадает в глобальную область видимости</li>
	<li>Переменная совершают поднятие hoisting, но значение будет undefined</li>
</ul>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="case">Условные операторы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Условный оператор case()</h3>
<!------------------------------------------------------>
Использование цифр в виде аргумента
<pre><code class="js">
switch(Number(id)) {
	case 1: alert(id); break;
	case 2: alert(id); break;
	case 3: alert(id); break;
	default: alert("default");
}
</code></pre>

Использование строк в виде аргумента
<pre><code class="js">
switch(name) {
	case 'name1': alert(name); break;
	case 'name2': alert(name); break;
	case 'name3': alert(name); break;
	default: alert("default");
}
</code></pre>

<!------------------------------------------------------>
<h3>Условный оператор if()</h3>
<!------------------------------------------------------>
<pre><code class="js">
if (year < 2011) {
	alert('Это слишком рано..');
} else if (year > 2011) {
	alert('Это поздновато..');
} else {
	alert('Да, точно в этом году!');
}
</code></pre>

<!------------------------------------------------------>
<h3>Тернарный оператор</h3>
<!------------------------------------------------------>

<ul class="list-point">
	<li>условие ? значение1 : значение2</li>
	<li>если условие верно – возвращается значение1, если неверно – значение2</li>
</ul>

<div class="container-flex"><div class="container-half"><pre><code class="js">
// if … else
if (age > 14) {
	access = true;
} else {
	access = false;
}
</code></pre></div><div class="container-half"><pre><code class="js">
// Тернарный оператор
access = (age > 14) ? true : false;
<br><br><br>
</code></pre></div></div>

<div class="container-flex"><div class="container-half"><pre><code class="js">
// if … else
if(apple == orange) {
   res = "Равно"; 
} else {
   res = "Не равно"; 
}
</code></pre></div><div class="container-half"><pre><code class="js">
// Тернарный оператор
res = (apple == orange) ? "Равно" : "Не равно";
<br><br>
</code></pre></div></div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="cycle-array">Перебор массива</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list">
	<li><bg-list>forEach</bg-list> - для перебора массива</li>
	<li><bg-list>filter</bg-list> - для фильтрации массива</li>
	<li><bg-list>map</bg-list> - для трансформации массива в массив</li>
	<li><bg-list>every/some</bg-list> - для проверки массива</li>
	<li><bg-list>reduce/reduceRight</bg-list> - для прохода по массиву с вычислением значения</li>
</ul>

<!------------------------------------------------------>
<h3>forEach</h3>
<!------------------------------------------------------>
<ul>
	<li>Ничего не возвращает, используется только для перебора</li>
</ul>
<pre><code class="js">
var arr = ["Яблоко", "Апельсин", "Груша"];
arr.forEach(function(element, index, arr) {
	console.log( index + ": " + element + " (массив:" + arr + ")" );
});
// "0: Яблоко   (массив:Яблоко,Апельсин,Груша)"
// "1: Апельсин (массив:Яблоко,Апельсин,Груша)"
// "2: Груша    (массив:Яблоко,Апельсин,Груша)"
</code></pre>

<!------------------------------------------------------>
<h3>filter</h3>
<!------------------------------------------------------>
<ul>
	<li>Используется для фильтрации массива через функцию</li>
	<li>Создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true</li>
</ul>

<pre><code class="js">
var arr = [1, -1, 2, -2, 3];
var positiveArr = arr.filter(function(number) {
	return number > 0;
});
alert(positiveArr); // 1,2,3
</code></pre>

<!------------------------------------------------------>
<h3>map</h3>
<!------------------------------------------------------>
<pre><code class="js">
<a href="#map">Ссылка</a>
</code></pre>

<!------------------------------------------------------>
<h3>every/some</h3>
<!------------------------------------------------------>
<ul>
	<li>Используется для проверки массива</li>
	<li>Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr</li>
	<li>Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr</li>
</ul>

<pre><code class="js">
var arr = [1, -1, 2, -2, 3];
function isPositive(number) {
  return number > 0;
}
alert( arr.every(isPositive) ); // false, не все положительные
alert( arr.some(isPositive) );  // true, есть хоть одно положительное
</code></pre>

<!------------------------------------------------------>
<h3>reduce/reduceRight</h3>
<!------------------------------------------------------>
<ul>
	<li>Используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата</li>
	<li><b>arr.reduce</b> идёт по массиву слева-направо</li>
	<li><b>arr.reduceRight</b> идёт по массиву справа-налево</li>
</ul>

<pre><code class="js">
<em>arr.reduce(callback[, initialValue])</em>
</code></pre>

<ul class="list-point">
	<b>callback(previousValue, currentItem, index, arr)</b>
	<li><bg-list>previousValue</bg-list> - последний результат вызова функции, «промежуточный результат»</li>
	<li><bg-list>currentItem</bg-list> - текущий элемент массива, элементы перебираются по очереди слева-направо</li>
	<li><bg-list>index</bg-list> - номер текущего элемента</li>
	<li><bg-list>arr</bg-list> - обрабатываемый массив</li>
</ul>

<ul class="list-point">
	<b>initialValue - начальное значение</b>
	<li>Если есть <bg-list>initialValue</bg-list>, то на первом вызове значение <bg-list>previousValue</bg-list> будет равно <bg-list>initialValue</bg-list></li>
	<li>Если нет <bg-list>initialValue</bg-list>, то оно равно первому элементу массива, а перебор начинается со второго</li>
</ul>

<pre><code class="js">
// сумма элементов массива
var arr = [1, 2, 3, 4, 5]

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current
});

alert(result); // 15
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="cycle">Циклы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Цикл for</h3>
<!------------------------------------------------------>
<pre><code class="js">
for (var i = 1; i < 10; i++) {  
    console.log(i); 
}
</code></pre>

<h3>Цикл while</h3>
<pre><code class="js">
var i = 0;  
while (i < 10) {  
    console.log(i); 
    i++;  
}
</code></pre>

<!------------------------------------------------------>
<h3>Цикл do while</h3>
<!------------------------------------------------------>
<pre><code class="js">
var i = 0;  
do {  
    console.log(i); 
    i++;  
} while (i < 10);
</code></pre>

<pre><code class="js">
break    // выход из цикла
continue // прекращает выполнение текущей итерации цикла и переходит на следующую
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="array">Массивы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>Массив - это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length</li>
	<li>Так как это объект, то в функцию он передаётся по ссылке</li>
	<li>Нет причин использовать массив как обычный объект, хотя технически это и возможно</li>
</ul>

<!------------------------------------------------------>
<h3>Объявление</h3>
<!------------------------------------------------------>
<pre><code class="js">
var arr = [];                        // объявление пустого массива
var arr = ['Tony', 'Anne'];          // объявление массива из заполненных элементов
var arr = [,,'Tony'];                // пропуск элементов
var arr = new Array(5);              // объявление массива из пустых элементов с длиной 5 (конструктор)
var arr = new Array('Tony', 'Anne'); // объявление массива (конструктор)
</code></pre>

<!------------------------------------------------------>
<h3>Методы</h3>
<!------------------------------------------------------>
<bg-list>push</bg-list> <bg-list>pop</bg-list> <bg-list>unshift</bg-list> <bg-list>shift</bg-list>
<pre><code class="js">
arr.<bg-code>push</bg-code>('Jack', 'Tony');            // добавляет элементы в конец
arr.<bg-code>unshift</bg-code>('Jack', 'Tony');         // добавляет элементы в начало
arr.<bg-code>pop</bg-code>();                           // удаляет и возвращает последний элемент
arr.<bg-code>shift</bg-code>();                         // удаляет и возвращает первый элемент
</code></pre>

<bg-list>indexOf</bg-list> <bg-list>lastIndexOf</bg-list>
<pre><code class="js">
var a = colors.<bg-code>indexOf</bg-code>('white');     // возвращает первый индекс, по которому элемент может быть найден в массиве или -1, если индекса нет
var a = colors.<bg-code>lastIndexOf</bg-code>('white'); // возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет
</code></pre>

<bg-list>join</bg-list> <bg-list>split</bg-list>
<pre><code class="js">
var a = arr.<bg-code>join</bg-code>('.');               // преобразование массива в строку с заданным разделителем
var arr = str.<bg-code>split</bg-code>(';');            // преобразование строки с заданным разделителем в массив 
</code></pre>

<bg-list>slice</bg-list>
<pre><code class="js">
var arr2 = arr1.<bg-code>slice</bg-code>(1, 7);         // копировать с 1 до 7 не включая, если не указан второй аргумент, то до конца
var arr2 = arr1.<bg-code>slice</bg-code>(1);            // копировать с 1 до конца
var arr2 = arr.<bg-code>slice</bg-code>(-2);            // копировать c 2 элемента с конца и дальше
var arr2 = arr.<bg-code>slice</bg-code>();              // копировать весь массив
</code></pre>

<bg-list>splice</bg-list>
<pre><code class="js">                
arr.<bg-code>splice</bg-code>(3, 2);                     // удалить с 3 индекса 2 элемента
arr.<bg-code>splice</bg-code>(2, 0, 'Алина', 'Марина');  // добавление элементов
arr.<bg-code>splice</bg-code>(1, 2, 'Алексей", "Билл');  // замена элементов (заменить 2 удаленных элемента на Алексей, Билл)
arr.<bg-code>splice</bg-code>(-1, 1);                    // удалить с последнего индекса-1 1 элемент (отрицательная позиция отсчитывается с конца)
</code></pre>

<bg-list>length</bg-list> <bg-list>reverse</bg-list> <bg-list>concat</bg-list>
<pre><code class="js">
var a = arr.<bg-code>length</bg-code>;                  // длина массива (индекс последнего элемента)
arr.<bg-code>reverse</bg-code>();                       // меняет порядок элементов в массиве на обратный
var arr = arr1.<bg-code>concat</bg-code>(arr2, arr3);   // создаёт новый массив, в который копируются элементы из массивов
</code></pre>

<bg-list>sort</bg-list>
<pre><code class="js">
arr.<bg-code>sort</bg-code>();                          // сортировка по алфавиту, преобразуя элементы к строке
</code></pre>

<pre><code class="js">
// свой порядок сортировки (сортировка чисел)
var arr = [1, 12, 2];
arr.sort(function(a, b) {
  if (a > b) return 1;
  if (a < b) return -1;	
});
console.log(arr);  // 1, 2, 15
</code></pre>

<h3>Примеры</h3>
<pre><code class="js">
arr['someIndex'] = 'someValue';       // использование строки в виде индекса
arr.length = 10;                      // все элементы больше 10 индекса будут удалены
delete arr[4];                        // присваивание элементу по индексу 4 undefined
var a = Array.isArray(arr);           // проверка на массив
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="array_obj">Массивы обьектов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var a = new Array(
	{"name":"Андрей", "email":"andry@mail.ru"},
	{"name":"Анна",   "email":"anna@mail.ru"}
);

console.log(a[0].name);  // "Андрей"
console.log(a[1].email); // "anna@mail.ru"
</code></pre>

<h3>Примеры</h3>
<pre><code class="js">
// перебор массива
for (var i=0; i<=arr.length-1; i++) {
	console.log(arr[i]);
}
</code></pre>

<pre><code class="js">
// перебор массива и удаление выбранного элемента
var id = 12;
for (var i=0; i<=arr.length-1; i++) {
	if (id == arr[i]) {
		arr.splice(i, 1); 
		break;
	} 
}
</code></pre>

<pre><code class="js">
// добавление нового элемента в массив
if (arr != '') {
	arr[arr.length] = id;
} else {
	arr[0] = id;
}
</code></pre>

<pre><code class="js">
// удаление элемента массива
arr.splice(arr.indexOf(String(id)), 1);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="str">Строки</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Строки в JavaScript имеют внутреннюю кодировку Юникод</li>
</ul>
<pre><code class="js">
var a = str.<bg-code>length</bg-code>;       // длина строки 
77.<bg-code>toString()</bg-code>;            // преобразование в строку
var arr = str.<bg-code>split</bg-code>(';'); // преобразование строки с заданным разделителем в массив
var str = str.<bg-code>trim</bg-code>();     // обрезает пробелы с начала и конца строки
</code></pre>

<pre><code class="js">
var name = name.<bg-code>toUpperCase</bg-code>(); // верхний регистр
var name = name.<bg-code>toLowerCase</bg-code>(); // нижний регистр
</code></pre>

<h4>Поиск в строке совпадений с образцом</h4>
<pre><code class="js">
var pos = str.<bg-code>indexOf</bg-code>('name');     // с начала (-1 не найдено)
var pos = str.indexOf('name', 2);  // поиск начат с позиции 2
var pos = str.<bg-code>lastIndexOf</bg-code>('name'); // с конца (-1 не найдено)
</code></pre>

<h4>Взятие подстроки: substring, substr, slice</h4>

<bg-list>slice</bg-list>
<ul class="list-point">
	<li>Отрицательные значения отсчитываются от конца строки</li>
</ul>
<pre><code class="js">
var root = str.<bg-code>slice</bg-code>(1, 7);        // вырезать с 1 позиции до 7 позиции не включая
var root = 'testme'.slice(-2);     // 'me', от 2 позиции с конца
var root = 'testme'.slice(1, -1);  // "estm", от 1 позиции до первой с конца 
</code></pre>

<bg-list>substring</bg-list>
<ul class="list-point">
	<li>Отрицательные аргументы интерпретируются как равные нулю</li>
	<li>Слишком большие значения усекаются до длины строки</li>
	<li>Если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end</li>
</ul>
<pre><code class="js">
var root = str.<bg-code>substring</bg-code>(1, 7);       // вырезать с 1 позиции до 7 позиции не включая
var root = str.substring(1);          // вырезать с 1 позиции до конца строки
var root = 'testme'.substring(-2);    // 'testme', -2 становится 0
var root = 'testme'.substring(4, -1); // 'test', -1 становится 0 -> получили substring(4, 0), 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
</code></pre>

<bg-list>substr</bg-list>
<pre><code class="js">
var root = str.<bg-code>substr</bg-code>(1, 4);   // вырезать с 1 позиции 4 символа
var root = str.substr(1);      // вырезать с 1 позиции до конца строки
</code></pre>

<h4>charAt, charCodeAt</h4>
<pre><code class="js">
var root = <bg-code>charAt</bg-code>(2);     // возвращает символ строки по индексу 
var root = <bg-code>charCodeAt</bg-code>(2); // возвращает код символа строки по индексу (все русские буквы находятся в диапазоне от 1040 до 1103)
</code></pre>

<pre><code class="js">
alert( "".charAt(0) ); // пустая строка
alert( "" [0] );       // undefined
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>

<h4>Перебор строки</h4>
<pre><code class="js">
for (var i=0; i <= str.length-1; i++) {
	console.log(str[i]);
}
</code></pre>

<h4>Длина числа</h4>
<pre><code class="js">
var id = 100;
var a = id.toString().length;
</code></pre>

<h4>Сложение</h4>
<pre><code class="js">
"Blink" + 181 + 1;   // "Blink1811"
"Blink" + (181 + 1); // "Blink182"
</code></pre>

<h4>Экраснирвание кавычек</h4>
<pre><code class="js">
'\n'                     // перенос строки
alert('привет \n мир');  // вывод переноса строки
"call me \"ziggy\" now"; // экранирование кавычек
</code></pre>

<h4>Проверка на заполненное поле</h4>
<pre><code class="js">
var login = '';
var password = '';
isFormValid() {
	return login.length > 0 && password.length > 0;
}
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="number">Числа</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
num.toFixed(2);             // фиксирование кол-ва знаков после запятой
123456789.toLocaleString(); // вывод чисел в стандарте ECMA (result = 402 123 456 789)
</code></pre>

<pre><code class="js">
Number(num);     // преобразование любого объекта в число
parseInt(num);   // преобразование в целое число
parseFloat(num); // преобразование в целое/дробное число ('50.5px', вернет значение "50.5"
+'50.5';         // преобразование в целое/дробное число
</code></pre>

<h4>isNaN</h4>
<ul>
	<li>isNaN преобразует к числу пустую строку, строку из пробельных символов, значения false, true, null</li>
</ul>
<pre><code class="js">
isNaN(num); // если в переменной не число, вернет истину
</code></pre>

<h4>isFinite</h4>
<ul class="list-point">
	<li>isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity</li>
</ul>
<pre><code class="js">
alert( isFinite(1) );        // true
alert( isFinite(Infinity) ); // false
alert( isFinite(NaN) );      // false
</code></pre>

<h4>Infinity</h4>
<ul class="list-point">
	<li>Infinity больше любого числа</li>
	<li>Добавление к бесконечности не меняет её</li>
</ul>
<pre><code class="js">
alert( 1 / 0 );     // Infinity
alert( 12345 / 0 ); // Infinity
alert( -1 / 0 );    // -Infinity
var x = Infinity;   // Infinity можно присвоить и в явном виде
</code></pre>

<h4>NaN</h4>
<ul class="list-point">
	<li>NaN (Not-A-Number)</li>
	<li>Значение NaN используется для обозначения математической ошибки</li>
	<li>Значение NaN – единственное в своем роде, которое не равно ничему, включая себя</li>
</ul>
<pre><code class="js">
alert( 0 / 0 );   // NaN
alert( NaN + 1 ); // NaN
</code></pre>

<h4>Перебор в двоичную систему отсчета</h4>
<pre><code class="js">
parseInt("11000", 2);              // переводит строку с двоичной записью числа в число
n.toString(2);                     // получает для числа n запись в 2-ной системе в виде строки

var access = parseInt("11000", 2); // получаем число из строки
alert(access);                     // 24, число с таким 2-ным представлением

var access2 = access.toString(2); // обратно двоичную строку из числа
alert(access2);                   // 11000
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="operators">Операторы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h4>Остаток от деления</h4>
<pre><code class="js">
alert(5 % 2); // 1, остаток от деления 5 на 2
alert(8 % 3); // 2, остаток от деления 8 на 3
alert(6 % 3); // 0, остаток от деления 6 на 3
</code></pre>

<h4>Инкремент/декремент</h4>
<ul class="list-point">
	<li><bg-list>i++</bg-list> постфиксная форм</li>
	<li><bg-list>++i</bg-list> префиксная форма</li>
</ul>

<pre><code class="js">
var i = 1;
var a = ++i;
alert(a); // 2
</code></pre>

<pre><code class="js">
var i = 1;
var a = i++;
alert(a); // 1
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="math">Math</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
Math.round(num); // округляет число к ближайшему целому (5 округляется вверх)
Math.ceil(num);  // округляет число в большую сторону
Math.floor(num); // округляет число в меньшую сторону
</code></pre>

<pre><code class="js">
var rand = Math.random(); // генерация случайного числа от 0 (включительно) до 1 (не включая)
var rand = Math.round(Math.random() * 100); // от 0 до 100
</code></pre>

<pre><code class="js">
var a = Math.pow(4,2);        // степень 4 в 2
var a = Math.sqrt(400);       // квадратный корень числа
var a = Math.abs(-7);         // модуль
var a = Math.max(1, 2, 3, 4); // большее число из аргументов
var a = Math.min(1, 2, 3, 4); // меньшее число из аргументов
var a = Math.exp(2);          // возведение часла "e" в указанную степень
var a = Math.log(5);          // натуральный логарифм числа
</code></pre>

<pre><code class="js">
var a = Math.PI;              // число PI
var a = Math.E;               // чисто E
</code></pre>

<pre><code class="js">
var a = Math.sin(1);          // синус (радиан)
var a = Math.cos(1);          // косинус
var a = Math.tan(1);          // тангенс
var a = Math.atan(1);         // арктангенс
var a = Math.asin(1);         // арксинус
var a = Math.acos(1);         // арккосинус
</code></pre>

<h4>Пример Random(min, max)</h4>
<pre><code class="js">
function mtRand(min, max) {
	return Math.floor(Math.random() * (max - min + 1));
	//return Math.random() * (max - min) + min;
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="date">Дата и время</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="html">
<a href="http://momentjs.com/" target="_blank">Moment.js</a>
</code></pre>

<!------------------------------------------------------>
<h3>Создание</h3>
<!------------------------------------------------------>
<pre><code class="js">
new <bg-code>Date</bg-code>(year, month, date, hours, minutes, seconds, ms)
</code></pre>

<pre><code class="js">
var selectDate = new Date(2012,0,1,0,0,0); // объявление для заданной даты
var nowDate = new Date();                  // текущее дата и время на компьютере пользователя
</code></pre>

<!------------------------------------------------------>
<h3>Установка значений</h3>
<!------------------------------------------------------>
<pre><code class="js">
var selectDate = new Date(2012,0,1,0,0,0);
</code></pre>
<pre><code class="js">
selectDate.<bg-code>setMinutes</bg-code>(25);                 // установка минут
setSeconds.<bg-code>setSeconds</bg-code>(25);                 // установка секунд
...
</code></pre>

<!------------------------------------------------------>
<h3>Получение значений</h3>
<!------------------------------------------------------>
<pre><code class="js">
var nowDate = new Date();
</code></pre>
<pre><code class="js">
var yearFull = nowDate.<bg-code>getFullYear()</bg-code>;      // год (4 цифры)
var month    = nowDate.<bg-code>getMonth()</bg-code>;         // месяц (от 0 до 1)
var day      = nowDate.<bg-code>getDate()</bg-code>;          // число месяца (от 1 до 31)
var dayWeek  = nowDate.<bg-code>getDay()</bg-code>;           // день недели (от 0-воскресенье до 6-суббота)
var hour     = nowDate.<bg-code>getHours()</bg-code>;         // час
var minutes  = nowDate.<bg-code>getMinutes()</bg-code>;       // минуты
var seconds  = nowDate.<bg-code>getSeconds()</bg-code>;       // секунды
var mseconds = nowDate.<bg-code>getMilliseconds()</bg-code>;  // миллисекунды
</code></pre>

<!------------------------------------------------------>
<h3>Date.parse</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<b>Формат представления даты</b> <bg-code>YYYY-MM-DDTHH:mm:ss.sss</bg-code>
	<li><bg-code>YYYY-MM-DD</bg-code> - дата в формате год-месяц-день</li>
	<li>Обычный символ <bg-code>T</bg-code> используется как разделитель</li>
	<li><bg-code>HH:mm:ss.sss</bg-code> – время: часы-минуты-секунды-миллисекунды</li>
	<li>Часть <bg-code>'Z'</bg-code> обозначает временную зону – в формате <bg-code>+-hh:mm</bg-code>, либо символ <bg-code>Z</bg-code>, обозначающий UTC</li>
</ul>

<ul class="list-point">
	<b>Date.parse(str)</b>
	<li>Метод <bg-code>Date.parse(str)</bg-code> разбирает строку str в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, <bg-code>Date.parse</bg-code> возвращает NaN</li>
</ul>

<pre><code class="js">
var msUTC = Date.parse('2012-01-26T13:51:50.417Z'); // зона UTC
alert( msUTC ); // 1327571510417 (число миллисекунд)

var ms = Date.parse('2012-01-26T13:51:50.417-07:00'); // С таймзоной -07:00 GMT
alert( ms ); // 1327611110417 (число миллисекунд)
</code></pre>

<!------------------------------------------------------>
<h3>toLocaleString</h3>
<!------------------------------------------------------>
<pre><code class="js">
var date = new Date(2014, 11, 31, 12, 30, 0);

var options = {
	era: 'long',
	year: 'numeric',
	month: 'long',
	day: 'numeric',
	weekday: 'long',
	timezone: 'UTC',
	hour: 'numeric',
	minute: 'numeric',
	second: 'numeric'
};

alert( date.<bg-code>toLocaleString</bg-code>("ru", options) );    // среда, 31 декабря 2014 г. н.э. 12:30:00
alert( date.<bg-code>toLocaleString</bg-code>("en-US", options) ); // Wednesday, December 31, 2014 Anno Domini 12:30:00 PM
</code></pre>

<pre><code class="js">
var a = nowDate.<bg-code>toLocaleTimeString()</bg-code>; // время с учетом локализации
var a = nowDate.<bg-code>toLocaleDateString()</bg-code>; // дата с учетом локализации
</code></pre>

<pre><code class="js">
// вывод зависит от браузера
var d = new Date();
var a = d.<bg-code>toString()</bg-code>;     // возвращает дату целиком 'Wed Jan 26 2011 16:40:50 GMT+0300'
var a = d.<bg-code>toDateString()</bg-code>; // возвращает только дату
var a = d.<bg-code>toTimeString()</bg-code>; // возвращает только время
</code></pre>


<!------------------------------------------------------>
<h3>GMT и UTC</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Все методы, указанные выше, возвращают результат для местной временной зоны</li>
	<li>Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay() и т.д.</li>
</ul>
<pre><code class="js">
var a = nowDate.getHours();          // время по гринвичу (GMT)
var a = nowDate.<bg-code>getUTCHours()</bg-code>;       // время в формате UTC
var a = nowDate.<bg-code>getTimezoneOffset()</bg-code>; // возвращает разницу между местным и UTC-временем, в минутах.
</code></pre>

<!------------------------------------------------------>
<h3>Другие методы</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = nowDate.<bg-code>toTimeString()</bg-code>; // вывод времени в виде строки
var a = nowDate.<bg-code>toDateString()</bg-code>; // вывод даты в виде строки
</code></pre>

<pre><code class="js">
var selectDate = new Date(2012,0,1,0,0,0);
var a = selectDate.<bg-code>getTime()</bg-code>;  // возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0
</code></pre>

<pre><code class="js">
var timeInMs = <bg-code>Date.now</bg-code>();     // возвращает количество миллисекунд, прошедших с 1 января 1970 года 00:00:00 по UTC.
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>
<h4>Вывод текщей даты</h4>
<pre><code class="js">
var weekday = ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'];
var month = ['Января', 'Февраля', 'Марта', 'Апреля', 'Мая', 'Июня', 'Июля', 'Августа', 'Сентября', 'Октября', 'Ноября', 'Декабря'];
var nowDate = new Date();
var nowDay   = weekday[nowDate.getDay()];
var nowDate  = nowDate.getDate();
var nowMonth = month[nowDate.getMonth()];
</code></pre>

<h4>Разность дат</h4>
<pre><code class="js">
var start = new Date; // засекли время

// что-то сделать
for (var i = 0; i < 100000; i++) {
  var doSomething = i * i * i;
}

var end = new Date; // конец измерения
console.log( "Цикл занял " + (end - start) + " ms" );
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="catch">Исключения</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h3>Создание исключений</h3>
<pre><code class="js">
var calculate = function(n) {
	if (n>10) {
		throw new Error('n должно быть больше 10');
	}
	return n;
}
calculate(20);
</code></pre>

<h3>Обработка исключений</h3>
<pre><code class="js">
try {
	// инструкции, которые могут бросить исключение
} catch (идентификатор) {
	// инструкции будут выполняться если в try произошло исключение
	// передается выражение (идентификатор), которое было в throw
} finally {
	// инструкции будут выполняться независимо от исключения
}
// catch или finally может отсутствовать
// если ошибка необработана, скрипт не будет выполняться
// если ошибка обработана в catch, скрипт продолжит выполнение
</code></pre>

<pre><code class="js">
var calculate = function(n) {
	if (n>10) {
		throw new Error('n должно быть больше 10');
	}
	return n;
}
try {
	calculate(20);
} catch(e) {
	console.log('Ошибка функции calculate() ' + e.message);
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="timeout">Таймеры</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>setTimeout</h3>
<!------------------------------------------------------>
<ul class="list">
	<b>setTimeout(code, time);</b> - однократное выполнение кода через некоторое время
	<li><bg-list>code</bg-list> - код или функция</li>
	<li><bg-list>time</bg-list> - время в миллисекундах, которое должно пройти до выполнения кода (1000 миллисекунд = 1 секунда)</li>
</ul>

<pre><code class="js">
var timer = setTimeout("console.log('go');", 1000);
var timer = setTimeout(function() { console.log('go'); }, 1000);
var timer = setTimeout(func, 1000);

function func () {
    console.log('go');
}

clearTimeout(timer); // отменяет выполнение setTimeout
</code></pre>

<!------------------------------------------------------>
<h3>setInterval</h3>
<!------------------------------------------------------>
<pre><code class="js">
setInterval();   // повторение выполнения кода через определенное время
clearInterval(); // отменяет выполнение setInterval()

var timer = setInterval("console.log('go');", 1000);
clearInterval(timer); // остановка setInterval
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="prevent">Отмена обычного поведения элемента</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
preventDefault(); // отмена обычного поведения элемента
return false - аналогично preventDefault(), но дальнейший код не выполняется
</code></pre>

<pre><code class="js">
element.onclick = function(event) {
	event.preventDefault();
	// return false ;
};
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="console">Console</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
console.log('Сообщение');
console.info('Информация');
console.warn('Предупреждение');
console.error('Ошибка');
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="jsdoc">Синтаксис JSDoc</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
/**
* Возвращает x в степени n, только для натуральных n
*
* @param {number} x Число для возведения в степень.
* @param {number} n Показатель степени, натуральное число.
* @return {number} x в степени n.
*/
function pow(x, n) {
	...
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="external-script">Асинхронные скрипты: defer/async</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>Если браузер видит тег <bg-list>script</bg-list>, то он обязан сначала выполнить его, а потом показать оставшуюся часть страницы</li>
	<li>Специальные атрибуты <bg-list>async</bg-list> и <bg-list>defer</bg-list> используются для того, чтобы пока грузится внешний скрипт - браузер показал остальную (следующую за ним) часть страницы</li>
	<li>При одновременном указании async и defer в современных браузерах будет использован только async</li>
	<li>Атрибуты async/defer работают только в том случае, если назначены на внешние скрипты, т.е. имеющие src</li>
	
</ul>

<!------------------------------------------------------>
<h3>Атрибут async</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Не сохраняет относительную последовательность скриптов</li>
	<li>Не ждет пока весь HTML-документ будет обработан браузером</li>
	<li>Браузер не останавливает обработку страницы, а работает дальше. Когда скрипт будет загружен – он выполнится</li>
</ul>
<pre><code class="js">
// первым сработает тот скрипт, который раньше загрузится
&lt;script src="1.js" async&gt;&lt;/script&gt;
&lt;script src="2.js" async&gt;&lt;/script&gt;
</code></pre>

<!------------------------------------------------------>
<h3>Атрибут defer</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Сохраняет относительную последовательность скриптов</li>
	<li>Ждет пока весь HTML-документ будет обработан браузером</li>
</ul>

<pre><code class="js">
// первым сработает всегда 1.js, а скрипт 2.js, даже если загрузился раньше, будет его ждать
&lt;script src="1.js" defer&gt;&lt;/script&gt;
&lt;script src="2.js" defer&gt;&lt;/script&gt;
</code></pre>

<pre><code class="js">
// скрипт async.js выполнится, как только загрузится – возможно, до того, как весь документ готов
// defer.js подождёт готовности всего документа
&lt;script src="async.js" async&gt;&lt;/script&gt;
&lt;script src="defer.js" defer&gt;&lt;/script&gt;
text text text
</code></pre>

<h3>Добавление скриптов через JS</h3>
<ul class="list-point">
	<li>Скрипты, добавленные через JS ведут себя как async</li>
</ul>

<pre><code class="js">
function addScript(src){
	var script = document.createElement('script');
	script.src = src;
	script.async = false; // чтобы гарантировать порядок
	document.head.appendChild(script);
}

addScript('1.js'); // загружаться эти скрипты начнут сразу
addScript('2.js'); // выполнятся, как только загрузятся
addScript('3.js'); // но, гарантированно, в порядке 1 -> 2 -> 3
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="comparison">Сравнение и логические значения</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<h3>Сравнение строк</h3>
<ul class="list-point">
	<li>Cравниваются численные коды символов Unicode</li>
</ul>
<pre><code class="js">
alert('Б' > 'А');        // true
alert('а' > 'Я');        // true, строчные буквы больше прописных
alert('Банан' > 'Анна'); // true, если первая буква первой строки больше – значит первая строка больше, независимо от остальных символов
alert('Привет' > 'Прив'); // true, любая буква больше отсутствия буквы
</code></pre>

<h3>Сравнение разных типов</h3>
<ul class="list-point">
	<li>При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям</li>
</ul>
<pre><code class="js">
alert('2' > 1);    // true, сравнивается как 2 > 1
alert( '01' == 1); // true, сравнивается как 1 == 1
alert(false == 0); // true, false становится числом 0
alert(true == 1);  // true, так как true становится числом 1.
</code></pre>

<h3>Сравнение с null и undefined</h3>
<ul class="list-point">
	<li>Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё</li>
	<li>При преобразовании в число null становится 0, а undefined становится NaN</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="attribute">Атрибуты</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var a1 = element.attributes;         // массив атрибутов
var a2 = element.hasAttribute('id'); // проверить наличие атрибута
var a3 = element.getAttribute('id'); // получить значение атрибута
element.setAttribute('id', 'new');   // установить атрибут
element.removeAttribute('id');       // удалить атрибут
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="document-open">Open / Location</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Открытие окна</h3>
<pre><code class="js">
var newWin = window.open('', 'Новое окно', 'width=400, height=300');
newWin.document.write('Вывод информации в новом окне');
newWin.close(); // закрыть созданное окно
</code></pre>

<h4>Переход на страницу</h4>
<pre><code class="js">
window.open();
// 1 – какую страницу загружать 
// 2 – название окна
// 3 – опции окна
</code></pre>

<pre><code class="js">
window.location.href = 'page.html'; // переходим на страницу (на этой же странице)
window.open('page.html');           // переходим на страницу (в новой вкладке)
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="document-width">Width / Height</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Width / Height</h3>
<pre><code class="js">
var a1 = window.innerWidth;                     // ширина окна пользователя
var a2 = window.innerHeight;                    // высота окна пользователя

var a3 = document.body.clientWidth;             // ширина документа (если body margin:0, совпадает с innerWidth)
var a4 = document.body.clientHeight;            // высота документа (по контенту body)

var a5 = document.documentElement.clientWidth;  // ширина документа (совпадает с innerWidth)
var a6 = document.documentElement.clientHeight; // высота документа (совпадает с innerHeight)
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="document-media">Media queries</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Media queries</h3>
<pre><code class="js">
var screen = <bg-code>window.matchMedia</bg-code>('(max-width:500px)');
if (screen.<bg-code>matches</bg-code>) {
	console.log('<500px');
} else {
	console.log('>500px');
}
</code></pre>

<pre><code class="js">
var screen = window.matchMedia('(max-width:500px)');
screen.addListener(changes);
changes(screen);

function changes(screen) {
	if (screen.matches) {
		console.log('<500px');
	} else {
		console.log('>500px');
	}
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="dom-element">DOM элементы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>Document Object Model (DOM) </bg-list> - объектная модель представления документа. Независящий от платформы и языка программирования способ представления документа, позволяющий программам и скриптам получить доступ к содержимому HTML, XHTML и XML документов, а также изменять содержимое, структуру и оформление таких документов</li>
	<li><bg-list>DOM</bg-list> - представление документа в виде дерева тегов, доступное для изменения через JS</li>
	<li>Всё содержимое документа представлено в виде иерархии объектов</li>
	<li>Структура этой иерархии стандартизирована, чтобы обеспечить независимость от платформы</li>
</ul>

<ul class="list-point">
	<b>Узлы (nodes)</b>
	<li><bg-list>Тип "element"</bg-list> - каждый HTML тег создает узел (node) дерева</li>
	<li><bg-list>Тип "element" дочерние узлы</bg-list> - вложенные в него элементы</li>
	<li><bg-list>Тип "text"</bg-list> - для представления текста</li>
</ul>

<pre><code class="js">
var a = element.<bg-code>tagName</bg-code>;  // название тега (если текстовый узел будет undefined)
var a = element.<bg-code>nodeName</bg-code>; // название узла (узел элемента или тексовый узел)
var a = element.<bg-code>nodeType</bg-code>; // тип узла (узел элемента 1 или текстовый узел 3)
</code></pre>

<pre><code class="js">
<em>createElement();</em>    // создать узел элемента
<em>createTextNode();</em>   // создать текстовый узел 
<em>appendChild();</em>      // добавить элемент перед
<em>insertBefore();</em>     // добавить элемент после
<em>removeChild();</em>      // удалить элемент
</code></pre>

<h4>Создание</h4>
<pre><code class="js">
var element = document.<bg-code>createElement</bg-code>('div');
element.innerHTML = 'Go to google';
element.className = 'class-google';
</code></pre>

<h4>Добавление на страницу</h4>
<pre><code class="js">
var wrapper = document.querySelector('#wrapper');

wrapper.<bg-code>appendChild</bg-code>(element);                      // внутри элемента после контента
wrapper.<bg-code>insertBefore</bg-code>(element, wrapper.lastChild);  // внутри элемента перед контентом
wrapper.parentNode.<bg-code>insertBefore</bg-code>(element, wrapper); // после элемента
wrapper.parentNode.<bg-code>appendChild</bg-code>(element);           // до элемента
wrapper.parentNode.<bg-code>replaceChild</bg-code>(element, wrapper); // заменить элемент другим элементом

// insertBefore (1 - элемент который вставляем, 2 - элемент перед которым вставляем)
// insertBefore (1 - чем заменяем, 2 - что заменяем)
</code></pre>

<h4>Удаление</h4>
<pre><code class="js">
wrapper.parentNode.<bg-code>removeChild</bg-code>(element); // удаление нового элемента
wrapper.parentNode.<bg-code>removeChild</bg-code>(wrapper); // удаление элемента обертки
document.body.<bg-code>removeChild</bg-code>(element);      // удаление нового элемента (если родитель body)
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="css">CSS</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
element.<bg-code>style</bg-code>.fontSize = '20px';              // css
</code></pre>

<pre><code class="js">
element.classList;                            // массив классов элемента
element.classList.<bg-code>add</bg-code>('active');              // добавление класса
element.classList.<bg-code>remove</bg-code>('active');           // удаление класса
element.classList.<bg-code>toggle</bg-code>('active');           // добавление / удаление класса
var a = element.classList.<bg-code>contains</bg-code>('active'); // проверяет наличие класса (true/false)
var a = element.classList.<bg-code>item</bg-code>(0);            // вернет название класса по индексу 
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="web-api">Web API</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<!------------------------------------------------------>
<h3>Определения</h3>
<!------------------------------------------------------>
<ul class="list">
	<li><bg-list>document</bg-list> - документ, который загружается в браузер</li>
	<li><bg-list>window</bg-list> - окно браузера</li>
</ul>
<ul class="list">
	<b>Window</b> - глобальный объект, состоит из
	<li><bg-list>1. DOM</bg-list> - объектная модель документа</li>
	<li><bg-list>2. BOM</bg-list> - объектная модель браузера</li>
	<li><bg-list>3. Глобальные переменные, объекты, функции</bg-list>  и т.д.</li>
</ul>

<!------------------------------------------------------>
<h3>1. window.document</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = window.document; // html документ
document.write("Текст"); // вывод на экран
</code></pre>

<!------------------------------------------------------>
<h3>2. Navigator - информация о браузере и ОС</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = navigator.userAgent;     // название браузера
var a = navigator.platform;      // ОС
var a = navigator.language;      // язык браузера
var a = navigator.oscpu;         // название операционной системы
var a = navigator.cookieEnabled; // включены ли куки
var a = navigator.onLine;        // подключен ли пользователь к Интернету
</code></pre>

<!------------------------------------------------------>
<h3>3. Screen - данные о экране пользователя</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = screen.width;       // ширина экрана
var a = screen.height;      // высота экрана
var a = screen.availWidth;  // доступная ширина (на сколько можно раскрыть браузер не в полноэкранном режиме)
var a = screen.availHeight; // доступная высота
var a = screen.colorDepth;  // глубина цвета
</code></pre>

<!------------------------------------------------------>
<h3>4. Location - информация о URL, возможность перезагрузить страницу</h3>
<!------------------------------------------------------>
<pre><code class="js">
location.reload();           // перезагрузка страницы
var a = location.href;       // адрес загруженной страницы
var a = location.toString(); // URL
location.href = 'page.html'; // переходим на страницу (на этой же странице)
</code></pre>

<pre><code class="js">
var a = window.location.pathname.split('/')[2];
var a = location.hash.slice(1);
</code></pre>

<h4>Ковертация URL</h4>
<pre><code class="js">
var encoded = encodeURI('http://google.com/на-русском');
var decoded = decodeURI(encoded);

console.log(encoded); // http://google.com/%D0%BD%D0%B0-%D1%80%D1%83%D1%81%D1%81%D0%BA%D0%BE%D0%BC
console.log(decoded); // http://google.com/на-русском
</code></pre>

<h4>Текущий адрес страницы без .html и символа "/" в начале</h4>
<pre><code class="js">
var currentUrl;        
// определяем строку пути относительно хоста страницы в формате "/page.html"       
currentUrl = location.pathname; 
// обрезаем символ "/" в начале и символы ".html" в конце
currentUrl = currentUrl.slice(1,currentUrl.length-5); 
</code></pre>

<h4>Поиск совпадений</h4>
<pre><code class="js">
// -1 - нет совпадений
var page = location.href.indexOf('/page/');
var page = location.pathname.indexOf('/page/');
</code></pre>

<!------------------------------------------------------>
<h3>5. History - вперед/назад по истории, позвляет без перезагрузки изменить страницу браузера</h3>
<!------------------------------------------------------>
<pre><code class="js">
window.history.back();         // эквивалент клика по кнопке назад
window.history.forward();      // эквивалент клика по кнопке вперед
window.history.go(-1);         // эквивалент history.back();
window.history.go(1);          // эквивалент history.forward();
var a = window.history.length; // количество страниц в стеке истории
</code></pre>

<pre><code class="js">
if (history && history.pushState) {
    // проверка поддержки history
}
</code></pre>

<!------------------------------------------------------>
<h3>6. Frames - содержит коллекцию всех дочерних объектов фреймов на странице</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = frames;
</code></pre>

<!------------------------------------------------------>
<h3>7. Вывод сообщения пользователю</h3>
<!------------------------------------------------------>
<pre><code class="js">
alert("Привет Мир");                      // модальное окно
var age = prompt('Сколько Вам лет?', ''); // модальное окно с вопросом и полем ввода
var answer = confirm('Вы согласны?');     // модальное окно да/нет (вернет bool значение)
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="form">Web Forms</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>input type="text"</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = element.<bg-code>value</bg-code>;
element.<bg-code>value</bg-code> = 'new value';
</code></pre>

<!------------------------------------------------------>
<h3>input type="checkbox"</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = element.<bg-code>checked</bg-code>; 
element.<bg-code>checked</bg-code> = true;
</code></pre>

<pre><code class="html">
&lt;input type="checkbox" onchange="func();"&gt; 
&lt;!-- onchange - изменение состояния --&gt;
</code></pre>

<!------------------------------------------------------>
<h3>input type="radio"</h3>
<!------------------------------------------------------>
<pre><code class="js">
var radio = document.querySelectorAll('input[type="radio"]');
for(var i=0; i<=radio.length-1; i++) {
	if(radio[i].<bg-code>checked</bg-code>) {
		var value = radio[i].getAttribute('value');
		console.log(value);
	}
}
</code></pre>

<pre><code class="js">
radio.<bg-code>disabled</bg-code> = true;         
</code></pre>	

<!------------------------------------------------------>
<h3>select</h3>
<!------------------------------------------------------>
<pre><code class="js">
var select = document.querySelector('select');
var a = select.<bg-code>value</bg-code>;
var a = select.<bg-code>options</bg-code>[select.selectedIndex].value;
var a = select.<bg-code>options</bg-code>[select.selectedIndex].text;
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="data-storage">Web Storage: Local Storage и Session Storage</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<b>Web Storage</b> - интернет-хранилище или DOM-хранилище<br>
	<b>Два основных типа веб-хранилища</b>
	<li>1. <bg-list>Локальное хранилище (localStorage)</bg-list> - аналогичен постоянным кукам. Доступно для всех скриптов из домена, который первоначально добавил данные и сохраняется после закрытия браузера. Не имеют определенного времени жизни</li>
	<li>2. <bg-list>Сессионное хранилище (sessionStorage)</bg-list> - аналогичен сессионным кукам. Сессия сохраняется по принципу одна страница-одно окно и ограничивается жизнью данного окна, то есть для каждого открытого окна создаётся новая сессия, которая прекращает своё существование при закрытии окна и не зависит от домена открывшего её. Сессия страницы остается активной все время пока окно браузера открыто и сохраняется между перезагрузками страниц. Открытие той же страницы в новом окне браузера или новой вкладке приводит к созданию новой сессии страницы, что отличается от поведения session cookies.</li>
</ul>

<ul class="list-point">
	<b>Особенности</b>
	<li>Не отправляются на сервер в отличие от Cookie</li>
</ul>

<!------------------------------------------------------>
<h3>Local Storage</h3>
<!------------------------------------------------------>
<p>Google Chrome -> F12 -> Application -> Local Storage</p>
<p>localStorage это свойство глобального объекта браузера (window)</p>
<pre><code class="js">
localStorage.<bg-code>setItem</bg-code>('id', '77');   // добавляет в localStorage новый ключ со значением (а если такой ключ уже существует, то перезаписывает новым значением)
var a = localStorage.<bg-code>getItem</bg-code>('id'); // получить значение
localStorage.<bg-code>removeItem</bg-code>('id');      // удаление ключа
localStorage.<bg-code>clear</bg-code>();               // очистка всего хранилища
</code></pre>

<pre><code class="js">
localStorage["Ключ"] = "Значение"; // установка значения
var a = localStorage["Ключ"];      // получение значения
delete localStorage["Ключ"];       // удаление значения
</code></pre>

<h4>Провека наличия ключа</h4>
<pre><code class="js">
if (localStorage.getItem('key') !== null) {...}
</code></pre>

<h4>Объекты и массивы</h4>
<pre><code class="js">
var obj = {
	item1: 1,
	item2: [123, "two", 3.0],
	item3: "hello"
};

localStorage.setItem("key", JSON.stringify(obj));        // сериализация объекта и запись в хранилище по ключу "key"
var returnObj = JSON.parse(localStorage.getItem("key")); // из json в объект
</code></pre>

<h4>Проверка QUOTA_EXCEEDED_ERR</h4>
<pre><code class="js">
// браузеры выделяют 5MB под localStorage
// при привышении исключение QUOTA_EXCEEDED_ERR
try {
	localStorage.setItem('ключ', 'значение');
} catch(e) {
	if (e == QUOTA_EXCEEDED_ERR) {
		console.log('Превышен лимит');
	}
}
</code></pre>

<!------------------------------------------------------>
<h3>Session Storage</h3>
<!------------------------------------------------------>
<pre><code class="js">
sessionStorage.<bg-code>setItem</bg-code>('key', 'value');   // сохранение данных в sessionStorage
var data = sessionStorage.<bg-code>getItem</bg-code>('key'); // получение данных из sessionStorage
sessionStorage.<bg-code>removeItem</bg-code>('key');         // удаление ключа
sessionStorage.<bg-code>clear</bg-code>();                   // очистка всего хранилища
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="data-db">IndexedDB</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li><bg-list>IndexedDB</bg-list> - это способ постоянного хранения данных внутри клиентского браузера, другими словами это NOSQL хранилище на стороне клиента</li>
</ul>





<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="data-cookie">Cookie</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<b>Типы куки</b>
	<li><bg-list>Сессионные куки</bg-list> временные куки, существуют только во временной памяти, пока пользователь находится на странице веб-сайта. Браузеры обычно удаляют сессионные куки после того, как пользователь закрывает окно браузера. В отличие от других типов куки, сессионные куки не имеют истечения срока действия</li>
	<li><bg-list>Постоянные куки</bg-list> постоянные куки-файлы удаляются в определённую дату или через определённый промежуток времени. Это означает, что информация о куки будет передаваться на сервер каждый раз, когда пользователь посещает веб-сайт, которому эти куки принадлежат</li>
	<li><bg-list>Защищенные куки</bg-list> могут быть переданы только через шифрованное соединение (то есть HTTPS). Они не могут передаваться по незащищенным соединениям. Чтобы защитить куки, необходимо добавить флаг Secure в файл куки</li>
	<li><bg-list>HttpOnly-куки</bg-list> нельзя обращаться с помощью API на стороне клиента, таких как JS</li>
</ul>

<ul class="list-point">
	<b>Особенности</b>
	<li>Данные отправляются обратно на сервер для каждого HTTP-запроса</li>
	<li>Куки могут устанавливать дату их удаления, в этом случае они будут автоматически удалены браузером в указанный срок. Если дата удаления не указана, куки удаляются сразу, как только пользователь закроет браузер. Таким образом, указание даты истечения позволяет сохранить куки более чем на один сеанс и такие куки называются постоянными</li>
	<li>Работают только на веб-сервере</li>
</ul>

<pre><code class="js">
<bg-code>document.cookie</bg-code> = 'info=123';                                        // установить cookie (удаляются при закрытии браузера)
<bg-code>document.cookie</bg-code> = 'info=123; expires=Fri, 31 Dec 2018 23:59:59 GMT'; // установить cookie (удалятся 31.12.2018)
var a = <bg-code>document.cookie</bg-code>;                                             // прочитать cookie
</code></pre>

<h4>Атрибуты куки</h4>
<pre><code class="js">
document.cookie = 'info=123; expires=Fri, 31 Dec 2018 23:59:59 GMT; path=/; domain=.example.org';
</code></pre>




<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="methods-this">Context (this, call, apply, bind)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>this</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>У каждого вызова функции есть свой «контекст выполнения» <bg-list>execution context</bg-list> и он всегда разный в зависимости от того как функция была вызвана</li>
	<li><bg-list>Контекст выполнения</bg-list> - служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор</li>
	<li><bg-list>Контекст вызова функции</bg-list> - тот объект который ее вызывает</li>
	<li><bg-list>this</bg-list> - ссылка на текущий контекст вызова (на текущий объект с которым произошло событие) и определяется в момент вызова функции</li>
</ul>



<!------------------------------------------------------>
<h3>bind(), call(), apply()</h3>
<!------------------------------------------------------>
<ul class="list">
	<li><bg-list>call()</bg-list> - явное указание контекст вызова</li>
	<li><bg-list>apply()</bg-list> - аналогичен call(), только аргументы передаются массивом вторым аргументом</li>
	<li><bg-list>bind()</bg-list> - не вызывает функцию, а связывает с объектом. не изменяет исходную функцию, а возвращает новую</li>
</ul>

<pre><code class="js">
var greet = function(greeting) {
	return greeting + ' User '+this.name;
}
var person = {
	name: 'Brad',
	greet: greet
}
var anotherPerson = {
	name: 'Tony',
	greet: greet
}
</code></pre>

<pre><code class="js">
var a = anotherPerson.greet.<bg-code>call</bg-code>(person, 'Hello');    // this указывает на person
var a = anotherPerson.greet.<bg-code>apply</bg-code>(person, ['Hello']); // this указывает на person
var b = greet.<bg-code>bind</bg-code>(person);                           // this указывает на person
var a = b('Hello');
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="method-chaining">Method Chaining (Цепные вызовы методов)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
var str1 = 'Hello';
var str2 = str1
    .replace('a', 'b')
    .concat(' add')
    .toUpperCase();
</code></pre>
	

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="json">JSON</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list">
	<li><bg-list>JSON</bg-list> - JavaScript Object Notation</li>
	<li><bg-list>Сериализация объектов</bg-list> - преобразование объектов в строки</li>
	<li><bg-list>В JSON можно хранить</bg-list> - объекты, массивы, строки, числа true, false, null. Другие значения при сериализации превращаются в null</li>
</ul>

<pre><code class="js">
var user = {
    name: 'Tony',
    id: 25
}
var userData = <bg-code>JSON.stringify</bg-code>(user); // объект в JSON ("{"name":"Tony","id":25}")
var userObj = <bg-code>JSON.parse</bg-code>(userData);  // JSON в строку
</code></pre>
	
<pre><code class="js">
// если в объекте есть метод toJSON при преобразовани stringify данные будут браться из него
var user = {
    name: 'Tony',
    id: 25,
    toJSON() {
        return {
            name: this.name
        }
    }
}
var userData = JSON.stringify(user); // объект в JSON ("{"name":"Tony"}")
</code></pre>
	

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="strict-mode">Strict Mode</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<p>Может быть прописано в начале файла или в начале функции</p>
<pre><code class="js">
'use strict';
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="regexr">Регулярные выражения</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="html">
<a href="https://regexr.com/" target="_blank">https://regexr.com/</a>
</code></pre>

<!------------------------------------------------------>
<h3>Expression Flags</h3>
<!------------------------------------------------------>
<pre><code class="html">
<em>//g</em>          - global (все совпадения)
<em>//i</em>          - case insensitive (регистронезависимый поиск)
<em>//m</em>          - multiline
<em>//u</em>          - unicode
<em>//y</em>          - sticky
</code></pre>

<pre><code class="html">
<em>[]</em>           - класс символов
<em>/[a-zA-Z]/g</em>  - глобальный поиск
</code></pre>

<!------------------------------------------------------>
<h3>Expressions</h3>
<!------------------------------------------------------>
<pre><code class="html">
<em>a-zA-Z</em>               - строчные и заглавне буквы
<em>0-9</em>                  - символы от 0-9
<em>^0-9</em>                 - символы кроме чисел от 0-9 
<em>\d</em>                   - символы от 0-9
<em>\D</em>                   - символы кроме чисел от 0-9
<em>\w</em>                   - символы, являющиеся буквами или цифрами
<em>\W</em>                   - символы, не являющиеся буквами или цифрами
<em>\s</em>                   - пустые символы (пробелы, табуляция, перенос строк)
<em>\S</em>                   - все не пустые символы
<em>\bar\b</em>               - граница слова. только слово "bar"
<em>\bar\B</em>               - не должно быть границы слова. только символы "bar" в слове
<em>grey|gray</em>            - или
<em>.</em>                    - любой символ кроме переноса строк
<em>\.</em>                   - точка (экранированно /)
<em>a.{5}z</em>               - между буквами "a" и "z" 5 любых символов
<em>a.{2,5}z</em>             - между буквами "a" и "z" от 2-5 любых символов
<em>a.{2,}z</em>              - между буквами "a" и "z" от 2 и более любых символов
<em>a.+z</em>                 - между буквами "a" и "z" от 1 и более любых символов
<em>a.*z</em>                 - между буквами "a" и "z" от 0 и более любых символов
<em>^edit</em>                - начало строки (установить multiline)
<em>\.$</em>                  - конец строки (установить multiline)
<em>and(?= hi)</em>           - слова "and" после которых есть пробел и слово "hi"
<em>and(?! hi)</em>           - слова "and" после которых нет пробела и слова "hi"
<em>(\b\w+)@(\w+\.\w+\b)</em> - запоминающая группа. поиск email
</code></pre>

<!------------------------------------------------------>
<h3>Класс RegExp</h3>
<!------------------------------------------------------>
<pre><code class="js">
var pattern = new RegExp('\w+', 'g'); // конструктор
var pattern = /\w+/g;                 // литерал
</code></pre>

<h4>Свойства, доступные для чтение</h4>
<pre><code class="js">
pattern.global;
pattern.ignoreCase;
pattern.mutiline;
pattern.lastIndex; // индекс последнего результата
</code></pre>

<h4>test() - проверка соответствия строки регулярному выражению (true/false)</h4>
<pre><code class="js">
var text = "О дивный новый мир";
var pattern = /новый/;
var result = pattern.test(text); 
</code></pre>

<h4>exec() - аналогичен match()</h4>
<pre><code class="js">
// если не установлен флаг global, результат аналогичен методу match
// если установлен флаг global, получаем 1 первый match
var text = "О дивный новый мир";
var pattern = /новый/g;
var result = pattern.exec(text); 
</code></pre>

<!------------------------------------------------------>
<h3>Строки</h3>
<!------------------------------------------------------>

<h4>search() - возвращает позицию первого элемента</h4>
<pre><code class="js">
// игнорирует флаг global
var text = "О дивный новый мир";
var pattern = /мы/;
var result = text.search(pattern); // 9
</code></pre>

<h4>match() - возвращает само совпадение</h4>
<pre><code class="js">
// не игнорирует флаг global
var text = "О дивный новый мир";
var pattern = /новый/;
var result = text.match(pattern); // ["новый", index: 9, input: "О дивный новый мир", groups: undefined]
</code></pre>

<h4>split() - преобразование строки с заданным разделителем в массив </h4>
<pre><code class="js">
var pattern = /[\s,]+/;
var result = text.split(pattern); // разделитель пробел
</code></pre>

<h4>replace() - ищет совпадение и заменяет</h4>
<pre><code class="js">
var text = 'привет мир';
var pattern = /привет/;

text = text.replace(pattern, function(match) {
    return match.toUpperCase();
});
</code></pre>

<pre><code class="js">
str = str.replace(/'/g, '"');         // поменять одинарные кавычки на двойные
str = str.replace(/«/g, '"');         // поменять « 
str = str.replace(/»/g, '"');         // поменять »
str = str.replace(/–/g, '-');         // поменять "–"
str = str.replace(/\r|\n/g, '');      // убрать перенос строки
str = str.replace(/<\/?[^>]+>/g, ''); // удалить html теги из текста
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="collback">Collback Function</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list">
	<li><bg-list>callback function</bg-list> - функция обратного вызова button.onclick = function() {}</li>
</ul>

<pre><code class="js">
fade(this, 1000, function() {
	this.style.display = 'none';
})
function fade(element, time, callbackFunction) {
	// если callback не задан, создаем пустую функцию
	var callback = callbackFunction || function() {};
	// вызываем callback когда необходимо
	callback.call(element); // передать новый контекст this
}
</code></pre>

<pre><code class="js">
var greeting = function(callback) {
	var name = 'Tony';
	return callback(name);
}
var a = greeting(function(name) {
	return 'Hello ' + name;
});
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="iterators">Итераторы</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>Итерируемый, перебираемый объект (Iterable)</bg-list> - объект содержание которого можно перебрать по одному элементу. Пример: массив, строка, коллекция dom-элементов</li>
	<li><bg-list>Итератор</bg-list> - паттерн проектирования, согласно которому источник элементов прячется от клиента. Клиенту достается специальный объект с помощью которого он может получить элементы по одному. Клиенту не нужно беспокоиться о том как итерировать объект, при этом внутри самого объекта автор может использовать любую структуру для хранения элементов и любой алгоритм для их перебор. Клиент не получает саму структуру и автору не нужно беспокоиться что клиент может ее изменить</li>
	<li><bg-list>Объект является итератором</bg-list>, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая свое текущее положение внутри этой последовательности</li>
	<li><bg-list>Конструкция for..of</bg-list> в начале своего выполнения автоматически вызывает Symbol.iterator(), получает итератор и далее вызывает метод next() до получения done: true. Такова внутренняя механика. Внешний код при переборе через for..of видит только значения</li>
	<li><bg-list>Интераторы</bg-list> используются для реализации генераторов</li>
</ul>

<ul class="list-point">
	<b>Плюсы</b>
	<li>Разные языковые конструкции работают с разными структурами данных по одному принципу в не зависимости от их внутренней реализации</li>
	<li>Можно написать собственную структуру данных, реализовать интерфейс iterable и работать с ней с помощью конструкций for...of, spread-операторов, Array.from и т.д.</li>
</ul>

<h4>Перебор через for...of</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
for(var item of arr) {
    console.log(item);
}
</code></pre>

<h4>Перебор через встроенный итератор</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
var iterator = arr[<bg-code>Symbol.iterator</bg-code>]();
console.log(iterator.<bg-code>next()</bg-code>); // {value: "js", done: false}
console.log(iterator.<bg-code>next()</bg-code>); // {value: "python", done: false}
console.log(iterator.<bg-code>next()</bg-code>); // {value: "ruby", done: false}
console.log(iterator.<bg-code>next()</bg-code>); // {value: undefined, done: true}
</code></pre>

<h4>Перебор через встроенный итератор в цикле</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
var iterator = arr[Symbol.iterator]();
var next = iterator.next();
// по похожему алгоритму работает for...of
while (!next.done) {
    console.log(next.value);
    next = iterator.next();
}
</code></pre>

<h4>Создание итератора</h4>
<pre><code class="js">
// итерируемый объект
// числа от 1 до 100
let idGenerator = {
    [Symbol.iterator]() {
        let id = 1;
        return {
            next() {
                let value = id++;
                let done = false;
                return {value, done};
            }
        };
    }
};
// используя цикл
// for(let id of idGenerator) {
//     console.log(id);
//     if (id > 100) {
//         break;
//     }
// }
// доступ к итератору
let num = idGenerator[Symbol.iterator]();
console.log(num.next().value);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="promise">Promise (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li>Функции <bg-code>resolve/reject</bg-code> принимают ровно один аргумент - результат/ошибку. Именно он передаётся обработчикам в <bg-code>.then/.catch</bg-code></li>
	<li><bg-code>Promise</bg-code> после <bg-code>reject/resolve</bg-code> - неизменны</li>
	<li>Если говорить о взаимодействии с API, то <bg-code>catch</bg-code> используется для обработки http статусов <bg-code>4xx 5xx</bg-code>, <bg-code>then</bg-code> это статусы <bg-code>2xx</bg-code></li>
</ul>

<!------------------------------------------------------>
<h3>Состояния Promise</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-list>Promise Pending</bg-list> - обещение выполняется</li>
	<li><bg-list>Promise Resolved</bg-list> - обещание сдержано</li>
	<li><bg-list>Promise Rejected</bg-list> - обещение не сдержано</li>
</ul>

<!------------------------------------------------------>
<h3>Создание Promise</h3>
<!------------------------------------------------------>
<pre><code class="js">
functin functionAsync() {
	var promise = new <bg-code>Promise</bg-code>(function(resolve, reject) {
		// любые асинхронные операции
		// resolve(результат) при успешном выполнении
		// reject(ошибка) при ошибке
		const isSuccess = (Math.random() * 100) <= 70;
	    if (isSuccess) {
	        <bg-code>resolve</bg-code>('ok');
	    } else {
	        <bg-code>reject</bg-code>(new Error('Api error')); // аналогично
	        throw new Error('Api error');   // аналогично
	    }
	});
	return promise;
}
</code></pre>

<pre><code class="js">
functionAsync()
	// resolve
    <bg-code>.then</bg-code>(result => {
        console.log(result);
    })
    // reject
    <bg-code>.catch</bg-code>(error => console.error(error)); // Error: Api error
    // .catch(error => console.error(error.message)); // Api error
</code></pre>

<!------------------------------------------------------>
<h3>Обработка Promise в асинхронных операциях</h3>
<!------------------------------------------------------>
<pre><code class="js">
functionAsync()
	.then(resolve, reject);
	// resolve - функция, которая сработает если обещание выполняется
	// reject  - функция, которая сработает если обещание не будет выполнена
</code></pre>

<pre><code class="js">
functionAsync()
	.then(functionSuccess1)
	.then(functionSuccess1)
	.catch(functionError);
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>

<h4>Пример #1</h4>
<pre><code class="js">
function applyForVisa(document) {
	console.log('Обработка заявления...');
	let promise = new Promise(function(resolve, reject) {
		setTimeout(function() {
			Math.random() > 0 ? resolve({}) : reject('В визе отказано');
		}, 2000);
	});
	return promise;
}
function getVisa(visa) {
	console.info('Виза получена');
	return new Promise(function(resolve, reject) {
		setTimeout(() => resolve(visa), 2000);
	});
}
function bookHotel(visa) {
	console.log(visa);
	console.log('Бронируем отель');
	return Promise.resolve(visa);
	// return Promise.reject('Нет мест');
}
function buyTickets(booking) {
	console.log('Покупаем билеты');
	console.log('Бронь', booking);
}
applyForVisa({})
	.then(getVisa)
	.then(bookHotel)
	.then(buyTickets)
	.catch(error => console.error(error))
	.then(() => console.log('Выведется в любом случае'));
</code></pre>

<h4>Пример #2. Несколько Promise</h4>
<pre><code class="js">
function go(num) {
	return new Promise(function(resolve, reject) {
		setTimeout(() => resolve(num), 1000);
	})
}

let p1 = go(1);
let p2 = go(2);
let p3 = go(3);

// выполняет все обещания даже если ошибка в первом
// но закончится всё равно ошибкой
Promise.all([p1, p2, p3])
	.then(value => console.log(value));

// получить результат от первого
Promise.race([p1, p2, p3])
	.then(value => console.log(value));
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="generators">Generators (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Generators альтернатива Promise</li>
	<li>Generators - функции, которые могут останавливать свое выполнение, возвращать промежуточный результат и далее возобновлять выполнение позже в произвольный мемент времени</li>
</ul>

<h4>Объявление генератора</h4>
<pre><code class="js">
function* genetare()  {} 
function * genetare() {} 
function *genetare()  {} 

// анонимная функция
var generator = function*() {}

// метод у объекта
var obj = {
    *generator(start, end) {}
}

// метод у класса
class SomeClass {
    *generator(start, end) {}
}
</code></pre>

<ul class="list-point">
	<li>При вызове Генератора возвращается объект Итератор, позволяющий приостанавливать и возобновлять процесс выполнения функции</li>
	<li><bg-list>yield</bg-list> - позволяет поставить выполнение функции на паузу и возобновить в произвольный момент</li>
	<li><bg-list>yield</bg-list> - производит и отдает информацию - объек со свойствами value и done,
но при этом также отдаем контроль за функцией</li>
	<li><bg-list>yield 1</bg-list> - возвращает промежуточный результат (value: 1)</li>
</ul>

<h4>Использование с Fetch</h4>
<pre><code class="js">
function getApi() {
	let response = yield fetch('url');
	let data = yield response.json();
	return data;
}
</code></pre>

<h4>Пример #1. Передать значение</h4>
<pre><code class="js">
function* generate() {
    console.log('Start');
    yield 1;
    console.log('Finish');
}
var iterator = generate();
console.log(iterator.next()); // Object { value: undefined, done: false } Start
console.log(iterator.next()); // Object { value: undefined, done: true  } Finish
console.log(iterator.next()); // Object { value: undefined, done: true  }        
</pre></code>

<h4>Пример #2. Получить значение</h4>
<pre><code class="js">
function* generator() {
    var result = yield;
    console.log(result); // 1
}
var iterator = generator();
console.log(iterator.next());  // первый вызов запускает генератора, нельзя передать значение
console.log(iterator.next(1)); // передаваемое значение

iterator.return(); // остановить генератор
iterator.throw();  // остановить с ошибкой
</pre></code>

<h4>Пример #3. Генаратор</h4>
<pre><code class="js">
function* range(start, end) {
    let current = start;
    while (current <= end) {
        yield current++;
    }
}
for (let num of range(1, 10)) {
    console.log(num);
}
</pre></code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="async-func">Async Function (ES2017)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Async Function - асинхронная функция (Promise + Generator)</li>
	<li>Асинхронная функция возвращает обещение, для получения значения используется then</li>
	<li>Если в асинхронной функции специально вернуть обещение, оно не оборачивается в другое обещание</li>
</ul>

<pre><code class="js">
async function getUser(id) {
    return { id:1 };   
}
getUser(1).then(user => console.log(user));
</code></pre>

<ul class="list-point">
	<li>await дожидается выполнения обещания, вытаскивает значение и возвращает его</li>
	<li>код после await выполнится только после выполнения функции</li>
	<li>await можно использовать только внутри асинхронной функции</li>
	<li>await необязательно ставить перед вызовом асинхронной фунцкии. это может быть любая функция, возвращающая обещание</li>
</ul>
<pre><code class="js">
async function getUser(id) {
    return { id:1 };   
}
async function main() {
    let user = await getUser(1);
    console.log(user);
}
main();
</code></pre>

<pre><code class="js">
async function getUser(id) {
    let response = await fetch('url');
    let data = await response.json();
    return data;
}

async function main() {
    try {
        let user = await getUser(1);
        console.log(user);
    } catch(error) {
        console.log(error);
    }
}

main();
</code></pre>

<h4>Варианты объявления</h4>
<pre><code class="js">
const getUser = async function(id) {}
const getUser = async (id) => {}
const dataService = {
	getUser: async function(id) {}  // свойство
	async getUserProp(id) {}        // метод
}
</code></pre>

<pre><code class="js">
(async function() {
	//
})();

(async () => {
	//
})();
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="set">Set (ES6)</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Set (ES6) - множество</li>
	<li>Структура данных в которой хранятся уникальные значения</li>
	<li>Нет литеральной формы, создается с помощью конструктора</li>
	<li>Варианты использования: хранение css классов dom элементов</li>
</ul>

<!------------------------------------------------------>
<h3>Объявление</h3>
<!------------------------------------------------------>
<pre><code class="js">
const set = new Set(); // Set(0) {}
</code></pre>

<pre><code class="js">
// для указания начального значения в конструкторе указывается перебираемый объект
const set = new Set(['button', 'active', 'small']); // Set(3) {"button", "active", "small"}
</code></pre>

<pre><code class="js">
// буква "t" хранится 1 раз, т.к. в set только уникальные значения
const set = new Set('button'); // Set(5) {"b", "u", "t", "o", "n"}
</code></pre>

<pre><code class="js">
// set из 1 элемента
const set = new Set(['button']); // Set(1) {"button"}
</code></pre>

<pre><code class="js">
// клонирование set
const set1 = new Set(['button']); // Set(1) {"button"}
const set2 = new Set(set1);       // Set(1) {"button"}
</code></pre>

<!------------------------------------------------------>
<h3>Добавление нового элемента</h3>
<!------------------------------------------------------>
<pre><code class="js">
const set = new Set();
set.add('button');
set.add('active');
set.add('active');
// Set(2) {"button", "active"}

const set = new Set();
set
    .add('button')
    .add('active')
    .add('active');
</code></pre>

<!------------------------------------------------------>
<h3>Методы</h3>
<!------------------------------------------------------>
<pre><code class="js">
var a = set.size;          // кол-во элементо в set
var a = set.has('button'); // проверка наличия значения
set.delete('active');      // удаление элемента 
set.clear();               // очистка set
</code></pre>

<!------------------------------------------------------>
<h3>Set и Объекты</h3>
<!------------------------------------------------------>
<pre><code class="js">
const set = new Set();
set.add({className: 'button'}); 
var a = set.has({className: 'button'}); // false
// в метод add отправляется ссылка на один объект
// в метод has отправляется ссылка на другой объект

const set = new Set();
const buttonRef = {className: 'button'};
set.add(buttonRef); 
var a = set.has(buttonRef); // true
</code></pre>

<!------------------------------------------------------>
<h3>values, keys, entries</h3>
<!------------------------------------------------------>
<pre><code class="js">
// нет метода для получения доступа к конкретному элементу
// нет понятия как индекс, поэтому keys возвращает values
console.log(...set);           // button active
console.log([...set]);         // (2) ["button", "active"]
console.log(Array.from(set));  // (2) ["button", "active"]

console.log(set.values());     // SetIterator {"button", "active"}
console.log(...set.values());  // button active
console.log(...set.keys());    // button active
console.log(...set.entries()); // (2) ["button", "button"] (2) ["active", "active"]
</code></pre>

<!------------------------------------------------------>
<h3>Перебор set</h3>
<!------------------------------------------------------>
<pre><code class="js">
// перебор set
for (let item of set) {
    console.log(item);
}
// button
// active
</code></pre>

<pre><code class="js">
set.forEach((item, item2, set) => console.log(item, item2, set));
// button button Set(2) {"button", "active"}
// active active Set(2) {"button", "active"}
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="patterns">Паттерны проектирования</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="html">
<a href="https://refactoring.guru/ru/design-patterns/catalog" target="_blank">Каталог паттернов проектирования</a>
<a href="https://habr.com/ru/company/ruvds/blog/427293/" target="_blank">Паттерны проектирования в JavaScript</a>
<a href="https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9" target="_blank">Шаблоны проектирования в JavaScript</a>
</code></pre>

<ul class="list-point">
	<li><bg-list>Паттерн проектирования</bg-list> (design pattern) - это повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста</li>
</ul>

<h4>Основные</h4>
<ul class="list-point">
	<bg-mass><a href="#pattern-singleton">Синглтон (Singleton)</a></bg-mass>
	<bg-mass><a href="#pattern-module">Модуль (Module)</a></bg-mass>
	<bg-mass><a href="#pattern-revealing-module">Открытый модуль (Revealing Module)</a></bg-mass>
	<bg-mass><a href="#pattern-decorator">Декоратор (Decorator)</a></bg-mass>
</ul>
<ul class="list-point">
	<bg-mass><a href="#pattern-factory">Фабрика (Factory)</a></bg-mass>
	<bg-mass>Фабричный метод (Factory Method)</bg-mass>
	<bg-mass>Абстрактная фабрика (Abstract Factory)</bg-mass>
	<bg-mass>Адаптер (Adapter)</bg-mass>
	<bg-mass>Наблюдатель (Observer)</bg-mass>
	<bg-mass>Издатель-подписчик (Publisher-Subscriber, Pub/Sub)</bg-mass>
</ul>
<h4>Дополнительные</h4>
<ul class="list-point">
	<bg-mass>Хранитель (Memento)</bg-mass>
	<bg-mass>Цепочка обязанностей (Chain of Responsibility)</bg-mass>
	<bg-mass>Команда (Command)</bg-mass>
	<bg-mass>Состояние (State)</bg-mass>
	<bg-mass>Стратегия (Strategy)</bg-mass>
	<bg-mass>Итератор (Iterator)</bg-mass>
	<bg-mass>Шаблонный метод (Template Method)</bg-mass>
	<bg-mass>Посредник (Mediator)</bg-mass>
	<bg-mass>Посетитель (Visitor)</bg-mass>
	<bg-mass>Прокси (Proxy)</bg-mass>
	<bg-mass>Мост (Bridge)</bg-mass>
	<bg-mass>Компоновщик (Composite)</bg-mass>
	<bg-mass>Строитель (Builder)</bg-mass>
	<bg-mass>Фасад (Facade)</bg-mass>
	<bg-mass>Прототип (Prototype)</bg-mass>
	<bg-mass>Приспособленец (Flyweight)</bg-mass>
</ul>

<!------------------------------------------------------>
<h3 id="pattern-singleton">Паттерн «Синглтон»</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Использование конструктора плохая практика, особенно если у класса есть зависимости var user = new User();</li>
	<li><bg-list>Паттерн «Синглтон»</bg-list> или «Одиночка» (Singleton) представляет собой объект, который может существовать лишь в единственном экземпляре. В рамках применения этого паттерна новый экземпляр некоего класса создаётся в том случае, если он пока не создан. Если же экземпляр класса уже существует, то, при попытке обращения к конструктору, возвращается ссылка на соответствующий объект. Последующие вызовы конструктора всегда будут возвращать тот же самый объект</li>
	<li><bg-list>Синглтон</bg-list> гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему в однопоточном приложении</li>
</ul>

<h4>Представление класса в виде объектного литерала</h4>
<ul class="list-point">
	<li>Всякий раз, когда мы обращаемся к переменной user, мы получаем ссылку на один и тот же объект</li>
</ul>
<pre><code class="js">
const user = {
	name: 'Tony',
	greet: function() {
		console.log('Hello!');
	}
};
</code></pre>

<h4>Представление класса в виде синглтона</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
var instance = null;

class Singleton {
	constructor() {
		if(!instance){
			instance = this;
		}
		// this.name = null;
		return instance;
	}
	testMethod() {
		return 'Hello'
	}
}

var a = new Singleton();
var b = new Singleton();
<bg-code>console.log(a === b); // true</bg-code>
console.log(a.testMethod());
</code></pre></div><div class="container-half"><pre><code class="js">
class usualClass {
	constructor() {
		// this.name = null;
	}
	testMethod() {
		return 'Hello'
	}
}

var a = new usualClass();
var b = new usualClass();
<bg-code>console.log(a === b); // false</bg-code>
console.log(a.testMethod());
<br><br><br><br><br>
</code></pre></div></div>

<!------------------------------------------------------>
<h3 id="pattern-module">Паттерн «Модуль»</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-list>Модуль</bg-list> - самостоятельный фрагмент кода, который можно изменять, не затрагивая другой код проекта. Модули, кроме того, позволяют избегать такого явления, как загрязнение областей видимости, благодаря тому, что они создают отдельные области видимости для объявляемых в них переменных.</li>
	<li>Модуль использует <u>IIFE</u>, <u>замыкания</u> и <u>области видимости функций</u> для имитации этой концепции <u>инкапсуляции</u></li>
	<li><bg-list>Модуль при помощи замыканий</bg-list> – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется</li>
	<li>Все функции модуля будут иметь доступ к другим переменным и внутренним функциям этого же модуля через замыкание. Но снаружи программист, использующий модуль, может обращаться напрямую только к тем переменным и функциям, которые экспортированы. Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля</li>
	<li><bg-list>Недостаток</bg-list> приходится создавать публичные функции только для того, чтобы обращаться к приватным функциям и переменным</li>
</ul>

<pre><code class="js">
const myModule = (function() {
	const privateVariable = 'Hello World';
	function privateMethod() {
		console.log(privateVariable);
	}
	return {
		publicMethod: function() {
			privateMethod();
		}
	}
})();
</code></pre>

<pre><code class="js">
myModule.publicMethod(); // Выводит 'Hello World'
</code></pre>

<!------------------------------------------------------>
<h3 id="pattern-revealing-module">Паттерн «Открытый модуль»</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-list>Открытый модуль</bg-list> - в паттерне назначаем свойствам возвращаемого объекта приватные функции, которые хотим сделать общедоступными</li>
</ul>

<ul class="list-point">
	<b>Преимущества паттерна «Открытый модуль» перед паттерном «Модуль»</b>
	<li>«Открытый модуль» позволяет делать общедоступными скрытые сущности модуля (и снова скрывать их, если нужно), модифицируя, для каждой из них, лишь одну строку в объекте, возвращаемом после выполнения IIFE</li>
	<li>Возвращаемый объект не содержит определения функций. Всё, что находится справа от имён его свойств, определено в IIFE. Это способствует чистоте кода и упрощает его чтение</li>
</ul>

<pre><code class="js">
const myRevealingModule = (function() {
	let privateVar = 'Peter';
	const publicVar  = 'Hello World';
	function privateFunction() {
		console.log('Name: '+ privateVar);
	}
	function publicSetName(name) {
		privateVar = name;
	}
	function publicGetName() {
		privateFunction();
	}
	return {
		setName: publicSetName,
		greeting: publicVar,
		getName: publicGetName
	};
})();
</code></pre>

<pre><code class="js">
myRevealingModule.setName('Mark');
myRevealingModule.getName(); // Выводит Name: Mark
</code></pre>

<!------------------------------------------------------>
<h3 id="pattern-decorator">Паттерн «Декоратор»</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Паттерн используется для расширения функционала объектов без модификации существующих классов или функций-конструкторов. Паттерн можно использовать для добавления к объектам неких возможностей без модификации кода, который ответственен за их создание</li>
</ul>

<pre><code class="js">
function Car(name) {
	this.name = name;
	this.color = 'White';
}

// создание нового объекта, который планируется декорировать
const tesla= new Car('Tesla Model 3');

// декорирование объекта - добавление нового функционала
tesla.setColor = function(color) {
	this.color = color;
}
tesla.setPrice = function(price) {
	this.price = price;
}

tesla.setColor('black');
tesla.setPrice(49000);
console.log(tesla.color); // выводит black
</code></pre>


<!------------------------------------------------------>
<h3 id="pattern-factory">Паттерн «Фабрика»</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li>Паттерн использует для создания объектов так называемые <u>«фабричные методы»</u>. При этом не требуется указывать классы или функции-конструкторы, которые применяются для создания объектов</li>
	<li>Паттерн используется для создания объектов в случаях, когда не нужно делать общедоступной логику их создания. Паттерн может быть использован в том случае, если нужно создавать различные объекты в зависимости от специфических условий</li>
</ul>


<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- AJAX -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ajax-request">Технологии</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code>
1. XMLHttpRequest (не используют в явном виде, создаются обертки)
2. Fetch (нативный, полифил для IE)
3. Axios
</code></pre>

<pre><code class="bash">
# Vue Resource (до версии Vue.js 2)
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="xmlhttprequest">XMLHttpRequest</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h4>Асинхронный</h4>
<pre><code class="js">
var xmlhttp = new XMLHttpRequest();
// установка обработчика событий
xmlhttp.onreadystatechange = function() {
    if (xmlhttp.readyState==4 && xmlhttp.status==200) {
		dosomething(xmlhttp.responseText);
    }
};
xmlhttp.open('GET', url, true); // true - скачиваем асинхронно
xmlhttp.send(null); // отправляем запрос, результат придёт в обработчик onreadystatechange
</code></pre>

<h4>Синхронный</h4>
<pre><code class="js">
var xmlhttp = new XMLHttpRequest();
xmlhttp.open('GET', url, false); // false - скачиваем синхронно
// отправляем запрос, тут же ждём результат
xmlhttp.send(null);
// результат получен
if(xmlhttp.status == 200)
    dosomething(xmlhttp.responseText);
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="fetch">Fetch</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="html">
<a href="https://github.com/github/fetch" target="_blank">https://github.com/github/fetch - полифил и описание методов</a>
<a href="https://developer.mozilla.org/ru/docs/Web/API/Fetch_API/Using_Fetch" target="_blank">MDN</a>
</code></pre>

<h4>Синтаксис метода fetch</h4>
<ul class="list">
	<b>let promise = fetch(url[, options])</b>
	<li><bg-list>url</bg-list> - URL, на который сделать запрос</li>
	<li><bg-list>options</bg-list> - необязательный объект с настройками запроса</li>
</ul>

<ul class="list">
	<b>Свойства options</b>
	<li><bg-list>method</bg-list> - метод запроса</li>
	<li><bg-list>headers</bg-list> - headers </li>
	<li><bg-list>body</bg-list> -  тело запроса: FormData, Blob, строка и т.д.</li>
	<li><bg-list>mode</bg-list> - одно из: «same-origin», «no-cors», «cors», указывает, в каком режиме кросс-доменности предполагается делать запрос</li>
	<li><bg-list>credentials</bg-list> - одно из: «omit», «same-origin», «include», указывает, пересылать ли куки и заголовки авторизации вместе с запросом</li>
	<li><bg-list>cache</bg-list> - одно из «default», «no-store», «reload», «no-cache», «force-cache», «only-if-cached», указывает, как кешировать запрос</li>
	<li><bg-list>redirect</bg-list> - можно поставить «follow» для обычного поведения при коде 30x (следовать редиректу) или «error» для интерпретации редиректа как ошибки</li>
</ul>

<h4>Объект response (ответ)</h4>
<pre><code class="js">
var a = response.headers.get('Content-Type');
var a = response.status; 

var a = response.arrayBuffer();
var a = response.blob();
var a = response.formData();
var a = response.json();
var a = response.text();
</code></pre>

<h4>Пример #1. Без передачи значений</h4>
<pre><code class="js">
fetch('script.php')
    .then(function(response) {
        return response.text();
    })
    .then(function(body) {
        document.body.innerHTML = body;
    })
    .catch(function(error) {
        console.log(error);
    });
</code></pre>

<h4>Пример #2. Передача одного значения</h4>
<pre><code class="js">
fetch('script.php', {
	method: 'POST',
	body: 'hello'
})
</code></pre>
<pre><code class="php">
// script.php
&lt;?php
    $content = file_get_contents("php://input");
    echo $content;
?&gt;
</code></pre>

<h4>Пример #3. Передача JSON</h4>
<pre><code class="js">
fetch('script.php', {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json'
	},
	body: JSON.stringify({
		name: 'Tony',
		login: 'Admin'
	})
})
</code></pre>
<pre><code class="php">
// script.php
&lt;?php
    $content = file_get_contents("php://input");
    $decoded = json_decode($content, true);
    echo $decoded[name];
?&gt;
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="axios">Axios</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<pre><code class="html">
<a href="https://github.com/axios/axios" target="_blank">GitHub Axios</a>
</code></pre>

<pre><code class="bash">
npm i axios --save
</code></pre>

<pre><code class="js">
const axios = require('axios');
</code></pre>

<!------------------------------------------------------>
<h3 id="axios">GET</h3>
<!------------------------------------------------------>
<pre><code class="js">
axios.get('url')
.then(response => {
	console.log(response.data);
})
.catch(error => console.log(error));
</code></pre>

<!------------------------------------------------------>
<h3 id="axios-post">POST</h3>
<!------------------------------------------------------>
<pre><code class="js">
axios.post('url', {
		firstName: 'Fred',
		lastName: 'Flintstone'
	})
	.then(function (response) {
		console.log(response);
	})
	.catch(function (error) {
		console.log(error);
	});
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ajax-variants">Варианты запросов</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------>
<h3>Обработка формы</h3>
<!------------------------------------------------------>
<pre><code class="html">
&lt;form class="form"&gt;
	&lt;input type="text" name="name" required=""&gt;
	&lt;input type="text" name="message" required=""&gt;
	&lt;input type="submit" value="Отправить"&gt;
&lt;/form&gt;
</code></pre>

<pre><code class="js">
var form = document.querySelector('.form');

form.addEventListener('submit', function(e) {
	e.preventDefault();
	var name = this['name'];
	var message = this['message'];
	console.log(name.value, message.value);
});
</code></pre>

<!------------------------------------------------------>
<h3>Отправка формы из HTML</h3>
<!------------------------------------------------------>
<pre><code class="html">
&lt;form action="script.php" method="get"&gt;
    &lt;input type="text" name="name" required=""&gt;
    &lt;textarea name="message"&gt;&lt;/textarea&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;
</code></pre>

<pre><code class="html">
http://test1.ru/script.php?name=myname&message=my+message
</code></pre>

<pre><code class="php">
&lt;?php
	$name    = $_GET[name]; 
	$message = $_GET[message]; 
?&gt;
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="ajax-http-methods">HTTP-методы GET/POST/PUT/DELETE</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li><bg-list>HTTP</bg-list> протокол описывает взаимодействие между двумя компьютерами (клиентом и сервером), построенное на базе сообщений, называемых запрос (<bg-list>Request</bg-list>) и ответ (<bg-list>Response</bg-list>). Каждое сообщение состоит из трех частей: стартовая строка, заголовки и тело. При этом обязательной является только стартовая строка</li>
	<li><bg-list>Uniform Resource Identifier (URI)</bg-list> - единообразный идентификатор ресурса.
	Ресурс как правило, файл на сервере ('/styles.css'), или абстрактный объект ('/blogs/webdev/')</li>
	<li><bg-list>REST (REpresentational State Transfer)</bg-list> описывает принципы взаимодействия клиента и сервера, основанные на понятиях «ресурса» и «глагола». В случае HTTP ресурс определяется своим URI, а глагол — это HTTP-метод</li>
</ul>

<pre><code class="html">
<em>GET</em>     - получение ресурса
<em>POST</em>    - создание ресурса 
<em>PUT</em>     - обновление ресурса
<em>DELETE</em>  - удаление ресурса
<em>HEAD</em>    - аналогичен GET, получение информации о ресурсе, не получая самого ресурса

<em>OPTIONS</em> - определение возможностей веб-сервера или параметров соединения для конкретного ресурса
<em>PATCH</em>   - аналогичен PUT, но применяется только к фрагменту ресурса
<em>TRACE</em>   - возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе
<em>CONNECT</em> - преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="chrome-dev-tools">Chrome DevTools</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<ul class="list-point">
	<li><bg-list>F8</bg-list> - продолжить выполнение. Продолжает выполнения скрипта с текущего момента в обычном режиме. Если скрипт не встретит новых точек останова, то в отладчик управление больше не вернется</li>
	<li><bg-list>F10</bg-list> - сделать шаг, не заходя внутрь функции. Выполняет одну команду скрипта. Если в ней есть вызов функции – то отладчик обходит его стороной, т.е. не переходит на код внутри</li>
	<li><bg-list>F11</bg-list> - сделать шаг. Выполняет одну команду скрипта и переходит к следующей. Если есть вложенный вызов, то заходит внутрь функции</li>
	<li><bg-list>Shift+F11</bg-list> - выполнять до выхода из текущей функции. Выполняет команды до завершения текущей функции. Быстрый выход из вложенного вызова</li>
</ul>

Остановку можно инициировать и напрямую из кода скрипта, командой debugger
<pre><code class="js">
function pow(x, n) {
	...
	debugger; // отладчик остановится тут
	...
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h2 id="garbage-collection">Сборщик мусора</h2>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><bg-list>Сборщик мусора (Garbage collection, GC)</bg-list> - очистка памяти от недостижимых значений в браузере. GC встроенн в интерпретатор, он наблюдает за объектами и время от времени удаляет недостижимые</li>
	<li><bg-list>Примитивы</bg-list> - при присвоении они копируются целиком, ссылок на них не создаётся. Если в переменной была одна строка, а её заменили на другую, то предыдущая удаляется</li>
	<li><bg-list>Объекты</bg-list> требуют специального <u>«сборщика мусора»</u>, который наблюдает за ссылками, т.к. на один объект может быть много ссылок из разных переменных и, при перезаписи одной из них, объект может быть всё ещё доступен из другой</li>
	<li>
		<bg-list>Упрощение для работы с памятью</bg-list>: «значение остаётся в памяти, пока на него есть хотя бы одна ссылка»
		<ul class="list-point">
			<li>Верно - в том плане, что если ссылок на значение нет, то память из-под него очищается</li>
			<li>Неверно - в другую сторону: наличие ссылки не гарантирует, что значение останется в памяти</li>
		</ul>
	</li>
	<li><bg-list>Сборщик мусора</bg-list> идёт от корня по ссылкам и запоминает все найденные объекты. По окончанию - он смотрит, какие объекты в нём отсутствуют и удаляет их</li>
	<li><bg-list>Применение оптимизации интерпретаторами</bg-list> - деление объектов на два вида «старые» и «новые». Для каждого типа выделяется своя область памяти. Каждый объект создаётся в «новой» области и, если прожил достаточно долго, мигрирует в старую. «Новая» область обычно небольшая. Она очищается часто. «Старая» – редко</li>
	<li><bg-list>Замыкания</bg-list> <u>LexicalEnvironment</u> внешней функции существует в памяти до тех пор, пока существует хоть одна внутренняя функция, ссылающаяся на него через свойство <u>[[Scope]]</u></li>
	<li><bg-list>Оптимизация в V8</bg-list>JS-движки делают оптимизации <u>замыканий</u> по памяти. Они анализируют использование переменных и в случае, когда переменная из замыкания абсолютно точно не используется, удаляют её</li>
</ul>

<h4>Очистка памяти</h4>
<pre><code class="js">
var user = {
	name: 'Tony'
}
user = null;
</code></pre>







</div>
</div>
</div>
	<div id="preloader"></div>
    <script src="libraries/jquery.js"></script>
	<script src="libraries/highlight/highlight.pack.js"></script>
	<script src="js/main.js"></script>
	<script src="module/preloader/preloader.js"></script>
</body>
</html>
