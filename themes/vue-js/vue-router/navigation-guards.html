<h2>Навигационные хуки</h2>

<ul class="list-point">
	<li>Навигационные хуки vue-router используются для перенаправлений или отмены навигационных переходов. Есть несколько способов внедрить навигационный хук: глобально, для конкретного маршрута, или для конкретного компонента</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>1. Глобальные хуки (до навигационных хуков)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Глобальные навигационные хуки вызываются в порядке их создания при каждом навигационном переходе</li>
</ul>

<ul class="list-point">
	<b>В каждый навигационный хук передаётся три параметра</b>
	<li><code class="txt">to: Route</code>: целевой объект Route, к которому осуществляется переход</li>
	<li><code class="txt">from: Route</code>: текущий маршрут, с которого осуществляется переход к новому</li>
	<li><code class="txt">next: Function</code>: функция, вызов которой разрешает хук. В зависимости от переданных в next аргументов, результатом будет:</li>

	<ul class="list-point">
		<li><code class="txt">next()</code>: переход к следующему хуку в цепочке. Если хуков больше нет, переход считается подтверждённым</li>
		<li><code class="txt">next(false)</code>: отмена перехода. Если URL был изменён (вручную пользователем, или кнопкой "назад"), он будет сброшен на соответствующий маршрут from</li>
		<li><code class="txt">next('/')</code> или <code class="txt">next({ path: '/' })</code>: перенаправление на другой маршрут. Текущий переход будет отменён, и процесс начнётся заново для нового маршрута. Вы можете передать любой объект местоположения в next, который позволяет вам указывать опции такие как replace: true, name: 'home' и любой другой параметр используемый во входном параметре to компонента router-link или router.push</li>
		<li><code class="txt">next(error)</code>: если аргумент, переданный next является экземпляром Error, навигация будет прервана и ошибка будет передана в коллбэк, зарегистрированный через router.onError()</li>
	</ul>
</ul>

<!------------------------------------------------------------->
<h4>Регистрация: beforeEach</h4>
<!------------------------------------------------------------->
<pre><code class="js">
// регистрация глобального хука
const router = new VueRouter({ ... })
router.<bg-code>beforeEach</bg-code>((to, from, next) => {
	// ...
})
</code></pre>

<!------------------------------------------------------------->
<h4>Разрешения перехода: beforeResolve</h4>
<!------------------------------------------------------------->
<pre><code class="js">
router.<bg-code>beforeResolve</bg-code>() => {
	// ...
}
// похож на router.beforeEach, с той разницей, что разрешающий хук будет вызван 
// непосредственно перед подтверждением навигации, 
// после того, как будут разрешены все хуки компонента и асинхронные компоненты для маршрута
</code></pre>

<!------------------------------------------------------------->
<h4>Завершения перехода: afterEach</h4>
<!------------------------------------------------------------->
<pre><code class="js">
router.<bg-code>afterEach</bg-code>((to, from) => {
	// ...
})
// в отличие от сторожевых хуков, в них не передаётся функция next, 
// и на навигацию они повлиять не могут
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>2. Для конкретных маршрутов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
const router = new VueRouter({
	routes: [
		{
			path: '/foo',
			component: Foo,
			<bg-code>beforeEnter</bg-code>: (to, from, next) => {
				// ...
			}
		}
	]
})
// можно указать напрямую для конкретного маршрута в его конфигурации
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>3. Для конкретных компонентов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
const Foo = {
	template: `...`,
	<bg-code>beforeRouteEnter</bg-code>(to, from, next) {
		// вызывается до подтверждения пути, соответствующего этому компоненту.
		// НЕ ИМЕЕТ доступа к контексту экземпляра компонента `this`,
		// так как к моменту вызова экземпляр ещё не создан!
	},
	<bg-code>beforeRouteUpdate</bg-code>(to, from, next) {
		// вызывается когда маршрут, что рендерит этот компонент изменился,
		// но этот компонент будет повторно использован в новом маршруте.
		// Например, для маршрута с динамическими параметрами `/foo/:id`, когда мы
		// перемещаемся между `/foo/1` и `/foo/2`, экземпляр того же компонента `Foo`
		// будет использован повторно, и этот хук будет вызван когда это случится.
		// Также имеется доступ в `this` к экземпляру компонента.
	},
	<bg-code>beforeRouteLeave</bg-code>(to, from, next) {
		// вызывается перед переходом от пути, соответствующего текущему компоненту;
		// имеет доступ к контексту экземпляра компонента `this`.
	}
}
</code></pre>





<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Полная цепочка обработки навигации</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
 <ol class="list-num">
 	<li>Срабатывание навигации</li>
 	<li>Вызов leave-хуков в деактивируемых компонентах</li>
 	<li>Вызов глобальных <code class="txt">beforeEach</code> хуков</li>
 	<li>Вызов <code class="txt">beforeRouteUpdate</code> хука в переиспользуемых компонентах</li>
 	<li>Вызов <code class="txt">beforeEnter</code> в конфигурации маршрута</li>
 	<li>Разрешение асинхронных компонентов для маршрута</li>
 	<li>Вызов <code class="txt">beforeRouteEnter</code> в активируемых компонентах</li>
 	<li>Вызов глобальных <code class="txt">beforeResolve</code> хуков</li>
 	<li>Навигация подтверждена</li>
 	<li>Вызов глобальных <code class="txt">afterEach</code> хуков</li>
 	<li>Выполняется обновление DOM</li>
 	<li>Вызов коллбэков, переданных в <code class="txt">next</code> в <code class="txt">beforeRouteEnter</code> хуке с созданными экземплярами</li>
 </ol>
