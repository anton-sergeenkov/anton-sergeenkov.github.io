<h2>nextTick - асинхронная очередь обновлений</h2>

<ul class="list-point">
	<li><bg-define>nextTick</bg-define> - работа с обновлённым DOM после изменения данных</li>
	<li>Во Vue обновление DOM выполняется асинхронно. Каждый раз, когда обнаруживается изменение в данных, создаётся очередь, которая используется в качестве буфера для этого и последующих изменений, происходящих в текущей итерации (<code class="txt">“tick”</code>) цикла событий. Если один и тот же наблюдатель срабатывает несколько раз, в очередь он попадёт всё равно лишь единожды. Благодаря использованию буфера и устранению дубликатов, вычисления и манипуляции DOM сводятся к минимуму. В следующей итерации цикла событий Vue разбирает очередь и выполняет актуальные (уже не содержащие дубликатов) обновления. На низком уровне для асинхронной постановки задач в очередь используются <code class="txt">Promise.then</code> и <code class="txt">MessageChannel</code>, а если они недоступны, то <code class="txt">setTimeout(fn, 0)</code></li>

	<li>Итак, если выполнить код <code class="txt">vm.someData = 'value'</code>, компонент не будет отрисован сразу же. Он обновится в следующей итерации при разборе очереди. Чтобы выполнить какой-нибудь код только после того, как завершится обновление DOM, можно передать коллбэк в метод <code class="txt">Vue.nextTick(callback)</code> после изменения данных. Он будет вызван после обновления DOM</li>
</ul>

<pre><code class="html">
&lt;div id="example"&gt;{{ message }}&lt;/div&gt;
</code></pre>

<pre><code class="js">
var vm = new Vue({
	el: '#example',
	data: {
		message: '123'
	}
})
vm.message = 'новое сообщение'; // изменяем данные (DOM еще не обновлён)
vm.$el.textContent === 'новое сообщение'; // false
Vue.<bg-code>nextTick</bg-code>(function () {
	vm.$el.textContent === 'новое сообщение'; // true (DOM обновлён)
})
</code></pre>

<!------------------------------------------------------------->
<h4>Метод экземпляра</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Существует также метод экземпляра <code class="txt">vm.$nextTick()</code>, особенно подходящий для использования внутри компонентов, поскольку он не требует обращения к глобальной переменной <code class="txt">Vue</code>, а также автоматически связывает контекст <u>this</u> коллбэка с текущим экземпляром Vue</li>
</ul>

<pre><code class="js">
Vue.component('example', {
	template: '{{ message }}',
	data: function () {
		return {
			message: 'не обновлено'
		}
	},
	methods: {
		updateMessage: function () {
			this.message = 'обновлено'
			console.log(this.$el.textContent) // => 'не обновлено'
			this.<bg-code>$nextTick</bg-code>(function () {
				console.log(this.$el.textContent) // => 'обновлено'
			})
		}
	}
})
</code></pre>

<!------------------------------------------------------------->
<h4>Использование с Promise</h4>
<!------------------------------------------------------------->
<pre><code class="js">
Vue.nextTick()
	.then(function () {
		// DOM обновлён
	})
</code></pre>

<!------------------------------------------------------------->
<h4>Использование с async/await</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Поскольку <code class="txt">$nextTick()</code> возвращает промис, вы можете достичь того же, используя синтаксис <code class="txt">async/await</code> (ES2016)</li>
</ul>

<pre><code class="js">
methods: {
	updateMessage: async function () {
		this.message = 'обновлено'
		console.log(this.$el.textContent) // => 'не обновлено'
		await this.<bg-code>$nextTick</bg-code>()
		console.log(this.$el.textContent) // => 'обновлено'
	}
}
</code></pre>