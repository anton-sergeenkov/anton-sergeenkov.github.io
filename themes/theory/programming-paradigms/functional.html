<h2>Функциональное программирование</h2>

<ul class="list-point">
    <li><bg-define>Функциональное программирование</bg-define> - последовательный вызов набора функций</li>
    <li>Процесс вычисления трактуется как вычисление значений функций в математическом понимании</li>
    <li>Специфические возможности по работе с функциями: передача функций другим функциям в качестве аргументов и возврат функций из других функций</li>
    <li>Предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций</li>
    <li>Описывает математические отношения между данными и целью</li>
    <li>Один из видов декларативного программрования</li>
    <li>Нужно что-то посчитать, но функция которая это считает возвращает не результат, а рецепт для вычисления результата, т.е. возвращает функцию, которая посчитает результат</li>
    <li>Методы для функционального программирования в JavaScript: arr.map, arr.forEach, arr.filter, arr.sort, arr.concat, arr.join, arr.reduce, arr.reduceRight, Object.assign, Object.keys()</li>
</ul>

<b class="margin-top">Что не используется</b>
<ol class="list-num">
    <li>Хранение состояния (нет переменных и операторов присваивания)</li>
</ol>

<b class="margin-top">Принципы</b>
<ol class="list-num">
    <li>При вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных</li>
    <li>То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций</li>
    <li>Не нужно описывать шаги, нужно определить функцию, выполнить функции последовательно и в результате выполнения набор функций будет получен результат</li>
    <li>Разделение функций и данных</li>
</ol>

<b class="margin-top">Концепции</b>
<ol class="list-num">
    <li><bg-define>Чистые функции</bg-define> (pure functions) - функция, которая при одинаковых аргументах всегда возвращает одни и те же значения и не имеет видимых побочных эффектов (side effects) ввода-вывода и памяти. Зависят только от своих параметров и возвращают только свой результат. Не влияют на состояние программы</li>
    <ul class="list-point">
        <b>Условия</b>
        <li><u>Детерменированная</u> - для одного и того же набора входных значений возвращает одинаковый результат</li>
        <li><u>Без побочных эффектов</u> В императивных языках некоторые функции в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывая их обработчики. Они называются функциями с побочными эффектами</li>
        <li>Для замены циклов в JS можно использовать map и reduce</li>
    </ul>

    <li><bg-define>Функции высшего порядка</bg-define> - функция принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата</li>

    <li><bg-define>Функции первого класса</bg-define> - функция трактуются как объект, то есть может быть передана другим функциям и ее можно вернуть из функций. Так же ее можно присваивать переменным let func = function(){}</li>

    <li><bg-define>Каррирование функций</bg-define> - все функции могут быть от одного аргумента. Преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному</li>

    <li><bg-define>Рекурсия</bg-define> В функциональных языках цикл обычно реализуется в виде рекурсии. Рекурсивные функции вызывают сами себя, позволяя операции выполняться снова и снова</li>

    <li><bg-define>Лямбда-исчисление</bg-define> - механизм «анонимных функций» - callback-функций, которые можно определить прямо в том месте, где они используются, и которые имеют доступ к локальным переменным текущей функции</li>

    <li><bg-define>Иммутабельность</bg-define> - свойство объектов не изменяться (н-р строка. строку нельзя поменять на месте, для изменения нужно создать новую строку). Принцип иммутабельности в ФП должен применяется для другими страктурами данных (списки, словари). Иммутабельный список - список в который нельзя добавить / удалить элемент, можно только итерироваться по ним. Можно создать новый список который содежит все элементы +1, при этом старый остается валадным</li>

    <li><bg-define>Замыкания</bg-define></li>
</ol>
