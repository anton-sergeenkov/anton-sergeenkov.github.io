<h2>Объектно-ориентированное программирование</h2>

<ul class="list-point">
    <li><u-text-define>Объектно-ориентированное программирование</u-text-define> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>1. Инкапсуляция</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-underline>Инкапсуляция</u-text-underline></li>
    <ul class="list-point">
        <li>свойство системы, позволяющее объединить данные и методы, работающие с ними</li>
        <li>скрыть детали реализации от пользователя</li>
        <li>механизм, позволяющий обеспечить согласованность и целостность данных объекта или класса и защитить их некорректного использования или повреждения</li>
        <li>механизм языка, позволяющий ограничить доступ одних компонентов программы к другим</li>
        <li>группировка свойств и методов в один класс</li>
        <li>заключение данных и методов обработки этих данных в единый компонент - объект</li>
    </ul>
    <hr>

    <li><u-text-underline>Инкапсуляция</u-text-underline> – отделение и защита внутреннего интерфейса от внешнего</li>
    <li><u>Внутренний интерфейс</u> – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными»</li>
    <li><u>Внешний интерфейс</u> – это свойства и методы, доступные снаружи объекта, их называют «публичными»</li>
    <hr>

    <li><b>Задача:</b> обеспечить целостность данных. Защитить данные от некорректного использования</li>
    <hr>


    - скрыты и защищены от пользователя
    - Интерфейс класса - публичный набор элементов класса, через который происходит управление внутренней реализации
    - Обращение к переменным через геттеры и сеттеры
    - Свойство системы объединять данные и методы работы с ними в класс -Инкапсуляция.  Разграничение доступа частей программы к компонентам друг друга - сокрытие


    <li>Мы обращаемся с объектами как с единой сущностью, а не как с набором отдельных полей и методов, тем самым скрываем и защищаем реализацию класса. Если клиентский код не знает ничего, кроме публичного интерфейса, он не может зависеть от деталей реализации</li>
    <li>Обычно прячут все поля класса и предоставляют набор методов для работы с ними. У разработчиков есть универсальный интерфейс для доступа к свойствам, им не важна какая реализация метода</li>
</ul>

<pre><code class="js">
public class Car {
    public void startMoving() {
        turnKey();
        startEngine();
    }
    private void turnKey() {...}
    private void startEngine() {...}
}
</code></pre>

<!------------------------------------------------------------->
<h4>Модификаторы доступа Java</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-code-list>public</u-code-list> - видны из всего приложения</li>
    <li><u-code-list>protected</u-code-list> - видны внутри класса, пакета и наследников</li>
    <li><u-code-list>package</u-code-list> - видны только из текущего пакета</li>
    <li><u-code-list>private</u-code-list> - видны внутри класса. запрещает доступ из подкласса</li>
</ul>






<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>2. Наследование</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-point">
    <li><u-text-define>Наследование</u-text-define> - описание нового класса на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс - потомком, наследником, дочерним или производным классом</li>
    <li>Наследование транзитивно: класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса (Object). Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию</li>
</ol>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>3. Полиморфизм</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-point">
    <li><u-text-define>Полиморфизм</u-text-define> - возможность объектов с одинаковой спецификацией иметь различную реализацию. «Один интерфейс, множество реализаций». Переопеределение методов у дочерних классов. Возможность единообразно обрабатывать объекты с различной реализацией при условии наличия общего интерфейса</li>

    <li></li>
</ol>

<pre><code class="js">
// Динамический полиморфизм
// Один и тот же метод (voice) в зависимости от реализации выводит различные значения
animal = new Dog();
animal.voice();

animal = new Cat();
animal.voice();
</code></pre>

<pre><code class="js">
// Статический полиморфизм
// Метод с одинаковым названием, но различными параметрами
public class Animal {
    public void voice() {...}
    public void voice(String s) {...}
    public void voice(int a) {...}
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>4. Абстракция</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-point">
    <li><u-text-define>Абстракция</u-text-define> способ представления объекта в программе, позволяющий работать с объектами не вдаваясь в особенности их реализации</li>
    <li>Инкапсуляция помогает реализовать абстракцию</li>
    <li>Абстракция - объекты из окружающиего мира которые мы хотим описать. Выделяем только черты, необходимые для решения задачи. Н-р: есть животное, но для конкретной задачи нужны не все характеристики, а только "вес" и "возраст"</li>
</ol>
