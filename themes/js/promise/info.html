<h2>Promise</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Информация</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><u-text-define>Promise</u-text-define> - специальный объект, который используются для обработки результатов асинхронных операций. Промис хранит своё состояние, текущий результат (если есть) и коллбэки</li>
	<li><u-text-define>Промисификация</u-text-define> - обертка над асинхронным функционалом, возвращающая промис</li>
	<li><u-text-define>Чейнинг (chaining)</u-text-define> - возможность стоить асинхронные цепочки из промисов .then…then…then, в каждый следующий then переходит результат от предыдущего</li>
</ul>

<!------------------------------------------------------------->
<h4>Состояния Promise</h4>
<!------------------------------------------------------------->
<ol class="list-num">
	<li><u>pending</u> - ожидание (выполняется)</li>
	<li><u>fulfilled</u> - выполнено успешно</li>
	<li><u>rejected</u> - отклонено (выполнено с ошибкой)</li>
</ol>

<!------------------------------------------------------------->
<h4>Навешиваемые коллбэки</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u>onFulfilled</u> – срабатывают, когда promise в состоянии «выполнен успешно»</li>
	<li><u>onRejected</u> – срабатывают, когда promise в состоянии «выполнен с ошибкой»</li>
</ul>

<!------------------------------------------------------------->
<h4>Комментарии</h4>
<!------------------------------------------------------------->
<ul class="list-point">

	<li>При создании <u-code-text>new Promise((resolve, reject) => ...)</u-code-text> автоматически запускается функция-аргумент, которая должна вызвать <u-code-text>resolve(result)</u-code-text> при успешном выполнении и <u-code-text>reject(error)</u-code-text> – при ошибке</li>
	<li><u>Promise</u> после <u-code-text>reject/resolve</u-code-text> - неизменны. Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда</li>
	<li>Если говорить о взаимодействии с API, то <u-code-text>catch</u-code-text> используется для обработки http статусов <u>4xx 5xx</u>, <u-code-text>then</u-code-text> это статусы <u>2xx</u></li>
	<li>Отсутствии внешнего <u-code-text>catch</u-code-text> не останавливает выполнение скрипта. Когда обработчик в промисах делает <u-code-text>throw</u-code-text> – в данном случае, при ошибке запроса, то такая ошибка не останавливает выполнение скрипта и не выводится в консоли. Она просто будет передана в ближайший следующий обработчик <u-code-text>onRejected</u-code-text></li>
	
	<li>Каждая последующая функция будет вызвана, когда предыдущий промис «зарезолвится», и вызвана она будет с результатом работы предыдущего промиса</li>
	<li>Состояние промиса изменяется 1 раз</li>
	<li>.then и .catch возвращают новый промис, поэтому их можно использовать по цепочке</li>
	<li>.then и .catch подписка на изменение промиса</li>
</ul>