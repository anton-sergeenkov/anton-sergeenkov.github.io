<h2>Параллельное выполнение Promise.all и Promise.race</h2>

<ul class="list-point">
	<li><bg-methods>Promise.all</bg-methods><bg-arguments>(iterable)</bg-arguments> - получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов</li>
	<li>Если какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются</li>
</ul>

<ul class="list-point">
	<li><bg-methods>Promise.race</bg-methods><bg-arguments>(iterable)</bg-arguments> - получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис</li>
	<li>Результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются</li>
</ul>

<h4>Пример #1</h4>
<pre><code class="js">
var promise1 = new Promise(function(resolve, reject) {
    resolve('promise1');
});
var promise2 = new Promise(function(resolve, reject) {
    resolve('promise2');
});

Promise.<u-code>all</u-code>([promise1, promise2])
    .then(value => console.log(value)); // [ 'promise1', 'promise2' ]
Promise.<u-code>race</u-code>([promise1, promise2])
    .then(value => console.log(value)); // promise1
</code></pre>

<h4>Пример #2</h4>
<pre><code class="js">
function go(num) {
	return new Promise(function(resolve, reject) {
		setTimeout(() => resolve(num), 1000);
	})
}

let p1 = go(1);
let p2 = go(2);
let p3 = go(3);

// выполняет все обещания даже если ошибка в первом
// но закончится всё равно ошибкой
Promise.all([p1, p2, p3])
	.then(value => console.log(value));

// получить результат от первого
Promise.race([p1, p2, p3])
	.then(value => console.log(value));
</code></pre>
