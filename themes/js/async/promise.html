<h2>Promise (ES6)</h2>

<ul class="list">
	<li><bg-define>Promise</bg-define> - специальный объект, который хранит своё состояние, текущий результат (если есть) и коллбэки</li>
	<li><bg-define>Промисификация</bg-define> - обертка над асинхронным функционалом, возвращающая промис</li>
	<li><bg-define>Чейнинг (chaining)</bg-define> - цепочки промисов .then…then…then, в каждый следующий then переходит результат от предыдущего</li>
	<li class="margin-top"><b>Состояния Promise</b></li>
	<ul class="list-point">
		<li><u>pending</u> - ожидание (выполняется)</li>
		<li><u>fulfilled</u> - выполнено успешно</li>
		<li><u>rejected</u> - выполнено с ошибкой</li>
	</ul>
	<li class="margin-top"><b>На promise можно навешивать коллбэки двух типов</b></li>
	<ul class="list-point">
		<li><u>onFulfilled</u> – срабатывают, когда promise в состоянии «выполнен успешно»</li>
		<li><u>onRejected</u> – срабатывают, когда promise в состоянии «выполнен с ошибкой»</li>
	</ul>
</ul>

<ul class="list-point">
	<li>При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, которая должна вызвать resolve(result) при успешном выполнении и reject(error) – при ошибке</li>
	<li><bg-code>Promise</bg-code> после <bg-code>reject/resolve</bg-code> - неизменны. Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда</li>
	<li>Если говорить о взаимодействии с API, то <bg-code>catch</bg-code> используется для обработки http статусов <u>4xx 5xx</u>, <bg-code>then</bg-code> это статусы <u>2xx</u></li>
	<li>Отсутствии внешнего .catch не останавливает выполнение скрипта. Когда обработчик в промисах делает <bg-code>throw</bg-code> – в данном случае, при ошибке запроса, то такая ошибка не останавливает выполнение скрипта и не выводится в консоли. Она просто будет передана в ближайший следующий обработчик onRejected</li>
</ul>

<!------------------------------------------------------>
<h3>Методы</h3>
<!------------------------------------------------------>

<pre><code class="js light">
<table>

	<tr><td><bg-methods>new Promise</bg-methods><bg-arguments>(executor)</bg-arguments></td><td>  // конструктор промиса</td></tr>
	<tr><td><em>	&#8226; resolve(result)</em></td><td>  // результат передается аргументом в .then</td></tr>
	<tr><td><em>	&#8226; reject(error)</em></td><td>  // ошибка передается аргументом в .catch</td></tr>

	<tr><td><bg-methods>.then</bg-methods><bg-arguments>(onFulfilled)</bg-arguments></td><td>  // выполняется обработчик onFulfilled</td></tr>
	<tr><td><em>	&#8226; result</em></td><td>  // функция или код при успешном выполнении</td></tr>

	<tr><td><bg-methods>.catch</bg-methods><bg-arguments>(onRejected)</bg-arguments></td><td>  // выполняется обработчик onRejected</td></tr>
	<tr><td><em>	&#8226; error</em></td><td>  // функция или код при неуспешном выполнении</td></tr>

	<tr><td><bg-methods>Promise.all</bg-methods><bg-arguments>(iterable)</bg-arguments></td><td>  // возвращает промис, который ждёт, пока все переданные промисы завершатся</td></tr>
	<tr><td><em>	&#8226; iterable</em></td><td>  // [p1, p2, p3] промисы</td></tr>

	<tr><td><bg-methods>Promise.race</bg-methods><bg-arguments>(iterable)</bg-arguments></td><td>  // результатом будет только первый успешно выполнившийся промис из списка</td></tr>
	<tr><td><em>	&#8226; iterable</em></td><td>  // [p1, p2, p3] промисы</td></tr>

	<tr><td><bg-methods>Promise.resolve</bg-methods><bg-arguments>(value)</bg-arguments></td><td>  // создаёт успешно выполнившийся промис с результатом value</td></tr>
	<tr><td><em>	&#8226; value</em></td><td>  // результат</td></tr>

	<tr><td><bg-methods>Promise.reject</bg-methods><bg-arguments>(error)</bg-arguments></td><td>  // создаёт уже выполнившийся промис с ошибкой error</td></tr>
	<tr><td><em>	&#8226; value</em></td><td>  // ошибка</td></tr>

</table></code></pre>

<!------------------------------------------------------>
<h3>Создание Promise</h3>
<!------------------------------------------------------>
<pre><code class="js">
functin functionAsync() {
	var promise = new <bg-code>Promise</bg-code>(function(resolve, reject) {
		// любые асинхронные операции
		// resolve(результат) при успешном выполнении
		// reject(ошибка) при ошибке
		const isSuccess = (Math.random() * 100) <= 70;
	    if (isSuccess) {
	        <bg-code>resolve</bg-code>('ok');
	    } else {
	        <bg-code>reject</bg-code>(new Error('Api error')); // аналогично
	        throw new Error('Api error');   // аналогично
	    }
	});
	return promise;
}
</code></pre>

<pre><code class="js">
functionAsync()
	// resolve
    <bg-code>.then</bg-code>(result => {
        console.log(result);
    })
    // reject
    <bg-code>.catch</bg-code>(error => console.error(error)); // Error: Api error
    // .catch(error => console.error(error.message)); // Api error
</code></pre>

<!------------------------------------------------------>
<h3>Обработка Promise в асинхронных операциях</h3>
<!------------------------------------------------------>
<h4>Первый вариант (один then)</h4>
<pre><code class="js">
functionAsync()
	<bg-code>.then</bg-code>(functionResolve, functionReject);
	// functionResolve - функция, которая сработает если обещание выполняется
	// functionReject  - функция, которая сработает если обещание не будет выполнена
</code></pre>

<h4>Второй вариант (несколько then)</h4>
<pre><code class="js">
functionAsync()
	<bg-code>.then</bg-code>(functionResolve1)
	<bg-code>.then</bg-code>(functionResolve2)
	<bg-code>.catch</bg-code>(functionReject);
</code></pre>

<h4>Третий вариант (вызванная функция)</h4>
<pre><code class="js">
functionAsync()
	<bg-code>.then</bg-code>(functionResolve1()) // вызванная функция пропускается
</code></pre>

<!------------------------------------------------------>
<h3>«Чейнинг» (цепочки промисов)</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><u>«Чейнинг» (chaining)</u> - цепочки промисов. При чейнинге, то есть последовательных вызовах <u>.then…then…then</u>, в каждый следующий then переходит результат от предыдущего. Если очередной <u>then вернул промис</u>, то далее по цепочке будет передан не сам этот промис, а его результат. </li>
	<li>Если then возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать</li>
	<li>Общее правило: если внутри then стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис</li>
</ul>

<pre><code class="js">
function functionAsync1() {
	var promise = new Promise(function(resolve, reject) {
	    resolve('promise1');
	});
	return promise;
}
function functionAsync2() {
	var promise = new Promise(function(resolve, reject) {
	    resolve('promise2');
	});
	return promise;
}
functionAsync1()
    <bg-code>.then</bg-code>(res => console.log(res)) // promise1
    <bg-code>.then</bg-code>(functionAsync2)
    <bg-code>.then</bg-code>(res => console.log(res)) // promise2
</code></pre>

<!------------------------------------------------------>
<h3>Внутренние свойства new Promise(executor)</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<b>new Promise(executor)</b>
	<li><u>PromiseState</u>            - состояние (вначале «pending»)</li>
	<li><u>PromiseResult</u>           - результат (при создании значения нет)</li>
	<li><u>PromiseFulfillReactions</u> - список функций-обработчиков успешного выполнения</li>
	<li><u>PromiseRejectReactions</u>  - список функций-обработчиков ошибки</li>	
</ul>

<ul class="list-point">
	<li>1. Когда функция-<bg-code>executor</bg-code> вызывает reject или resolve, то <bg-code>PromiseState</bg-code> становится"resolved" или "rejected", а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь <bg-code>"PromiseJobs"</bg-code></li>
	<li>2. Все функции-обработчики из очереди <bg-code>"PromiseJobs"</bg-code> выполняются асинхронно, один за другим, по завершении текущего кода</li>
	<li>3. Исключение из этого правила – если resolve возвращает другой Promise. Тогда дальнейшее выполнение ожидает его результата (в очередь помещается специальная задача), и функции-обработчики выполняются уже с ним</li>
	<li>4. В конце срабатывает общий обработчик <bg-code>genericError</bg-code>, который перехватывает любые ошибки</li>
</ul>

<pre><code class="js">
// промис выполнится сразу же
var promise = new Promise((resolve, reject) => resolve(1));
promise.then( function f1(result) {
	alert(result); // 1
	return 'f1';
})
promise.then( function f2(result) {
	alert(result); // 1
	return 'f2';
})
// PromiseState            - "resolved"
// PromiseResult           - 1
// PromiseFulfillReactions - [f1, f2]
// PromiseRejectReactions  - [Thrower, Thrower] Thrower – стандартная внутренняя функция, которая автоматически используется, если второй обработчик (reject) не указан

// В примере не используется чейнинг, обработчики добавляются именно на один и тот же промис
// Все функции из списка обработчиков вызываются с результатом промиса, одна за другой
// Никакой передачи результатов между обработчиками в рамках одного промиса нет, а сам результат промиса (PromiseResult) после установки не меняется
</code></pre>

<!------------------------------------------------------>
<h3>Параллельное выполнение Promise.all и Promise.race</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-methods>Promise.all</bg-methods><bg-arguments>(iterable)</bg-arguments> - получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов</li>
	<li>Если какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются</li>
</ul>

<ul class="list-point">
	<li><bg-methods>Promise.race</bg-methods><bg-arguments>(iterable)</bg-arguments> - получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис</li>
	<li>Результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются</li>
</ul>

<h4>Пример #1</h4>
<pre><code class="js">
var promise1 = new Promise(function(resolve, reject) {
    resolve('promise1');
});
var promise2 = new Promise(function(resolve, reject) {
    resolve('promise2');
});

Promise.<bg-code>all</bg-code>([promise1, promise2])
    .then(value => console.log(value)); // [ 'promise1', 'promise2' ]
Promise.<bg-code>race</bg-code>([promise1, promise2])
    .then(value => console.log(value)); // promise1
</code></pre>

<h4>Пример #2</h4>
<pre><code class="js">
function go(num) {
	return new Promise(function(resolve, reject) {
		setTimeout(() => resolve(num), 1000);
	})
}

let p1 = go(1);
let p2 = go(2);
let p3 = go(3);

// выполняет все обещания даже если ошибка в первом
// но закончится всё равно ошибкой
Promise.all([p1, p2, p3])
	.then(value => console.log(value));

// получить результат от первого
Promise.race([p1, p2, p3])
	.then(value => console.log(value));
</code></pre>

<!------------------------------------------------------>
<h3>Promise.resolve(value) и Promise.reject(error)</h3>
<!------------------------------------------------------>
<ul class="list-point">
	<li><bg-methods>Promise.resolve</bg-methods><bg-arguments>(value)</bg-arguments> - создаёт успешно выполнившийся промис с результатом value</li>
	<li>Promise.resolve используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть</li>
</ul>

<pre><code class="js">
// аналогичен конструкции
new Promise((resolve) => resolve(value))
Promise.resolve(window.location) // начать с этого значения
	.then(httpGet) // вызвать для него httpGet
	.then(alert) // и вывести результат
</code></pre>

<ul class="list-point">
	<li><bg-methods>Promise.reject</bg-methods><bg-arguments>(error)</bg-arguments> - создаёт уже выполнившийся промис с ошибкой error</li>
	<li>Метод Promise.reject используется очень редко, т.к. ошибка возникает обычно не в начале цепочки, а в процессе её выполнения</li>
</ul>

<pre><code class="js">
Promise.reject(new Error("..."))
	.catch(alert) // Error: ...
</code></pre>

<!------------------------------------------------------>
<h3>Примеры</h3>
<!------------------------------------------------------>
<h4>Пример #1</h4>
<pre><code class="js">
function applyForVisa(document) {
	console.log('Обработка заявления...');
	let promise = new Promise(function(resolve, reject) {
		setTimeout(function() {
			Math.random() > 0 ? resolve({}) : reject('В визе отказано');
		}, 2000);
	});
	return promise;
}
function getVisa(visa) {
	console.info('Виза получена');
	return new Promise(function(resolve, reject) {
		setTimeout(() => resolve(visa), 2000);
	});
}
function bookHotel(visa) {
	console.log(visa);
	console.log('Бронируем отель');
	return Promise.resolve(visa);
	// return Promise.reject('Нет мест');
}
function buyTickets(booking) {
	console.log('Покупаем билеты');
	console.log('Бронь', booking);
}
applyForVisa({})
	.then(getVisa)
	.then(bookHotel)
	.then(buyTickets)
	.catch(error => console.error(error))
	.then(() => console.log('Выведется в любом случае'));
</code></pre>
