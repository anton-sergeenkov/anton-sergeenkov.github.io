<h2>Flux & Redux</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Flux</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Flux-архитектура</u-text-define> - архитектурный подход или набор шаблонов программирования для построения пользовательского интерфейса веб-приложений, сочетающийся с реактивным программированием и построенный на однонаправленных потоках данных</li>
</ul>

<ol class="list-num">
	<b>Методология Flux состоит из 4 частей</b>
	<li><u>View</u> (компоненты)</li>
	<li><u>Action</u> (события)</li>
	<li><u>Dispatcher</u> - сообщает Store о каком-то событии и передает информацию</li>
	<li><u>Store</u> (хранилище) - задача ограничить доступ к состоянию через определенный интерфейс</li>
</ol>

<p class="center">
	<u-code-text>View</u-code-text> -> 
	<u-code-text>Action</u-code-text> -> 
	<u-code-text>Dispatcher</u-code-text> -> 
	<u-code-text>Store</u-code-text> -> 
	<u-code-text>View</u-code-text>
</p>

<hr>

<ul class="list-point">
	<li><b>Достоинства: </b>сложно случайно измененить состояние. Если что-то произойдет, то ясно где искать ошибку</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Redux</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<u-link-wrapper>
    <a href="https://getinstance.info/articles/react/learning-react-redux/" target="_blank">Новый уровень React: Redux</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>Redux</u-text-define> - это инструмент управления состоянием приложения. Он подходит для одностраничных приложений, в которых управление состоянием может со временем становиться сложным. Redux не связан с каким-то определенным фреймворком, и хотя разрабатывался для React, может использоваться с Angular или jQuery</li>

    <li>В React «однонаправленный поток данных» - поток данных проходит в одном направлении, от родителя к ребенку. При этом не очевидно, как два компонента, не связанные отношением родитель-ребенок, будут взаимодействовать между собой</li>

    <li>Redux предлагает хранить все состояние приложения в одном месте, называемом <u>«store»</u> («хранилище»). Компоненты «отправляют» изменение состояния в хранилище, а не напрямую другим компонентам. Компоненты, которые должны быть в курсе этих изменений, «подписываются» на хранилище</li>
</ul>

<ol class="list-num">
    <b>Принципы</b>
    <li>Единственный источник истины</li>
    <li>Состояние доступно только для чтения</li>
    <li>Изменения делаются «чистыми» функциями</li>
</ol>

<v-pre-npm>
npm i --save <u-code-npm>redux</u-code-npm>
</v-pre-npm>

<u-link-wrapper>
	<a href="https://redux.js.org/introduction/getting-started" target="_blank">Документация</a>
</u-link-wrapper>

<ul class="list-point">
	<li><u-text-define>Redux</u-text-define> - предсказуемый контейнер состояния для JS приложений</li>
</ul>

<!------------------------------------------------------------->
<h4>Store</h4>
<!------------------------------------------------------------->
<ol class="list-num">
    <li><u class="accent">Store</u> - помещаются все данные приложения. Store иммутабельный: мы можем создавать всегда только новую копию данных, а не менять старое состояние store. ТОЛЬКО ОДИН объект Store. Store, "объединяет" Reducer и Actions</li>
</ol>

<pre><code class="js">
const store = <u-code>createStore</u-code>(reducerFunction); // создание store
store.<u-code>getState</u-code>();                           // получить состояние store
store.<u-code>subscribe</u-code>();                          // подписка на изменение store
store.<u-code>dispatch</u-code>({                            // событие обновления состояния store
    type: 'тип_события', 
    payload: 'данные' 
}); 
</code></pre>

<!------------------------------------------------------------->
<h4>Принципы функционального программирования в Redux</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u>Чистые функции (pure functions)</u> - функция возвращаюшая знечение, зависомое только от получаемых аргументов</li>
	<li><u>Неизменность данных (immutability)</u></li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Структура файлов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Rails Style</li>
    <li>Redux Ducks</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример использования Redux</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js border">
import { createStore } from 'redux';

function changeStore(state = [], action) {
    // console.log(action);
    // => {type: "@@redux/INITn.9.1.1.y.1"}          // всегда когда redux инициализирован
    // => {type: "ADD_PRODUCT", payload: "Product1"} // добавленный action

    if (action.type === 'ADD_PRODUCT') {
        return [
            ...state,
            action.payload
        ];
    }
    return state;
}

const store = <u-code>createStore</u-code>(changeStore);

store.<u-code>subscribe</u-code>(() => {
    console.log('subscribe', store.<u-code>getState</u-code>());
});

store.<u-code>dispatch</u-code>({ type: 'ADD_PRODUCT', payload: 'Product1' });
store.<u-code>dispatch</u-code>({ type: 'ADD_PRODUCT', payload: 'Product2' });
</code></pre>

