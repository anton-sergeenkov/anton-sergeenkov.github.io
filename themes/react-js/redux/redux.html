<h2>Redux</h2>
 
<pre class="npm"><code class="bash">
npm i --save <bg-npm>redux</bg-npm>
</code></pre>

<u-link-wrapper>
	<a href="https://redux.js.org/introduction/getting-started" target="_blank">Документация</a>
</u-link-wrapper>

<ul class="list-point">
	<li><u-text-define>Redux</u-text-define> - предсказуемый контейнер состояния для JS приложений</li>
</ul>

<ol class="list-num">
	<li><u class="accent">Store</u> - помещаются все данные приложения. Store иммутабельный: мы можем создавать всегда только новую копию данных, а не менять старое состояние store. ТОЛЬКО ОДИН объект Store. Store, "объединяет" Reducer и Actions</li>
	<li><u class="accent">Reducer</u> (преобразователь) - чистая функция, которая берет на вход предыдущее состояние и action и возвращает новое состояние. Не модифицирует данные, а всегда возвращает новые данные</li>
	<li><u class="accent">Actions</u> - изменение состоние происходит с помощью действий</li>
</ol>

<ul class="list-point">
	<b>Принципы функционального программирования в Redux</b>
	<li><u>Чистые функции (pure functions)</u> - функция возвращаюшая знечение, зависомое только от получаемых аргументов</li>
	<li><u>Неизменность данных (immutability)</u></li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>1. State</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
const store = <u-code>createStore</u-code>(reducerFunction); // создание store
store.<u-code>getState</u-code>();                           // получить состояние store
store.<u-code>subscribe</u-code>();                          // подписка на изменение store
store.<u-code>dispatch</u-code>({                            // событие обновления состояния store
	type: 'тип_события', 
	payload: 'данные' 
}); 
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>2. Actions</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Actions</u-text-define> - объект. Описывает факт, что что-то произошло, но не указывает, как состояние приложения должно измениться в ответ (Reducer)</li>
    <li><u class="accent">type</u> - обязательное поле</li>
    <li><u class="accent">payload</u> - свойство в которое помещаются все данные, которые передаются вместе 
    с действием</li>
    <li><u-text-define>ActionsCreator</u-text-define> - функция для вызова Action</li>
</ul>

<pre><code class="js"><code-type>js</code-type>
const GET_PHOTOS = 'GET_PHOTOS'

// ActionsCreator
const getPhotos = (year) => ({
    type: GET_PHOTOS,
    payload: 2019
})
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>3. Reducer</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Reducer</u-text-define> - указывает, как состояние приложения должно измениться в ответ на Action</li>
    <li><u-text-define>Reducer Composition</u-text-define> - фундаментальный шаблон построения redux приложений: мы разбиваем наше глобальное состояние на кусочки, за каждый кусочек отвечает свой <u-code-text>reducer</u-code-text>. Кусочки объединяются в <u-code-text>rootReducer</u-code-text> Корневом Редьюсере</li>
    <li>Мы не мутировали наш state, мы создали новый state. В редьюсере, мы всегда должны возвращать новый объект, а не измененный предыдущий</li>
    <li>Объект, который мы возвращаем в редьюсере, далее с помощью функции <u-code-text>connect</u-code-text>, превратится в свойства для компонентов. Благодаря этому, внутри компонента <u-code-text>&lt;Component /&gt;</u-code-text>, мы сможем получить доступ к свойству <u-code-text>this.props.name_prop</u-code-text></li>
</ul>

<pre><code class="js"><code-type>js</code-type>
function page(state = initialState, action) {
    switch (action.type) {
        case GET_PHOTO_SUCCESS:
            return {...state, photos: action.payload}
        default:
            return state
    }
}
</code></pre>



<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js border">
import { createStore } from 'redux';

function changeStore(state = [], action) {
    if (action.type === 'ADD_PRODUCT') {
        return [
            ...state,
            action.payload
        ];
    }
    return state;
}

const store = <u-code>createStore</u-code>(changeStore);

store.<u-code>subscribe</u-code>(() => {
    console.log('subscribe', store.<u-code>getState</u-code>());
});

store.<u-code>dispatch</u-code>({ type: 'ADD_PRODUCT', payload: 'Product1' });
store.<u-code>dispatch</u-code>({ type: 'ADD_PRODUCT', payload: 'Product2' });
</code></pre>

<pre><code class="js">
function changeStore(state = [], action) {
    console.log(action);
    // => {type: "@@redux/INITn.9.1.1.y.1"}          // всегда когда redux инициализирован
    // => {type: "ADD_PRODUCT", payload: "Product1"} // добавленный action
}
</code></pre>
