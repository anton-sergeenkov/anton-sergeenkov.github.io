<h2>Обработка событий</h2>

<ul class="list-point">
	<li>События в React именуются в стиле camelCase вместо нижнего регистра</li>
	<li>С JSX вы передаёте функцию как обработчик события вместо строки</li>
</ul>

<v-two-code type="html;html" comment="react jsx;html">
<template v-slot:first>
&lt;button onClick={methodName}&gt;&lt;/button&gt;
</template>
<template v-slot:last>
&lt;button onclick="methodName()"&gt;&lt;/button&gt;
</template>
</v-two-code>

<ul class="list-point">
	<li>В React нельзя предотвратить обработчик события по умолчанию, вернув <code-text>false</code-text>. Нужно явно вызвать <code-text>preventDefault</code-text></li>
	<li>В приведённом выше коде <code-text>e</code-text> - это синтетическое событие</li>
</ul>

<v-two-code type="js;html" comment="react jsx;html">
<template v-slot:first>
function ActionLink() {
	function handleClick(e) {
		e.preventDefault();
		console.log('ok');
	}
	return (
		&lt;a href="#" onClick={handleClick}&gt;&lt;/a&gt;
	);
}
</template>
<template v-slot:last>
&lt;a href="#" onclick="console.log('ok'); return false"&gt;&lt;/a&gt;
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Потеря контекста</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Привязка с помощью bind</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>При обращении к <code-text>this</code-text> в JSX-колбэках необходимо учитывать, что методы класса в JavaScript по умолчанию не привязаны к контексту. Если вы забудете привязать метод <code-text>this.handleClick</code-text> и передать его в <code-text>onClick</code-text>, значение <code-text>this</code-text> будет undefined в момент вызова функции. Это часть того, как работают функции в JavaScript. Обычно, если ссылаться на метод без <code-text>()</code-text> после него, например, <code-text>onClick={this.handleClick}</code-text>, этот метод нужно привязать</li>
</ul>

<pre><code class="js">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			name: 'Tony'
		};
		// привязка обязательна для работы `this` в колбэке
		<bg-code>this.handleClick = this.handleClick.bind(this);</bg-code>
	}
	handleClick() {
		// без привязки в constructor не будет работать
		<bg-code>alert(this.state.name);</bg-code>
	}
	render() {
		return (
			&lt;button <bg-code>onClick={this.handleClick}</bg-code>&gt;Ok&lt;/button&gt;
		);
	}
}
</code></pre>

<!------------------------------------------------------------->
<h4>2. Эспериментальный синтаксис общедоступных полей классов</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Такой синтаксис доступен в Create React App по умолчанию</li>
	<li>Такой синтаксис гарантирует, что <code-text>this</code-text> привязан к <code-text>handleClick</code-text></li>
	<li><b>Предупреждение</b>: это экспериментальный синтаксис</li>
</ul>

<pre><code class="js">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			name: 'Tony'
		};
	}
	<bg-code>handleClick = () =&gt;</bg-code> {
		alert(this.state.name);
	}
	render() {
		return (
			&lt;button <bg-code>onClick={this.handleClick}</bg-code>&gt;Ok&lt;/button&gt;
		);
	}
}
</code></pre>

<!------------------------------------------------------------->
<h4>3. Стрелочные функции в колбэке</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Такой синтаксис гарантирует, что <code-text>this</code-text> привязан к <code-text>handleClick</code-text></li>
	<li>Проблема этого синтаксиса в том, что при каждом рендере компонента создаётся новый колбэк. Чаще всего это не страшно. Однако, если этот колбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова</li>
	<li>Рекомендуется делать привязку в конструкторе или использовать синтаксис полей классов, чтобы избежать проблем с производительностью</li>
</ul>

<pre><code class="js">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			name: 'Tony'
		};
	}
	handleClick() {
		alert(this.state.name);
	}
	render() {
		return (
			&lt;button <bg-code>onClick={(e) =&gt; this.handleClick(e)}</bg-code>&gt;Ok&lt;/button&gt;
		);
	}
}
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Передача аргументов в обработчики событий</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>В обоих случаях аргумент <code-text>e</code-text>, представляющий событие React, будет передан как второй аргумент после идентификатора. Используя стрелочную функцию, необходимо передавать аргумент явно, но с <code-text>bind</code-text> любые последующие аргументы передаются автоматически</li>
</ul>

<pre><code class="html">
&lt;!-- стрелочные функции --&gt;
&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Удалить строку&lt;/button&gt;
&lt;!-- Function.prototype.bind --&gt;
&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Удалить строку&lt;/button&gt;
</code></pre>