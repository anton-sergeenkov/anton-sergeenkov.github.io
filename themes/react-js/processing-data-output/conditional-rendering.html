<h2>Условный рендеринг</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Переменные-элементы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = { status: true };
	}
	render() {
		<bg-code-wrapper>
		const status = this.state.status;
		let text;
		if (status) {
			text = &lt;h2&gt;Yes&lt;/h2&gt;;
		} else {
			text = &lt;h2&gt;No&lt;/h2&gt;;
		}
		return (text);
		</bg-code-wrapper>
	}
};
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Встроенные условия if с логическим оператором &&</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Можно внедрить любое выражение в JSX, заключив его в фигурные скобки. Это правило распространяется и на логический оператор <code-text>&&</code-text> языка JavaScript, которым можно удобно вставить элемент в зависимости от условия</li>
	<li>В JavaScript выражение <code-text>true && expression</code-text> всегда вычисляется как <code-text>expression</code-text>, а выражение <code-text>false && expression</code-text> - как <code-text>false</code-text></li>
</ul>

<pre><code class="js">
render() {
	return (
		&lt;div&gt;
			{this.state.status &amp;&amp; &lt;h2&gt;Yes&lt;/h2&gt;}
		&lt;/div&gt;
	);
}
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Встроенные условия if-else с тернарным оператором</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Можно использовать тернарный оператор <code-text>condition ? true : false</code-text></li>
</ul>

<h4>Вариант 1</h4>
<pre><code class="js">
render() {
	return (
		&lt;div&gt;
			{this.state.status ? &lt;h2&gt;Yes&lt;/h2&gt; : &lt;h2&gt;No&lt;/h2&gt;}
		&lt;/div&gt;
	);
}
</code></pre>

<h4>Вариант 2</h4>
<pre><code class="js">
render() {
	return (
		&lt;div&gt;
			{this.state.status ? (
				&lt;h2&gt;Yes&lt;/h2&gt;
			) : ( 
				&lt;h2&gt;No&lt;/h2&gt;
			)}
		&lt;/div&gt;
	);
}
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Предотвращение рендеринга компонента</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>В редких случаях может потребоваться позволить компоненту спрятать себя, хотя он уже и отрендерен другим компонентом. Чтобы этого добиться, верните <code-text>null</code-text> вместо того, что обычно возвращается на рендеринг</li>
	<li>Сам факт возврата <code-text>null</code-text> из метода <code-text>render</code-text> компонента никак не влияет на срабатывание методов жизненного цикла компонента. Например, <code-text>componentDidUpdate</code-text> будет всё равно вызван</li>
</ul>

<pre><code class="js">
render() {
	if (!this.state.status) {
		return null;
	}
	return (&lt;h2&gt;Yes&lt;/h2&gt;);
}
</code></pre>
