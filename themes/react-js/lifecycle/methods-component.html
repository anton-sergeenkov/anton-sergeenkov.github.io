<h2>Методы жизненного цикла (lifecycle methods)</h2>

<!------------------------------------------------------------->
<h4>1. componentDidMount()</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-code-text>componentDidMount()</u-code-text> <u-text-underline>МОНТИРОВАНИЕ (mounting)</u-text-underline> вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов</li>
	<li>Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в <u>componentWillUnmount()</u></li>

	<li>Вы можете сразу вызвать <u>setState()</u>. Это вызовет дополнительный рендер перед тем, как браузер обновит экран. Гарантируется, что пользователь не увидит промежуточное состояние, даже если <u>render()</u> будет вызываться дважды. Подход может вызвать проблемы с производительностью. В большинстве случаев начальное состояние лучше объявить в <u>constructor()</u>. Однако, это может быть необходимо для случаев, когда нужно измерить размер или положение DOM-узла, на основе которого происходит рендер. Например, для модальных окон или всплывающих подсказок</li>
</ul>

<!------------------------------------------------------------->
<h4>2. componentDidUpdate</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-code-text>componentDidUpdate(prevProps, prevState, snapshot)</u-code-text> <u-text-underline>ОБНОВЛЕНИЕ</u-text-underline> вызывается сразу после обновления (изменение пропсов или состояния). Не вызывается при первом рендере</li>
	<li>Метод позволяет работать с DOM при обновлении компонента</li>
</ul>

<hr>
<pre><code class="js">
componentDidUpdate(prevProps) {
	// сравнение пропсов
	if (<u-code>this.props.userID</u-code> !== <u-code>prevProps.userID</u-code>) {
		this.fetchData(this.props.userID);
	}
}
</code></pre>

<ul class="list-point">
    <li>Метод подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться</li>
    <li>В методе можно вызывать <u>setState()</u>, однако его необходимо обернуть в условие, как в примере выше, чтобы не возник бесконечный цикл. Вызов <u>setState()</u> влечет за собой дополнительный рендер, который незаметен для пользователя, но может повлиять на производительность компонента. Вместо «отражения» пропсов в состоянии рекомендуется использовать пропсы напрямую</li>
</ul>

<!------------------------------------------------------------->
<h4>3. componentWillUnmount()</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-code-text>componentWillUnmount()</u-code-text> <u-text-underline>РАЗМОНТИРОВАНИЕ (unmounting)</u-text-underline> вызывается перед размонтированием и удалением компонента (после удаления DOM-узла, созданного компонентом)</li>
	<li>В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в <u>componentDidMount()</u></li>
	<li>Не используйте <u>setState()</u> в методе, так как компонент никогда не рендерится повторно. После того, как экземпляр компонента будет размонтирован, он никогда не будет примонтирован снова</li>
</ul>

<!------------------------------------------------------------->
<h4>componentDidCatch</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-code-text>componentDidCatch(error, info)</u-code-text><u-text-underline>ОБРАБОТКА ОШИБОК</u-text-underline> если произошла ошибка в процессе рендеринга, методе жизненного цикла или конструкторе любого дочернего компонента</li>
	<li><u-code-text>error</u-code-text> - перехваченная ошибка</li>
	<li><u-code-text>info</u-code-text> - объект с ключом <u>componentStack</u>, содержащий информацию о компоненте, в котором произошла ошибка</li>
	<li>Метод вызывается во время этапа «фиксации», поэтому здесь можно использовать побочные эффекты. Метод можно использовать для логирования ошибок</li>
	<li>В случае ошибки вы можете рендерить запасной интерфейс с помощью <u>getDerivedStateFromError()</u></li>
</ul>
