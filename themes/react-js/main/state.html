<h2>Состояние React-компонентов</h2>

<ul class="list-point">
	<li><u-text-define>Состояние» (state)</u-text-define> - контролируется и доступно только конкретному компоненту</li>
	<li>Нельзя меня состояние напрямую, иначе повторного рендера не происходит</li>
	<li>Конструктор - это единственное место, где можно присвоить значение <u-code-text>this.state</u-code-text> напрямую</li>

	<hr>
	<li>Состояние доступно только для самого компонента и скрыто от других</li>
	<li>Этот процесс называется <u>«нисходящим» («top-down»)</u> или <u>«однонаправленным» («unidirectional»)</u> потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов</li>

	<hr>
	<li><u-code-text>super(props)</u-code-text> - передаём <u-code-text>props</u-code-text> базовому (родительскому) конструктору. Классовые компоненты всегда должны вызывать базовый конструктор с аргументом <u-code-text>props</u-code-text></li>

	<hr>
	<li>React способствовал популяризации функционального программирования в мире Javascript. Это привело к тому, что в мире фреймворков Javascript все больше стали появляться паттерны, основанные на компонентно-ориентированной архитектуре UI, которая используется в React. И теперь всеобщая одержимость функциональным программированием все больше и больше проявляется в мире веб-разработки</li>
</ul>

<ul class="list-point">
    <li><u-menu-code>setState</u-menu-code> - добавляет в очередь изменения в состоянии компонента. Также он указывает React, что компонент и его дочерние элементы должны быть повторно отрендерены с обновлённым состоянием. Этот метод используется для обновления интерфейса в ответ на обработчики событий и ответы сервера</li>
    <ul class="list-point">
        <li><u-code-text>&#9776; updater</u-code-text> - значения state для обновления</li>
        <li><u-code-text>callback</u-code-text> - гарантированно вызывается после того как было применено обновление</li>
    </ul>
</ul>

<hr>

<v-two-code type="js;js" comment="правильно;неправильно">
<template v-slot:first>
this.<u-code>setState</u-code>({comment: 'Привет'});
</template>
<template v-slot:last>
this.state.comment = 'Привет';
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Асинхронное обновления состояния</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Обновления состояния могут быть асинхронными</li>
	<li>React может сгруппировать несколько вызовов <u-code-text>setState()</u-code-text> в одно обновление для улучшения производительности</li>
	<li>Поскольку <u-code-text>this.props</u-code-text> и <u-code-text>this.state</u-code-text> могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния</li>
</ul>

<pre><code class="js"><u-code-title>Неправильно: код может не обновить счётчик</u-code-title>
this.setState({
	counter: this.state.counter + this.props.increment,
});
</code></pre>

<ul class="list-point">
	<li>Второй вариант вызова <u-code-text>setState()</u-code-text>, принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента</li>
</ul>

<v-two-code type="js;js" comment="стрелочная функция;обычная функция">
<template v-slot:first>
this.setState((state, props) => ({
	counter: state.counter + props.increment
}));
</template>
<template v-slot:last>
this.setState(function(state, props) {
	return {
		counter: state.counter + props.increment
	};
});
</template>
</v-two-code>
