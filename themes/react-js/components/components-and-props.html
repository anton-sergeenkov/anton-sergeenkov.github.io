<h2>Компоненты и пропсы</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Функциональные и классовые компоненты</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="Функциональный;Классовый">
<template v-slot:first>
function Welcome(props) {
	return &lt;h1&gt;Привет, {props.name}&lt;/h1&gt;;
}
// она получает данные через props
// возвращает React-элемент
</template>
<template v-slot:last>
class Welcome extends React.Component {
	render() {
		return &lt;h1&gt;Привет, {this.props.name}&lt;/h1&gt;;
	}
}
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Импорт</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="React.Component;Component">
<template v-slot:first>
import React from 'react';
export default class Logo extends <u-code>React.Component</u-code> {
	//
}
</template>
<template v-slot:last>
import React, {Component} from 'react';
export default class App extends <u-code>Component</u-code> {
	//
}
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Экспорт</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="class;export default class">
<template v-slot:first>
class App extends Component {
	//
}
export default App;
</template>
<template v-slot:last>
export default class App extends Component {
	//
}
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Рендеринг</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Элементы могут описывать и наши собственные компоненты</li>
	<li>Когда React встречает подобный элемент, он собирает все JSX-атрибуты в один объект и передаёт их нашему компоненту. Этот объект называется <u>«пропсы» (props)</u></li>
</ul>

<pre><code class="js">
function Welcome(props) {
	return &lt;h1&gt;Привет, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name="Алиса" /&gt;;
ReactDOM.render(element, document.getElementById('root'));
</code></pre>

<ol class="list-num">
	<li>Мы передаём React-элемент <u-code-text>&lt;Welcome name="Алиса" /&gt;</u-code-text> в <u-code-text>ReactDOM.render()</u-code-text></li>
	<li>React вызывает наш компонент <u-code-text>Welcome</u-code-text> с пропсами <u-code-text>{name: 'Алиса'}</u-code-text></li>
	<li>Наш компонент <u-code-text>Welcome</u-code-text> возвращает элемент <u-code-text>&lt;h1&gt;Привет, Алиса&lt;/h1&gt;</u-code-text> в качестве результата</li>
	<li>React DOM делает минимальные изменения в DOM, чтобы получилось <u-code-text>&lt;h1&gt;Привет, Алиса&lt;/h1&gt;</u-code-text></li>
</ol>

<u-message-info>
	Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег. Например, <u-code-text>&lt;div /&gt;</code> это div-тег из HTML, а <u-code-text>&lt;Welcome /&gt;</u-code-text> это уже наш компонент <u-code-text>Welcome</u-code-text>, который должен быть в области видимости
</u-message-info>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Классовые компоненты jsx/js</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="container-flex"><div class="container-half"><pre><code class="js"><code-type>jsx</code-type>
class App extends React.Component {
	render() {
		return &lt;button&gt;Кнопка&lt;/button&gt;;
	}
}
ReactDOM.render(
	&lt;App /&gt;,
	document.getElementById('root')
);
</code></pre></div><div class="container-half"><pre><code class="js"><code-type>js</code-type>
const e = React.<u-code>createElement</u-code>;
class App extends React.Component {
	render() {
		return <u-code>e</u-code>('button', null, 'Кнопка');
	}
}
ReactDOM.render(
	<u-code>e</u-code>(App),
	document.getElementById('root')
);
</code></pre></div></div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Композиция компонентов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию - компоненты - на любом уровне нашего приложения</li>
</ul>

<pre><code class="js">
function Welcome(props) {
	return &lt;h1&gt;Привет, {props.name}&lt;/h1&gt;;
}
// компонент App может отрендерить компонент Welcome несколько раз
function App() {
	return (
		&lt;div&gt;
			&lt;Welcome name="Алиса" /&gt;
			&lt;Welcome name="Базилио" /&gt;
			&lt;Welcome name="Буратино" /&gt;
		&lt;/div&gt;
	);
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Классовые компоненты с пропсами</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="container-flex"><div class="container-half">
<b>Классовый компонент</b>
<pre><code class="js">
class App extends React.Component {
	<u-code>render()</u-code> {
		return (
			&lt;div&gt;
				&lt;Button name="Кнопка" /&gt;
			&lt;/div&gt;
		);
	}
}
class Button extends React.Component {
	<u-code>render()</u-code> {
		return &lt;button&gt;{<u-code>this.props.name</u-code>}&lt;/button&gt;;
	}
}
ReactDOM.render(
	&lt;App /&gt;,
	document.getElementById('root')
);
</code></pre>
</div><div class="container-half">
<b>Функциональный компонент</b>
<pre><code class="js">
function App() {
	return (
		&lt;div&gt;
			&lt;Button name="Кнопка" /&gt;
		&lt;/div&gt;
	);
}
function Button(props) {
	return &lt;button&gt;{props.name}&lt;/button&gt;;
}
ReactDOM.render(
	&lt;App /&gt;,
	document.getElementById('root')
);
</code></pre>
</div></div>
